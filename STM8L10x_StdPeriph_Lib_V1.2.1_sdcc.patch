diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Doxyfile ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Doxyfile
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Doxyfile	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Doxyfile	2017-08-15 16:34:14.000000000 +0200
***************
*** 0 ****
--- 1,2382 ----
+ # Doxyfile 1.8.7
+    
+ # This file describes the settings to be used by the documentation system
+ # doxygen (www.doxygen.org) for a project.
+ #
+ # All text after a double hash (##) is considered a comment and is placed in
+ # front of the TAG it is preceding.
+ #
+ # All text after a single hash (#) is considered a comment and will be ignored.
+ # The format is:
+ # TAG = value [value, ...]
+ # For lists, items can also be appended using:
+ # TAG += value [value, ...]
+ # Values that contain spaces should be placed between quotes (\" \").
+ 
+ #---------------------------------------------------------------------------
+ # Project related configuration options
+ #---------------------------------------------------------------------------
+ 
+ # This tag specifies the encoding used for all characters in the config file
+ # that follow. The default is UTF-8 which is also the encoding used for all text
+ # before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
+ # built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
+ # for the list of possible encodings.
+ # The default value is: UTF-8.
+ 
+ DOXYFILE_ENCODING      = UTF-8
+ 
+ # The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+ # double-quotes, unless you are using Doxywizard) that should identify the
+ # project for which the documentation is generated. This name is used in the
+ # title of most generated pages and in a few other places.
+ # The default value is: My Project.
+ 
+ PROJECT_NAME           = "STML10x Standard Peripheral Libary"
+ 
+ # The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+ # could be handy for archiving the generated documentation or if some version
+ # control system is used.
+ 
+ PROJECT_NUMBER         = 1.2.1
+ 
+ # Using the PROJECT_BRIEF tag one can provide an optional one line description
+ # for a project that appears at the top of each page and should give viewer a
+ # quick idea about the purpose of the project. Keep the description short.
+ 
+ PROJECT_BRIEF          = 
+ 
+ # With the PROJECT_LOGO tag one can specify an logo or icon that is included in
+ # the documentation. The maximum height of the logo should not exceed 55 pixels
+ # and the maximum width should not exceed 200 pixels. Doxygen will copy the logo
+ # to the output directory.
+ 
+ PROJECT_LOGO           = ./_htmresc/logo.bmp
+ 
+ # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+ # into which the generated documentation will be written. If a relative path is
+ # entered, it will be relative to the location where doxygen was started. If
+ # left blank the current directory will be used.
+ 
+ OUTPUT_DIRECTORY       = ./doxygen
+ 
+ # If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 4096 sub-
+ # directories (in 2 levels) under the output directory of each output format and
+ # will distribute the generated files over these directories. Enabling this
+ # option can be useful when feeding doxygen a huge amount of source files, where
+ # putting all generated files in the same directory would otherwise causes
+ # performance problems for the file system.
+ # The default value is: NO.
+ 
+ CREATE_SUBDIRS         = YES
+ 
+ # If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+ # characters to appear in the names of generated files. If set to NO, non-ASCII
+ # characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+ # U+3044.
+ # The default value is: NO.
+ 
+ ALLOW_UNICODE_NAMES    = YES
+ 
+ # The OUTPUT_LANGUAGE tag is used to specify the language in which all
+ # documentation generated by doxygen is written. Doxygen will use this
+ # information to generate all constant output in the proper language.
+ # Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+ # Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+ # Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+ # Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+ # Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+ # Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+ # Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+ # Ukrainian and Vietnamese.
+ # The default value is: English.
+ 
+ OUTPUT_LANGUAGE        = English
+ 
+ # If the BRIEF_MEMBER_DESC tag is set to YES doxygen will include brief member
+ # descriptions after the members that are listed in the file and class
+ # documentation (similar to Javadoc). Set to NO to disable this.
+ # The default value is: YES.
+ 
+ BRIEF_MEMBER_DESC      = YES
+ 
+ # If the REPEAT_BRIEF tag is set to YES doxygen will prepend the brief
+ # description of a member or function before the detailed description
+ #
+ # Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+ # brief descriptions will be completely suppressed.
+ # The default value is: YES.
+ 
+ REPEAT_BRIEF           = YES
+ 
+ # This tag implements a quasi-intelligent brief description abbreviator that is
+ # used to form the text in various listings. Each string in this list, if found
+ # as the leading text of the brief description, will be stripped from the text
+ # and the result, after processing the whole list, is used as the annotated
+ # text. Otherwise, the brief description is used as-is. If left blank, the
+ # following values are used ($name is automatically replaced with the name of
+ # the entity):The $name class, The $name widget, The $name file, is, provides,
+ # specifies, contains, represents, a, an and the.
+ 
+ ABBREVIATE_BRIEF       = "The $name class" \
+                          "The $name widget" \
+                          "The $name file" \
+                          is \
+                          provides \
+                          specifies \
+                          contains \
+                          represents \
+                          a \
+                          an \
+                          the
+ 
+ # If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+ # doxygen will generate a detailed section even if there is only a brief
+ # description.
+ # The default value is: NO.
+ 
+ ALWAYS_DETAILED_SEC    = NO
+ 
+ # If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+ # inherited members of a class in the documentation of that class as if those
+ # members were ordinary class members. Constructors, destructors and assignment
+ # operators of the base classes will not be shown.
+ # The default value is: NO.
+ 
+ INLINE_INHERITED_MEMB  = NO
+ 
+ # If the FULL_PATH_NAMES tag is set to YES doxygen will prepend the full path
+ # before files name in the file list and in the header files. If set to NO the
+ # shortest path that makes the file name unique will be used
+ # The default value is: YES.
+ 
+ FULL_PATH_NAMES        = YES
+ 
+ # The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+ # Stripping is only done if one of the specified strings matches the left-hand
+ # part of the path. The tag can be used to show relative paths in the file list.
+ # If left blank the directory from which doxygen is run is used as the path to
+ # strip.
+ #
+ # Note that you can specify absolute paths here, but also relative paths, which
+ # will be relative from the directory where doxygen is started.
+ # This tag requires that the tag FULL_PATH_NAMES is set to YES.
+ 
+ STRIP_FROM_PATH        = 
+ 
+ # The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+ # path mentioned in the documentation of a class, which tells the reader which
+ # header file to include in order to use a class. If left blank only the name of
+ # the header file containing the class definition is used. Otherwise one should
+ # specify the list of include paths that are normally passed to the compiler
+ # using the -I flag.
+ 
+ STRIP_FROM_INC_PATH    = 
+ 
+ # If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+ # less readable) file names. This can be useful is your file systems doesn't
+ # support long names like on DOS, Mac, or CD-ROM.
+ # The default value is: NO.
+ 
+ SHORT_NAMES            = NO
+ 
+ # If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+ # first line (until the first dot) of a Javadoc-style comment as the brief
+ # description. If set to NO, the Javadoc-style will behave just like regular Qt-
+ # style comments (thus requiring an explicit @brief command for a brief
+ # description.)
+ # The default value is: NO.
+ 
+ JAVADOC_AUTOBRIEF      = NO
+ 
+ # If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+ # line (until the first dot) of a Qt-style comment as the brief description. If
+ # set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+ # requiring an explicit \brief command for a brief description.)
+ # The default value is: NO.
+ 
+ QT_AUTOBRIEF           = NO
+ 
+ # The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+ # multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+ # a brief description. This used to be the default behavior. The new default is
+ # to treat a multi-line C++ comment block as a detailed description. Set this
+ # tag to YES if you prefer the old behavior instead.
+ #
+ # Note that setting this tag to YES also means that rational rose comments are
+ # not recognized any more.
+ # The default value is: NO.
+ 
+ MULTILINE_CPP_IS_BRIEF = NO
+ 
+ # If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+ # documentation from any documented member that it re-implements.
+ # The default value is: YES.
+ 
+ INHERIT_DOCS           = YES
+ 
+ # If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce a
+ # new page for each member. If set to NO, the documentation of a member will be
+ # part of the file/class/namespace that contains it.
+ # The default value is: NO.
+ 
+ SEPARATE_MEMBER_PAGES  = NO
+ 
+ # The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+ # uses this value to replace tabs by spaces in code fragments.
+ # Minimum value: 1, maximum value: 16, default value: 4.
+ 
+ TAB_SIZE               = 4
+ 
+ # This tag can be used to specify a number of aliases that act as commands in
+ # the documentation. An alias has the form:
+ # name=value
+ # For example adding
+ # "sideeffect=@par Side Effects:\n"
+ # will allow you to put the command \sideeffect (or @sideeffect) in the
+ # documentation, which will result in a user-defined paragraph with heading
+ # "Side Effects:". You can put \n's in the value part of an alias to insert
+ # newlines.
+ 
+ ALIASES                = 
+ 
+ # This tag can be used to specify a number of word-keyword mappings (TCL only).
+ # A mapping has the form "name=value". For example adding "class=itcl::class"
+ # will allow you to use the command class in the itcl::class meaning.
+ 
+ TCL_SUBST              = 
+ 
+ # Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+ # only. Doxygen will then generate output that is more tailored for C. For
+ # instance, some of the names that are used will be different. The list of all
+ # members will be omitted, etc.
+ # The default value is: NO.
+ 
+ OPTIMIZE_OUTPUT_FOR_C  = YES
+ 
+ # Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+ # Python sources only. Doxygen will then generate output that is more tailored
+ # for that language. For instance, namespaces will be presented as packages,
+ # qualified scopes will look different, etc.
+ # The default value is: NO.
+ 
+ OPTIMIZE_OUTPUT_JAVA   = NO
+ 
+ # Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+ # sources. Doxygen will then generate output that is tailored for Fortran.
+ # The default value is: NO.
+ 
+ OPTIMIZE_FOR_FORTRAN   = NO
+ 
+ # Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+ # sources. Doxygen will then generate output that is tailored for VHDL.
+ # The default value is: NO.
+ 
+ OPTIMIZE_OUTPUT_VHDL   = NO
+ 
+ # Doxygen selects the parser to use depending on the extension of the files it
+ # parses. With this tag you can assign which parser to use for a given
+ # extension. Doxygen has a built-in mapping, but you can override or extend it
+ # using this tag. The format is ext=language, where ext is a file extension, and
+ # language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+ # C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
+ # FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
+ # Fortran. In the later case the parser tries to guess whether the code is fixed
+ # or free formatted code, this is the default for Fortran type files), VHDL. For
+ # instance to make doxygen treat .inc files as Fortran files (default is PHP),
+ # and .f files as C (default is Fortran), use: inc=Fortran f=C.
+ #
+ # Note For files without extension you can use no_extension as a placeholder.
+ #
+ # Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+ # the files are not read by doxygen.
+ 
+ EXTENSION_MAPPING      = 
+ 
+ # If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+ # according to the Markdown format, which allows for more readable
+ # documentation. See http://daringfireball.net/projects/markdown/ for details.
+ # The output of markdown processing is further processed by doxygen, so you can
+ # mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+ # case of backward compatibilities issues.
+ # The default value is: YES.
+ 
+ MARKDOWN_SUPPORT       = YES
+ 
+ # When enabled doxygen tries to link words that correspond to documented
+ # classes, or namespaces to their corresponding documentation. Such a link can
+ # be prevented in individual cases by by putting a % sign in front of the word
+ # or globally by setting AUTOLINK_SUPPORT to NO.
+ # The default value is: YES.
+ 
+ AUTOLINK_SUPPORT       = YES
+ 
+ # If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+ # to include (a tag file for) the STL sources as input, then you should set this
+ # tag to YES in order to let doxygen match functions declarations and
+ # definitions whose arguments contain STL classes (e.g. func(std::string);
+ # versus func(std::string) {}). This also make the inheritance and collaboration
+ # diagrams that involve STL classes more complete and accurate.
+ # The default value is: NO.
+ 
+ BUILTIN_STL_SUPPORT    = NO
+ 
+ # If you use Microsoft's C++/CLI language, you should set this option to YES to
+ # enable parsing support.
+ # The default value is: NO.
+ 
+ CPP_CLI_SUPPORT        = NO
+ 
+ # Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+ # http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
+ # will parse them like normal C++ but will assume all classes use public instead
+ # of private inheritance when no explicit protection keyword is present.
+ # The default value is: NO.
+ 
+ SIP_SUPPORT            = NO
+ 
+ # For Microsoft's IDL there are propget and propput attributes to indicate
+ # getter and setter methods for a property. Setting this option to YES will make
+ # doxygen to replace the get and set methods by a property in the documentation.
+ # This will only work if the methods are indeed getting or setting a simple
+ # type. If this is not the case, or you want to show the methods anyway, you
+ # should set this option to NO.
+ # The default value is: YES.
+ 
+ IDL_PROPERTY_SUPPORT   = YES
+ 
+ # If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+ # tag is set to YES, then doxygen will reuse the documentation of the first
+ # member in the group (if any) for the other members of the group. By default
+ # all members of a group must be documented explicitly.
+ # The default value is: NO.
+ 
+ DISTRIBUTE_GROUP_DOC   = NO
+ 
+ # Set the SUBGROUPING tag to YES to allow class member groups of the same type
+ # (for instance a group of public functions) to be put as a subgroup of that
+ # type (e.g. under the Public Functions section). Set it to NO to prevent
+ # subgrouping. Alternatively, this can be done per class using the
+ # \nosubgrouping command.
+ # The default value is: YES.
+ 
+ SUBGROUPING            = YES
+ 
+ # When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+ # are shown inside the group in which they are included (e.g. using \ingroup)
+ # instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+ # and RTF).
+ #
+ # Note that this feature does not work in combination with
+ # SEPARATE_MEMBER_PAGES.
+ # The default value is: NO.
+ 
+ INLINE_GROUPED_CLASSES = NO
+ 
+ # When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+ # with only public data fields or simple typedef fields will be shown inline in
+ # the documentation of the scope in which they are defined (i.e. file,
+ # namespace, or group documentation), provided this scope is documented. If set
+ # to NO, structs, classes, and unions are shown on a separate page (for HTML and
+ # Man pages) or section (for LaTeX and RTF).
+ # The default value is: NO.
+ 
+ INLINE_SIMPLE_STRUCTS  = NO
+ 
+ # When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+ # enum is documented as struct, union, or enum with the name of the typedef. So
+ # typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+ # with name TypeT. When disabled the typedef will appear as a member of a file,
+ # namespace, or class. And the struct will be named TypeS. This can typically be
+ # useful for C code in case the coding convention dictates that all compound
+ # types are typedef'ed and only the typedef is referenced, never the tag name.
+ # The default value is: NO.
+ 
+ TYPEDEF_HIDES_STRUCT   = NO
+ 
+ # The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+ # cache is used to resolve symbols given their name and scope. Since this can be
+ # an expensive process and often the same symbol appears multiple times in the
+ # code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+ # doxygen will become slower. If the cache is too large, memory is wasted. The
+ # cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+ # is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+ # symbols. At the end of a run doxygen will report the cache usage and suggest
+ # the optimal cache size from a speed point of view.
+ # Minimum value: 0, maximum value: 9, default value: 0.
+ 
+ LOOKUP_CACHE_SIZE      = 0
+ 
+ #---------------------------------------------------------------------------
+ # Build related configuration options
+ #---------------------------------------------------------------------------
+ 
+ # If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+ # documentation are documented, even if no documentation was available. Private
+ # class members and static file members will be hidden unless the
+ # EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+ # Note: This will also disable the warnings about undocumented members that are
+ # normally produced when WARNINGS is set to YES.
+ # The default value is: NO.
+ 
+ EXTRACT_ALL            = NO
+ 
+ # If the EXTRACT_PRIVATE tag is set to YES all private members of a class will
+ # be included in the documentation.
+ # The default value is: NO.
+ 
+ EXTRACT_PRIVATE        = NO
+ 
+ # If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
+ # scope will be included in the documentation.
+ # The default value is: NO.
+ 
+ EXTRACT_PACKAGE        = NO
+ 
+ # If the EXTRACT_STATIC tag is set to YES all static members of a file will be
+ # included in the documentation.
+ # The default value is: NO.
+ 
+ EXTRACT_STATIC         = NO
+ 
+ # If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) defined
+ # locally in source files will be included in the documentation. If set to NO
+ # only classes defined in header files are included. Does not have any effect
+ # for Java sources.
+ # The default value is: YES.
+ 
+ EXTRACT_LOCAL_CLASSES  = YES
+ 
+ # This flag is only useful for Objective-C code. When set to YES local methods,
+ # which are defined in the implementation section but not in the interface are
+ # included in the documentation. If set to NO only methods in the interface are
+ # included.
+ # The default value is: NO.
+ 
+ EXTRACT_LOCAL_METHODS  = NO
+ 
+ # If this flag is set to YES, the members of anonymous namespaces will be
+ # extracted and appear in the documentation as a namespace called
+ # 'anonymous_namespace{file}', where file will be replaced with the base name of
+ # the file that contains the anonymous namespace. By default anonymous namespace
+ # are hidden.
+ # The default value is: NO.
+ 
+ EXTRACT_ANON_NSPACES   = NO
+ 
+ # If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+ # undocumented members inside documented classes or files. If set to NO these
+ # members will be included in the various overviews, but no documentation
+ # section is generated. This option has no effect if EXTRACT_ALL is enabled.
+ # The default value is: NO.
+ 
+ HIDE_UNDOC_MEMBERS     = NO
+ 
+ # If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+ # undocumented classes that are normally visible in the class hierarchy. If set
+ # to NO these classes will be included in the various overviews. This option has
+ # no effect if EXTRACT_ALL is enabled.
+ # The default value is: NO.
+ 
+ HIDE_UNDOC_CLASSES     = NO
+ 
+ # If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+ # (class|struct|union) declarations. If set to NO these declarations will be
+ # included in the documentation.
+ # The default value is: NO.
+ 
+ HIDE_FRIEND_COMPOUNDS  = NO
+ 
+ # If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+ # documentation blocks found inside the body of a function. If set to NO these
+ # blocks will be appended to the function's detailed documentation block.
+ # The default value is: NO.
+ 
+ HIDE_IN_BODY_DOCS      = NO
+ 
+ # The INTERNAL_DOCS tag determines if documentation that is typed after a
+ # \internal command is included. If the tag is set to NO then the documentation
+ # will be excluded. Set it to YES to include the internal documentation.
+ # The default value is: NO.
+ 
+ INTERNAL_DOCS          = NO
+ 
+ # If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+ # names in lower-case letters. If set to YES upper-case letters are also
+ # allowed. This is useful if you have classes or files whose names only differ
+ # in case and if your file system supports case sensitive file names. Windows
+ # and Mac users are advised to set this option to NO.
+ # The default value is: system dependent.
+ 
+ CASE_SENSE_NAMES       = NO
+ 
+ # If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+ # their full class and namespace scopes in the documentation. If set to YES the
+ # scope will be hidden.
+ # The default value is: NO.
+ 
+ HIDE_SCOPE_NAMES       = YES
+ 
+ # If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+ # the files that are included by a file in the documentation of that file.
+ # The default value is: YES.
+ 
+ SHOW_INCLUDE_FILES     = YES
+ 
+ # If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+ # grouped member an include statement to the documentation, telling the reader
+ # which file to include in order to use the member.
+ # The default value is: NO.
+ 
+ SHOW_GROUPED_MEMB_INC  = NO
+ 
+ # If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+ # files with double quotes in the documentation rather than with sharp brackets.
+ # The default value is: NO.
+ 
+ FORCE_LOCAL_INCLUDES   = NO
+ 
+ # If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+ # documentation for inline members.
+ # The default value is: YES.
+ 
+ INLINE_INFO            = YES
+ 
+ # If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+ # (detailed) documentation of file and class members alphabetically by member
+ # name. If set to NO the members will appear in declaration order.
+ # The default value is: YES.
+ 
+ SORT_MEMBER_DOCS       = YES
+ 
+ # If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+ # descriptions of file, namespace and class members alphabetically by member
+ # name. If set to NO the members will appear in declaration order. Note that
+ # this will also influence the order of the classes in the class list.
+ # The default value is: NO.
+ 
+ SORT_BRIEF_DOCS        = NO
+ 
+ # If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+ # (brief and detailed) documentation of class members so that constructors and
+ # destructors are listed first. If set to NO the constructors will appear in the
+ # respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+ # Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+ # member documentation.
+ # Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+ # detailed member documentation.
+ # The default value is: NO.
+ 
+ SORT_MEMBERS_CTORS_1ST = NO
+ 
+ # If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+ # of group names into alphabetical order. If set to NO the group names will
+ # appear in their defined order.
+ # The default value is: NO.
+ 
+ SORT_GROUP_NAMES       = NO
+ 
+ # If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+ # fully-qualified names, including namespaces. If set to NO, the class list will
+ # be sorted only by class name, not including the namespace part.
+ # Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+ # Note: This option applies only to the class list, not to the alphabetical
+ # list.
+ # The default value is: NO.
+ 
+ SORT_BY_SCOPE_NAME     = NO
+ 
+ # If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+ # type resolution of all parameters of a function it will reject a match between
+ # the prototype and the implementation of a member function even if there is
+ # only one candidate or it is obvious which candidate to choose by doing a
+ # simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+ # accept a match between prototype and implementation in such cases.
+ # The default value is: NO.
+ 
+ STRICT_PROTO_MATCHING  = NO
+ 
+ # The GENERATE_TODOLIST tag can be used to enable ( YES) or disable ( NO) the
+ # todo list. This list is created by putting \todo commands in the
+ # documentation.
+ # The default value is: YES.
+ 
+ GENERATE_TODOLIST      = YES
+ 
+ # The GENERATE_TESTLIST tag can be used to enable ( YES) or disable ( NO) the
+ # test list. This list is created by putting \test commands in the
+ # documentation.
+ # The default value is: YES.
+ 
+ GENERATE_TESTLIST      = YES
+ 
+ # The GENERATE_BUGLIST tag can be used to enable ( YES) or disable ( NO) the bug
+ # list. This list is created by putting \bug commands in the documentation.
+ # The default value is: YES.
+ 
+ GENERATE_BUGLIST       = YES
+ 
+ # The GENERATE_DEPRECATEDLIST tag can be used to enable ( YES) or disable ( NO)
+ # the deprecated list. This list is created by putting \deprecated commands in
+ # the documentation.
+ # The default value is: YES.
+ 
+ GENERATE_DEPRECATEDLIST= YES
+ 
+ # The ENABLED_SECTIONS tag can be used to enable conditional documentation
+ # sections, marked by \if <section_label> ... \endif and \cond <section_label>
+ # ... \endcond blocks.
+ 
+ ENABLED_SECTIONS       = 
+ 
+ # The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+ # initial value of a variable or macro / define can have for it to appear in the
+ # documentation. If the initializer consists of more lines than specified here
+ # it will be hidden. Use a value of 0 to hide initializers completely. The
+ # appearance of the value of individual variables and macros / defines can be
+ # controlled using \showinitializer or \hideinitializer command in the
+ # documentation regardless of this setting.
+ # Minimum value: 0, maximum value: 10000, default value: 30.
+ 
+ MAX_INITIALIZER_LINES  = 30
+ 
+ # Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+ # the bottom of the documentation of classes and structs. If set to YES the list
+ # will mention the files that were used to generate the documentation.
+ # The default value is: YES.
+ 
+ SHOW_USED_FILES        = YES
+ 
+ # Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+ # will remove the Files entry from the Quick Index and from the Folder Tree View
+ # (if specified).
+ # The default value is: YES.
+ 
+ SHOW_FILES             = YES
+ 
+ # Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+ # page. This will remove the Namespaces entry from the Quick Index and from the
+ # Folder Tree View (if specified).
+ # The default value is: YES.
+ 
+ SHOW_NAMESPACES        = YES
+ 
+ # The FILE_VERSION_FILTER tag can be used to specify a program or script that
+ # doxygen should invoke to get the current version for each file (typically from
+ # the version control system). Doxygen will invoke the program by executing (via
+ # popen()) the command command input-file, where command is the value of the
+ # FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+ # by doxygen. Whatever the program writes to standard output is used as the file
+ # version. For an example see the documentation.
+ 
+ FILE_VERSION_FILTER    = 
+ 
+ # The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+ # by doxygen. The layout file controls the global structure of the generated
+ # output files in an output format independent way. To create the layout file
+ # that represents doxygen's defaults, run doxygen with the -l option. You can
+ # optionally specify a file name after the option, if omitted DoxygenLayout.xml
+ # will be used as the name of the layout file.
+ #
+ # Note that if you run doxygen from a directory containing a file called
+ # DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+ # tag is left empty.
+ 
+ LAYOUT_FILE            = 
+ 
+ # The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+ # the reference definitions. This must be a list of .bib files. The .bib
+ # extension is automatically appended if omitted. This requires the bibtex tool
+ # to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
+ # For LaTeX the style of the bibliography can be controlled using
+ # LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+ # search path. Do not use file names with spaces, bibtex cannot handle them. See
+ # also \cite for info how to create references.
+ 
+ CITE_BIB_FILES         = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to warning and progress messages
+ #---------------------------------------------------------------------------
+ 
+ # The QUIET tag can be used to turn on/off the messages that are generated to
+ # standard output by doxygen. If QUIET is set to YES this implies that the
+ # messages are off.
+ # The default value is: NO.
+ 
+ QUIET                  = NO
+ 
+ # The WARNINGS tag can be used to turn on/off the warning messages that are
+ # generated to standard error ( stderr) by doxygen. If WARNINGS is set to YES
+ # this implies that the warnings are on.
+ #
+ # Tip: Turn warnings on while writing the documentation.
+ # The default value is: YES.
+ 
+ WARNINGS               = YES
+ 
+ # If the WARN_IF_UNDOCUMENTED tag is set to YES, then doxygen will generate
+ # warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+ # will automatically be disabled.
+ # The default value is: YES.
+ 
+ WARN_IF_UNDOCUMENTED   = YES
+ 
+ # If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+ # potential errors in the documentation, such as not documenting some parameters
+ # in a documented function, or documenting parameters that don't exist or using
+ # markup commands wrongly.
+ # The default value is: YES.
+ 
+ WARN_IF_DOC_ERROR      = YES
+ 
+ # This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+ # are documented, but have no documentation for their parameters or return
+ # value. If set to NO doxygen will only warn about wrong or incomplete parameter
+ # documentation, but not about the absence of documentation.
+ # The default value is: NO.
+ 
+ WARN_NO_PARAMDOC       = NO
+ 
+ # The WARN_FORMAT tag determines the format of the warning messages that doxygen
+ # can produce. The string should contain the $file, $line, and $text tags, which
+ # will be replaced by the file and line number from which the warning originated
+ # and the warning text. Optionally the format may contain $version, which will
+ # be replaced by the version of the file (if it could be obtained via
+ # FILE_VERSION_FILTER)
+ # The default value is: $file:$line: $text.
+ 
+ WARN_FORMAT            = "$file:$line: $text"
+ 
+ # The WARN_LOGFILE tag can be used to specify a file to which warning and error
+ # messages should be written. If left blank the output is written to standard
+ # error (stderr).
+ 
+ WARN_LOGFILE           = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the input files
+ #---------------------------------------------------------------------------
+ 
+ # The INPUT tag is used to specify the files and/or directories that contain
+ # documented source files. You may enter file names like myfile.cpp or
+ # directories like /usr/src/myproject. Separate the files or directories with
+ # spaces.
+ # Note: If this tag is empty the current directory is searched.
+ 
+ INPUT                  = ./Libraries \
+                          ./Utilities
+ 
+ # This tag can be used to specify the character encoding of the source files
+ # that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+ # libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+ # documentation (see: http://www.gnu.org/software/libiconv) for the list of
+ # possible encodings.
+ # The default value is: UTF-8.
+ 
+ INPUT_ENCODING         = UTF-8
+ 
+ # If the value of the INPUT tag contains directories, you can use the
+ # FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+ # *.h) to filter out the source-files in the directories. If left blank the
+ # following patterns are tested:*.c, *.cc, *.cxx, *.cpp, *.c++, *.java, *.ii,
+ # *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp,
+ # *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown,
+ # *.md, *.mm, *.dox, *.py, *.f90, *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf,
+ # *.qsf, *.as and *.js.
+ 
+ FILE_PATTERNS          = *.c \
+                          *.cc \
+                          *.cxx \
+                          *.cpp \
+                          *.c++ \
+                          *.java \
+                          *.ii \
+                          *.ixx \
+                          *.ipp \
+                          *.i++ \
+                          *.inl \
+                          *.idl \
+                          *.ddl \
+                          *.odl \
+                          *.h \
+                          *.hh \
+                          *.hxx \
+                          *.hpp \
+                          *.h++ \
+                          *.cs \
+                          *.d \
+                          *.php \
+                          *.php4 \
+                          *.php5 \
+                          *.phtml \
+                          *.inc \
+                          *.m \
+                          *.markdown \
+                          *.md \
+                          *.mm \
+                          *.dox \
+                          *.py \
+                          *.f90 \
+                          *.f \
+                          *.for \
+                          *.tcl \
+                          *.vhd \
+                          *.vhdl \
+                          *.ucf \
+                          *.qsf \
+                          *.as \
+                          *.js
+ 
+ # The RECURSIVE tag can be used to specify whether or not subdirectories should
+ # be searched for input files as well.
+ # The default value is: NO.
+ 
+ RECURSIVE              = YES
+ 
+ # The EXCLUDE tag can be used to specify files and/or directories that should be
+ # excluded from the INPUT source files. This way you can easily exclude a
+ # subdirectory from a directory tree whose root is specified with the INPUT tag.
+ #
+ # Note that relative paths are relative to the directory from which doxygen is
+ # run.
+ 
+ EXCLUDE                = 
+ 
+ # The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+ # directories that are symbolic links (a Unix file system feature) are excluded
+ # from the input.
+ # The default value is: NO.
+ 
+ EXCLUDE_SYMLINKS       = NO
+ 
+ # If the value of the INPUT tag contains directories, you can use the
+ # EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+ # certain files from those directories.
+ #
+ # Note that the wildcards are matched against the file with absolute path, so to
+ # exclude all test directories for example use the pattern */test/*
+ 
+ EXCLUDE_PATTERNS       = 
+ 
+ # The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+ # (namespaces, classes, functions, etc.) that should be excluded from the
+ # output. The symbol name can be a fully qualified name, a word, or if the
+ # wildcard * is used, a substring. Examples: ANamespace, AClass,
+ # AClass::ANamespace, ANamespace::*Test
+ #
+ # Note that the wildcards are matched against the file with absolute path, so to
+ # exclude all test directories use the pattern */test/*
+ 
+ EXCLUDE_SYMBOLS        = 
+ 
+ # The EXAMPLE_PATH tag can be used to specify one or more files or directories
+ # that contain example code fragments that are included (see the \include
+ # command).
+ 
+ EXAMPLE_PATH           = 
+ 
+ # If the value of the EXAMPLE_PATH tag contains directories, you can use the
+ # EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+ # *.h) to filter out the source-files in the directories. If left blank all
+ # files are included.
+ 
+ EXAMPLE_PATTERNS       = *
+ 
+ # If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+ # searched for input files to be used with the \include or \dontinclude commands
+ # irrespective of the value of the RECURSIVE tag.
+ # The default value is: NO.
+ 
+ EXAMPLE_RECURSIVE      = NO
+ 
+ # The IMAGE_PATH tag can be used to specify one or more files or directories
+ # that contain images that are to be included in the documentation (see the
+ # \image command).
+ 
+ IMAGE_PATH             = 
+ 
+ # The INPUT_FILTER tag can be used to specify a program that doxygen should
+ # invoke to filter for each input file. Doxygen will invoke the filter program
+ # by executing (via popen()) the command:
+ #
+ # <filter> <input-file>
+ #
+ # where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+ # name of an input file. Doxygen will then use the output that the filter
+ # program writes to standard output. If FILTER_PATTERNS is specified, this tag
+ # will be ignored.
+ #
+ # Note that the filter must not add or remove lines; it is applied before the
+ # code is scanned, but not when the output code is generated. If lines are added
+ # or removed, the anchors will not be placed correctly.
+ 
+ INPUT_FILTER           = 
+ 
+ # The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+ # basis. Doxygen will compare the file name with each pattern and apply the
+ # filter if there is a match. The filters are a list of the form: pattern=filter
+ # (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+ # filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+ # patterns match the file name, INPUT_FILTER is applied.
+ 
+ FILTER_PATTERNS        = 
+ 
+ # If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+ # INPUT_FILTER ) will also be used to filter the input files that are used for
+ # producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+ # The default value is: NO.
+ 
+ FILTER_SOURCE_FILES    = NO
+ 
+ # The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+ # pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+ # it is also possible to disable source filtering for a specific pattern using
+ # *.ext= (so without naming a filter).
+ # This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+ 
+ FILTER_SOURCE_PATTERNS = 
+ 
+ # If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+ # is part of the input, its contents will be placed on the main page
+ # (index.html). This can be useful if you have a project on for instance GitHub
+ # and want to reuse the introduction page also for the doxygen output.
+ 
+ USE_MDFILE_AS_MAINPAGE = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to source browsing
+ #---------------------------------------------------------------------------
+ 
+ # If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+ # generated. Documented entities will be cross-referenced with these sources.
+ #
+ # Note: To get rid of all source code in the generated output, make sure that
+ # also VERBATIM_HEADERS is set to NO.
+ # The default value is: NO.
+ 
+ SOURCE_BROWSER         = YES
+ 
+ # Setting the INLINE_SOURCES tag to YES will include the body of functions,
+ # classes and enums directly into the documentation.
+ # The default value is: NO.
+ 
+ INLINE_SOURCES         = YES
+ 
+ # Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+ # special comment blocks from generated source code fragments. Normal C, C++ and
+ # Fortran comments will always remain visible.
+ # The default value is: YES.
+ 
+ STRIP_CODE_COMMENTS    = YES
+ 
+ # If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+ # function all documented functions referencing it will be listed.
+ # The default value is: NO.
+ 
+ REFERENCED_BY_RELATION = NO
+ 
+ # If the REFERENCES_RELATION tag is set to YES then for each documented function
+ # all documented entities called/used by that function will be listed.
+ # The default value is: NO.
+ 
+ REFERENCES_RELATION    = NO
+ 
+ # If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+ # to YES, then the hyperlinks from functions in REFERENCES_RELATION and
+ # REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+ # link to the documentation.
+ # The default value is: YES.
+ 
+ REFERENCES_LINK_SOURCE = YES
+ 
+ # If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+ # source code will show a tooltip with additional information such as prototype,
+ # brief description and links to the definition and documentation. Since this
+ # will make the HTML file larger and loading of large files a bit slower, you
+ # can opt to disable this feature.
+ # The default value is: YES.
+ # This tag requires that the tag SOURCE_BROWSER is set to YES.
+ 
+ SOURCE_TOOLTIPS        = YES
+ 
+ # If the USE_HTAGS tag is set to YES then the references to source code will
+ # point to the HTML generated by the htags(1) tool instead of doxygen built-in
+ # source browser. The htags tool is part of GNU's global source tagging system
+ # (see http://www.gnu.org/software/global/global.html). You will need version
+ # 4.8.6 or higher.
+ #
+ # To use it do the following:
+ # - Install the latest version of global
+ # - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+ # - Make sure the INPUT points to the root of the source tree
+ # - Run doxygen as normal
+ #
+ # Doxygen will invoke htags (and that will in turn invoke gtags), so these
+ # tools must be available from the command line (i.e. in the search path).
+ #
+ # The result: instead of the source browser generated by doxygen, the links to
+ # source code will now point to the output of htags.
+ # The default value is: NO.
+ # This tag requires that the tag SOURCE_BROWSER is set to YES.
+ 
+ USE_HTAGS              = NO
+ 
+ # If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+ # verbatim copy of the header file for each class for which an include is
+ # specified. Set to NO to disable this.
+ # See also: Section \class.
+ # The default value is: YES.
+ 
+ VERBATIM_HEADERS       = YES
+ 
+ # If the CLANG_ASSISTED_PARSING tag is set to YES, then doxygen will use the
+ # clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
+ # cost of reduced performance. This can be particularly helpful with template
+ # rich C++ code for which doxygen's built-in parser lacks the necessary type
+ # information.
+ # Note: The availability of this option depends on whether or not doxygen was
+ # compiled with the --with-libclang option.
+ # The default value is: NO.
+ 
+ CLANG_ASSISTED_PARSING = NO
+ 
+ # If clang assisted parsing is enabled you can provide the compiler with command
+ # line options that you would normally use when invoking the compiler. Note that
+ # the include paths will already be set by doxygen for the files and directories
+ # specified with INPUT and INCLUDE_PATH.
+ # This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+ 
+ CLANG_OPTIONS          = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the alphabetical class index
+ #---------------------------------------------------------------------------
+ 
+ # If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+ # compounds will be generated. Enable this if the project contains a lot of
+ # classes, structs, unions or interfaces.
+ # The default value is: YES.
+ 
+ ALPHABETICAL_INDEX     = YES
+ 
+ # The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+ # which the alphabetical index list will be split.
+ # Minimum value: 1, maximum value: 20, default value: 5.
+ # This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+ 
+ COLS_IN_ALPHA_INDEX    = 5
+ 
+ # In case all classes in a project start with a common prefix, all classes will
+ # be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+ # can be used to specify a prefix (or a list of prefixes) that should be ignored
+ # while generating the index headers.
+ # This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+ 
+ IGNORE_PREFIX          = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the HTML output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_HTML tag is set to YES doxygen will generate HTML output
+ # The default value is: YES.
+ 
+ GENERATE_HTML          = YES
+ 
+ # The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+ # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+ # it.
+ # The default directory is: html.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_OUTPUT            = html
+ 
+ # The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+ # generated HTML page (for example: .htm, .php, .asp).
+ # The default value is: .html.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_FILE_EXTENSION    = .html
+ 
+ # The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+ # each generated HTML page. If the tag is left blank doxygen will generate a
+ # standard header.
+ #
+ # To get valid HTML the header file that includes any scripts and style sheets
+ # that doxygen needs, which is dependent on the configuration options used (e.g.
+ # the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+ # default header using
+ # doxygen -w html new_header.html new_footer.html new_stylesheet.css
+ # YourConfigFile
+ # and then modify the file new_header.html. See also section "Doxygen usage"
+ # for information on how to generate the default header that doxygen normally
+ # uses.
+ # Note: The header is subject to change so you typically have to regenerate the
+ # default header when upgrading to a newer version of doxygen. For a description
+ # of the possible markers and block names see the documentation.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_HEADER            = 
+ 
+ # The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+ # generated HTML page. If the tag is left blank doxygen will generate a standard
+ # footer. See HTML_HEADER for more information on how to generate a default
+ # footer and what special commands can be used inside the footer. See also
+ # section "Doxygen usage" for information on how to generate the default footer
+ # that doxygen normally uses.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_FOOTER            = 
+ 
+ # The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+ # sheet that is used by each HTML page. It can be used to fine-tune the look of
+ # the HTML output. If left blank doxygen will generate a default style sheet.
+ # See also section "Doxygen usage" for information on how to generate the style
+ # sheet that doxygen normally uses.
+ # Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+ # it is more robust and this tag (HTML_STYLESHEET) will in the future become
+ # obsolete.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_STYLESHEET        = 
+ 
+ # The HTML_EXTRA_STYLESHEET tag can be used to specify an additional user-
+ # defined cascading style sheet that is included after the standard style sheets
+ # created by doxygen. Using this option one can overrule certain style aspects.
+ # This is preferred over using HTML_STYLESHEET since it does not replace the
+ # standard style sheet and is therefor more robust against future updates.
+ # Doxygen will copy the style sheet file to the output directory. For an example
+ # see the documentation.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_EXTRA_STYLESHEET  = 
+ 
+ # The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+ # other source files which should be copied to the HTML output directory. Note
+ # that these files will be copied to the base HTML output directory. Use the
+ # $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+ # files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+ # files will be copied as-is; there are no commands or markers available.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_EXTRA_FILES       = 
+ 
+ # The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+ # will adjust the colors in the stylesheet and background images according to
+ # this color. Hue is specified as an angle on a colorwheel, see
+ # http://en.wikipedia.org/wiki/Hue for more information. For instance the value
+ # 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+ # purple, and 360 is red again.
+ # Minimum value: 0, maximum value: 359, default value: 220.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_COLORSTYLE_HUE    = 220
+ 
+ # The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+ # in the HTML output. For a value of 0 the output will use grayscales only. A
+ # value of 255 will produce the most vivid colors.
+ # Minimum value: 0, maximum value: 255, default value: 100.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_COLORSTYLE_SAT    = 100
+ 
+ # The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+ # luminance component of the colors in the HTML output. Values below 100
+ # gradually make the output lighter, whereas values above 100 make the output
+ # darker. The value divided by 100 is the actual gamma applied, so 80 represents
+ # a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+ # change the gamma.
+ # Minimum value: 40, maximum value: 240, default value: 80.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_COLORSTYLE_GAMMA  = 80
+ 
+ # If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+ # page will contain the date and time when the page was generated. Setting this
+ # to NO can help when comparing the output of multiple runs.
+ # The default value is: YES.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_TIMESTAMP         = YES
+ 
+ # If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+ # documentation will contain sections that can be hidden and shown after the
+ # page has loaded.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_DYNAMIC_SECTIONS  = NO
+ 
+ # With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+ # shown in the various tree structured indices initially; the user can expand
+ # and collapse entries dynamically later on. Doxygen will expand the tree to
+ # such a level that at most the specified number of entries are visible (unless
+ # a fully collapsed tree already exceeds this amount). So setting the number of
+ # entries 1 will produce a full collapsed tree by default. 0 is a special value
+ # representing an infinite number of entries and will result in a full expanded
+ # tree by default.
+ # Minimum value: 0, maximum value: 9999, default value: 100.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ HTML_INDEX_NUM_ENTRIES = 100
+ 
+ # If the GENERATE_DOCSET tag is set to YES, additional index files will be
+ # generated that can be used as input for Apple's Xcode 3 integrated development
+ # environment (see: http://developer.apple.com/tools/xcode/), introduced with
+ # OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
+ # Makefile in the HTML output directory. Running make will produce the docset in
+ # that directory and running make install will install the docset in
+ # ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+ # startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+ # for more information.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ GENERATE_DOCSET        = NO
+ 
+ # This tag determines the name of the docset feed. A documentation feed provides
+ # an umbrella under which multiple documentation sets from a single provider
+ # (such as a company or product suite) can be grouped.
+ # The default value is: Doxygen generated docs.
+ # This tag requires that the tag GENERATE_DOCSET is set to YES.
+ 
+ DOCSET_FEEDNAME        = "Doxygen generated docs"
+ 
+ # This tag specifies a string that should uniquely identify the documentation
+ # set bundle. This should be a reverse domain-name style string, e.g.
+ # com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+ # The default value is: org.doxygen.Project.
+ # This tag requires that the tag GENERATE_DOCSET is set to YES.
+ 
+ DOCSET_BUNDLE_ID       = org.doxygen.Project
+ 
+ # The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+ # the documentation publisher. This should be a reverse domain-name style
+ # string, e.g. com.mycompany.MyDocSet.documentation.
+ # The default value is: org.doxygen.Publisher.
+ # This tag requires that the tag GENERATE_DOCSET is set to YES.
+ 
+ DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+ 
+ # The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+ # The default value is: Publisher.
+ # This tag requires that the tag GENERATE_DOCSET is set to YES.
+ 
+ DOCSET_PUBLISHER_NAME  = Publisher
+ 
+ # If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+ # additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+ # index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+ # (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+ # Windows.
+ #
+ # The HTML Help Workshop contains a compiler that can convert all HTML output
+ # generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+ # files are now used as the Windows 98 help format, and will replace the old
+ # Windows help format (.hlp) on all Windows platforms in the future. Compressed
+ # HTML files also contain an index, a table of contents, and you can search for
+ # words in the documentation. The HTML workshop also contains a viewer for
+ # compressed HTML files.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ GENERATE_HTMLHELP      = NO
+ 
+ # The CHM_FILE tag can be used to specify the file name of the resulting .chm
+ # file. You can add a path in front of the file if the result should not be
+ # written to the html output directory.
+ # This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+ 
+ CHM_FILE               = 
+ 
+ # The HHC_LOCATION tag can be used to specify the location (absolute path
+ # including file name) of the HTML help compiler ( hhc.exe). If non-empty
+ # doxygen will try to run the HTML help compiler on the generated index.hhp.
+ # The file has to be specified with full path.
+ # This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+ 
+ HHC_LOCATION           = 
+ 
+ # The GENERATE_CHI flag controls if a separate .chi index file is generated (
+ # YES) or that it should be included in the master .chm file ( NO).
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+ 
+ GENERATE_CHI           = NO
+ 
+ # The CHM_INDEX_ENCODING is used to encode HtmlHelp index ( hhk), content ( hhc)
+ # and project file content.
+ # This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+ 
+ CHM_INDEX_ENCODING     = 
+ 
+ # The BINARY_TOC flag controls whether a binary table of contents is generated (
+ # YES) or a normal table of contents ( NO) in the .chm file. Furthermore it
+ # enables the Previous and Next buttons.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+ 
+ BINARY_TOC             = NO
+ 
+ # The TOC_EXPAND flag can be set to YES to add extra items for group members to
+ # the table of contents of the HTML help documentation and to the tree view.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+ 
+ TOC_EXPAND             = NO
+ 
+ # If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+ # QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+ # can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+ # (.qch) of the generated HTML documentation.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ GENERATE_QHP           = NO
+ 
+ # If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+ # the file name of the resulting .qch file. The path specified is relative to
+ # the HTML output folder.
+ # This tag requires that the tag GENERATE_QHP is set to YES.
+ 
+ QCH_FILE               = 
+ 
+ # The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+ # Project output. For more information please see Qt Help Project / Namespace
+ # (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
+ # The default value is: org.doxygen.Project.
+ # This tag requires that the tag GENERATE_QHP is set to YES.
+ 
+ QHP_NAMESPACE          = org.doxygen.Project
+ 
+ # The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+ # Help Project output. For more information please see Qt Help Project / Virtual
+ # Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
+ # folders).
+ # The default value is: doc.
+ # This tag requires that the tag GENERATE_QHP is set to YES.
+ 
+ QHP_VIRTUAL_FOLDER     = doc
+ 
+ # If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+ # filter to add. For more information please see Qt Help Project / Custom
+ # Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+ # filters).
+ # This tag requires that the tag GENERATE_QHP is set to YES.
+ 
+ QHP_CUST_FILTER_NAME   = 
+ 
+ # The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+ # custom filter to add. For more information please see Qt Help Project / Custom
+ # Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+ # filters).
+ # This tag requires that the tag GENERATE_QHP is set to YES.
+ 
+ QHP_CUST_FILTER_ATTRS  = 
+ 
+ # The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+ # project's filter section matches. Qt Help Project / Filter Attributes (see:
+ # http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
+ # This tag requires that the tag GENERATE_QHP is set to YES.
+ 
+ QHP_SECT_FILTER_ATTRS  = 
+ 
+ # The QHG_LOCATION tag can be used to specify the location of Qt's
+ # qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+ # generated .qhp file.
+ # This tag requires that the tag GENERATE_QHP is set to YES.
+ 
+ QHG_LOCATION           = 
+ 
+ # If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+ # generated, together with the HTML files, they form an Eclipse help plugin. To
+ # install this plugin and make it available under the help contents menu in
+ # Eclipse, the contents of the directory containing the HTML and XML files needs
+ # to be copied into the plugins directory of eclipse. The name of the directory
+ # within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+ # After copying Eclipse needs to be restarted before the help appears.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ GENERATE_ECLIPSEHELP   = NO
+ 
+ # A unique identifier for the Eclipse help plugin. When installing the plugin
+ # the directory name containing the HTML and XML files should also have this
+ # name. Each documentation set should have its own identifier.
+ # The default value is: org.doxygen.Project.
+ # This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+ 
+ ECLIPSE_DOC_ID         = org.doxygen.Project
+ 
+ # If you want full control over the layout of the generated HTML pages it might
+ # be necessary to disable the index and replace it with your own. The
+ # DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+ # of each HTML page. A value of NO enables the index and the value YES disables
+ # it. Since the tabs in the index contain the same information as the navigation
+ # tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ DISABLE_INDEX          = NO
+ 
+ # The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+ # structure should be generated to display hierarchical information. If the tag
+ # value is set to YES, a side panel will be generated containing a tree-like
+ # index structure (just like the one that is generated for HTML Help). For this
+ # to work a browser that supports JavaScript, DHTML, CSS and frames is required
+ # (i.e. any modern browser). Windows users are probably better off using the
+ # HTML help feature. Via custom stylesheets (see HTML_EXTRA_STYLESHEET) one can
+ # further fine-tune the look of the index. As an example, the default style
+ # sheet generated by doxygen has an example that shows how to put an image at
+ # the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+ # the same information as the tab index, you could consider setting
+ # DISABLE_INDEX to YES when enabling this option.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ GENERATE_TREEVIEW      = YES
+ 
+ # The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+ # doxygen will group on one line in the generated HTML documentation.
+ #
+ # Note that a value of 0 will completely suppress the enum values from appearing
+ # in the overview section.
+ # Minimum value: 0, maximum value: 20, default value: 4.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ ENUM_VALUES_PER_LINE   = 4
+ 
+ # If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+ # to set the initial width (in pixels) of the frame in which the tree is shown.
+ # Minimum value: 0, maximum value: 1500, default value: 250.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ TREEVIEW_WIDTH         = 250
+ 
+ # When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open links to
+ # external symbols imported via tag files in a separate window.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ EXT_LINKS_IN_WINDOW    = NO
+ 
+ # Use this tag to change the font size of LaTeX formulas included as images in
+ # the HTML documentation. When you change the font size after a successful
+ # doxygen run you need to manually remove any form_*.png images from the HTML
+ # output directory to force them to be regenerated.
+ # Minimum value: 8, maximum value: 50, default value: 10.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ FORMULA_FONTSIZE       = 10
+ 
+ # Use the FORMULA_TRANPARENT tag to determine whether or not the images
+ # generated for formulas are transparent PNGs. Transparent PNGs are not
+ # supported properly for IE 6.0, but are supported on all modern browsers.
+ #
+ # Note that when changing this option you need to delete any form_*.png files in
+ # the HTML output directory before the changes have effect.
+ # The default value is: YES.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ FORMULA_TRANSPARENT    = YES
+ 
+ # Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+ # http://www.mathjax.org) which uses client side Javascript for the rendering
+ # instead of using prerendered bitmaps. Use this if you do not have LaTeX
+ # installed or if you want to formulas look prettier in the HTML output. When
+ # enabled you may also need to install MathJax separately and configure the path
+ # to it using the MATHJAX_RELPATH option.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ USE_MATHJAX            = NO
+ 
+ # When MathJax is enabled you can set the default output format to be used for
+ # the MathJax output. See the MathJax site (see:
+ # http://docs.mathjax.org/en/latest/output.html) for more details.
+ # Possible values are: HTML-CSS (which is slower, but has the best
+ # compatibility), NativeMML (i.e. MathML) and SVG.
+ # The default value is: HTML-CSS.
+ # This tag requires that the tag USE_MATHJAX is set to YES.
+ 
+ MATHJAX_FORMAT         = HTML-CSS
+ 
+ # When MathJax is enabled you need to specify the location relative to the HTML
+ # output directory using the MATHJAX_RELPATH option. The destination directory
+ # should contain the MathJax.js script. For instance, if the mathjax directory
+ # is located at the same level as the HTML output directory, then
+ # MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+ # Content Delivery Network so you can quickly see the result without installing
+ # MathJax. However, it is strongly recommended to install a local copy of
+ # MathJax from http://www.mathjax.org before deployment.
+ # The default value is: http://cdn.mathjax.org/mathjax/latest.
+ # This tag requires that the tag USE_MATHJAX is set to YES.
+ 
+ MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+ 
+ # The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+ # extension names that should be enabled during MathJax rendering. For example
+ # MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+ # This tag requires that the tag USE_MATHJAX is set to YES.
+ 
+ MATHJAX_EXTENSIONS     = 
+ 
+ # The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+ # of code that will be used on startup of the MathJax code. See the MathJax site
+ # (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+ # example see the documentation.
+ # This tag requires that the tag USE_MATHJAX is set to YES.
+ 
+ MATHJAX_CODEFILE       = 
+ 
+ # When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+ # the HTML output. The underlying search engine uses javascript and DHTML and
+ # should work on any modern browser. Note that when using HTML help
+ # (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+ # there is already a search function so this one should typically be disabled.
+ # For large projects the javascript based search engine can be slow, then
+ # enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+ # search using the keyboard; to jump to the search box use <access key> + S
+ # (what the <access key> is depends on the OS and browser, but it is typically
+ # <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+ # key> to jump into the search results window, the results can be navigated
+ # using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+ # the search. The filter options can be selected when the cursor is inside the
+ # search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+ # to select a filter and <Enter> or <escape> to activate or cancel the filter
+ # option.
+ # The default value is: YES.
+ # This tag requires that the tag GENERATE_HTML is set to YES.
+ 
+ SEARCHENGINE           = YES
+ 
+ # When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+ # implemented using a web server instead of a web client using Javascript. There
+ # are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+ # setting. When disabled, doxygen will generate a PHP script for searching and
+ # an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+ # and searching needs to be provided by external tools. See the section
+ # "External Indexing and Searching" for details.
+ # The default value is: NO.
+ # This tag requires that the tag SEARCHENGINE is set to YES.
+ 
+ SERVER_BASED_SEARCH    = NO
+ 
+ # When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+ # script for searching. Instead the search results are written to an XML file
+ # which needs to be processed by an external indexer. Doxygen will invoke an
+ # external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+ # search results.
+ #
+ # Doxygen ships with an example indexer ( doxyindexer) and search engine
+ # (doxysearch.cgi) which are based on the open source search engine library
+ # Xapian (see: http://xapian.org/).
+ #
+ # See the section "External Indexing and Searching" for details.
+ # The default value is: NO.
+ # This tag requires that the tag SEARCHENGINE is set to YES.
+ 
+ EXTERNAL_SEARCH        = NO
+ 
+ # The SEARCHENGINE_URL should point to a search engine hosted by a web server
+ # which will return the search results when EXTERNAL_SEARCH is enabled.
+ #
+ # Doxygen ships with an example indexer ( doxyindexer) and search engine
+ # (doxysearch.cgi) which are based on the open source search engine library
+ # Xapian (see: http://xapian.org/). See the section "External Indexing and
+ # Searching" for details.
+ # This tag requires that the tag SEARCHENGINE is set to YES.
+ 
+ SEARCHENGINE_URL       = 
+ 
+ # When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+ # search data is written to a file for indexing by an external tool. With the
+ # SEARCHDATA_FILE tag the name of this file can be specified.
+ # The default file is: searchdata.xml.
+ # This tag requires that the tag SEARCHENGINE is set to YES.
+ 
+ SEARCHDATA_FILE        = searchdata.xml
+ 
+ # When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+ # EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+ # useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+ # projects and redirect the results back to the right project.
+ # This tag requires that the tag SEARCHENGINE is set to YES.
+ 
+ EXTERNAL_SEARCH_ID     = 
+ 
+ # The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+ # projects other than the one defined by this configuration file, but that are
+ # all added to the same external search index. Each project needs to have a
+ # unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+ # to a relative location where the documentation can be found. The format is:
+ # EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+ # This tag requires that the tag SEARCHENGINE is set to YES.
+ 
+ EXTRA_SEARCH_MAPPINGS  = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the LaTeX output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_LATEX tag is set to YES doxygen will generate LaTeX output.
+ # The default value is: YES.
+ 
+ GENERATE_LATEX         = NO
+ 
+ # The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+ # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+ # it.
+ # The default directory is: latex.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_OUTPUT           = latex
+ 
+ # The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+ # invoked.
+ #
+ # Note that when enabling USE_PDFLATEX this option is only used for generating
+ # bitmaps for formulas in the HTML output, but not in the Makefile that is
+ # written to the output directory.
+ # The default file is: latex.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_CMD_NAME         = latex
+ 
+ # The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+ # index for LaTeX.
+ # The default file is: makeindex.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ MAKEINDEX_CMD_NAME     = makeindex
+ 
+ # If the COMPACT_LATEX tag is set to YES doxygen generates more compact LaTeX
+ # documents. This may be useful for small projects and may help to save some
+ # trees in general.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ COMPACT_LATEX          = NO
+ 
+ # The PAPER_TYPE tag can be used to set the paper type that is used by the
+ # printer.
+ # Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+ # 14 inches) and executive (7.25 x 10.5 inches).
+ # The default value is: a4.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ PAPER_TYPE             = a4
+ 
+ # The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+ # that should be included in the LaTeX output. To get the times font for
+ # instance you can specify
+ # EXTRA_PACKAGES=times
+ # If left blank no extra packages will be included.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ EXTRA_PACKAGES         = 
+ 
+ # The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+ # generated LaTeX document. The header should contain everything until the first
+ # chapter. If it is left blank doxygen will generate a standard header. See
+ # section "Doxygen usage" for information on how to let doxygen write the
+ # default header to a separate file.
+ #
+ # Note: Only use a user-defined header if you know what you are doing! The
+ # following commands have a special meaning inside the header: $title,
+ # $datetime, $date, $doxygenversion, $projectname, $projectnumber. Doxygen will
+ # replace them by respectively the title of the page, the current date and time,
+ # only the current date, the version number of doxygen, the project name (see
+ # PROJECT_NAME), or the project number (see PROJECT_NUMBER).
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_HEADER           = 
+ 
+ # The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+ # generated LaTeX document. The footer should contain everything after the last
+ # chapter. If it is left blank doxygen will generate a standard footer.
+ #
+ # Note: Only use a user-defined footer if you know what you are doing!
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_FOOTER           = 
+ 
+ # The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+ # other source files which should be copied to the LATEX_OUTPUT output
+ # directory. Note that the files will be copied as-is; there are no commands or
+ # markers available.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_EXTRA_FILES      = 
+ 
+ # If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+ # prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+ # contain links (just like the HTML output) instead of page references. This
+ # makes the output suitable for online browsing using a PDF viewer.
+ # The default value is: YES.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ PDF_HYPERLINKS         = YES
+ 
+ # If the LATEX_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+ # the PDF file directly from the LaTeX files. Set this option to YES to get a
+ # higher quality PDF documentation.
+ # The default value is: YES.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ USE_PDFLATEX           = YES
+ 
+ # If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+ # command to the generated LaTeX files. This will instruct LaTeX to keep running
+ # if errors occur, instead of asking the user for help. This option is also used
+ # when generating formulas in HTML.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_BATCHMODE        = NO
+ 
+ # If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+ # index chapters (such as File Index, Compound Index, etc.) in the output.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_HIDE_INDICES     = NO
+ 
+ # If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+ # code with syntax highlighting in the LaTeX output.
+ #
+ # Note that which sources are shown also depends on other settings such as
+ # SOURCE_BROWSER.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_SOURCE_CODE      = NO
+ 
+ # The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+ # bibliography, e.g. plainnat, or ieeetr. See
+ # http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+ # The default value is: plain.
+ # This tag requires that the tag GENERATE_LATEX is set to YES.
+ 
+ LATEX_BIB_STYLE        = plain
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the RTF output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_RTF tag is set to YES doxygen will generate RTF output. The
+ # RTF output is optimized for Word 97 and may not look too pretty with other RTF
+ # readers/editors.
+ # The default value is: NO.
+ 
+ GENERATE_RTF           = NO
+ 
+ # The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+ # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+ # it.
+ # The default directory is: rtf.
+ # This tag requires that the tag GENERATE_RTF is set to YES.
+ 
+ RTF_OUTPUT             = rtf
+ 
+ # If the COMPACT_RTF tag is set to YES doxygen generates more compact RTF
+ # documents. This may be useful for small projects and may help to save some
+ # trees in general.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_RTF is set to YES.
+ 
+ COMPACT_RTF            = NO
+ 
+ # If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+ # contain hyperlink fields. The RTF file will contain links (just like the HTML
+ # output) instead of page references. This makes the output suitable for online
+ # browsing using Word or some other Word compatible readers that support those
+ # fields.
+ #
+ # Note: WordPad (write) and others do not support links.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_RTF is set to YES.
+ 
+ RTF_HYPERLINKS         = NO
+ 
+ # Load stylesheet definitions from file. Syntax is similar to doxygen's config
+ # file, i.e. a series of assignments. You only have to provide replacements,
+ # missing definitions are set to their default value.
+ #
+ # See also section "Doxygen usage" for information on how to generate the
+ # default style sheet that doxygen normally uses.
+ # This tag requires that the tag GENERATE_RTF is set to YES.
+ 
+ RTF_STYLESHEET_FILE    = 
+ 
+ # Set optional variables used in the generation of an RTF document. Syntax is
+ # similar to doxygen's config file. A template extensions file can be generated
+ # using doxygen -e rtf extensionFile.
+ # This tag requires that the tag GENERATE_RTF is set to YES.
+ 
+ RTF_EXTENSIONS_FILE    = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the man page output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_MAN tag is set to YES doxygen will generate man pages for
+ # classes and files.
+ # The default value is: NO.
+ 
+ GENERATE_MAN           = NO
+ 
+ # The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+ # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+ # it. A directory man3 will be created inside the directory specified by
+ # MAN_OUTPUT.
+ # The default directory is: man.
+ # This tag requires that the tag GENERATE_MAN is set to YES.
+ 
+ MAN_OUTPUT             = man
+ 
+ # The MAN_EXTENSION tag determines the extension that is added to the generated
+ # man pages. In case the manual section does not start with a number, the number
+ # 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+ # optional.
+ # The default value is: .3.
+ # This tag requires that the tag GENERATE_MAN is set to YES.
+ 
+ MAN_EXTENSION          = .3
+ 
+ # The MAN_SUBDIR tag determines the name of the directory created within
+ # MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+ # MAN_EXTENSION with the initial . removed.
+ # This tag requires that the tag GENERATE_MAN is set to YES.
+ 
+ MAN_SUBDIR             = 
+ 
+ # If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+ # will generate one additional man file for each entity documented in the real
+ # man page(s). These additional files only source the real man page, but without
+ # them the man command would be unable to find the correct page.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_MAN is set to YES.
+ 
+ MAN_LINKS              = NO
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the XML output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_XML tag is set to YES doxygen will generate an XML file that
+ # captures the structure of the code including all documentation.
+ # The default value is: NO.
+ 
+ GENERATE_XML           = NO
+ 
+ # The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+ # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+ # it.
+ # The default directory is: xml.
+ # This tag requires that the tag GENERATE_XML is set to YES.
+ 
+ XML_OUTPUT             = xml
+ 
+ # If the XML_PROGRAMLISTING tag is set to YES doxygen will dump the program
+ # listings (including syntax highlighting and cross-referencing information) to
+ # the XML output. Note that enabling this will significantly increase the size
+ # of the XML output.
+ # The default value is: YES.
+ # This tag requires that the tag GENERATE_XML is set to YES.
+ 
+ XML_PROGRAMLISTING     = YES
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the DOCBOOK output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_DOCBOOK tag is set to YES doxygen will generate Docbook files
+ # that can be used to generate PDF.
+ # The default value is: NO.
+ 
+ GENERATE_DOCBOOK       = NO
+ 
+ # The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+ # If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+ # front of it.
+ # The default directory is: docbook.
+ # This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+ 
+ DOCBOOK_OUTPUT         = docbook
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options for the AutoGen Definitions output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_AUTOGEN_DEF tag is set to YES doxygen will generate an AutoGen
+ # Definitions (see http://autogen.sf.net) file that captures the structure of
+ # the code including all documentation. Note that this feature is still
+ # experimental and incomplete at the moment.
+ # The default value is: NO.
+ 
+ GENERATE_AUTOGEN_DEF   = NO
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the Perl module output
+ #---------------------------------------------------------------------------
+ 
+ # If the GENERATE_PERLMOD tag is set to YES doxygen will generate a Perl module
+ # file that captures the structure of the code including all documentation.
+ #
+ # Note that this feature is still experimental and incomplete at the moment.
+ # The default value is: NO.
+ 
+ GENERATE_PERLMOD       = NO
+ 
+ # If the PERLMOD_LATEX tag is set to YES doxygen will generate the necessary
+ # Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+ # output from the Perl module output.
+ # The default value is: NO.
+ # This tag requires that the tag GENERATE_PERLMOD is set to YES.
+ 
+ PERLMOD_LATEX          = NO
+ 
+ # If the PERLMOD_PRETTY tag is set to YES the Perl module output will be nicely
+ # formatted so it can be parsed by a human reader. This is useful if you want to
+ # understand what is going on. On the other hand, if this tag is set to NO the
+ # size of the Perl module output will be much smaller and Perl will parse it
+ # just the same.
+ # The default value is: YES.
+ # This tag requires that the tag GENERATE_PERLMOD is set to YES.
+ 
+ PERLMOD_PRETTY         = YES
+ 
+ # The names of the make variables in the generated doxyrules.make file are
+ # prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+ # so different doxyrules.make files included by the same Makefile don't
+ # overwrite each other's variables.
+ # This tag requires that the tag GENERATE_PERLMOD is set to YES.
+ 
+ PERLMOD_MAKEVAR_PREFIX = 
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the preprocessor
+ #---------------------------------------------------------------------------
+ 
+ # If the ENABLE_PREPROCESSING tag is set to YES doxygen will evaluate all
+ # C-preprocessor directives found in the sources and include files.
+ # The default value is: YES.
+ 
+ ENABLE_PREPROCESSING   = YES
+ 
+ # If the MACRO_EXPANSION tag is set to YES doxygen will expand all macro names
+ # in the source code. If set to NO only conditional compilation will be
+ # performed. Macro expansion can be done in a controlled way by setting
+ # EXPAND_ONLY_PREDEF to YES.
+ # The default value is: NO.
+ # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+ 
+ MACRO_EXPANSION        = NO
+ 
+ # If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+ # the macro expansion is limited to the macros specified with the PREDEFINED and
+ # EXPAND_AS_DEFINED tags.
+ # The default value is: NO.
+ # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+ 
+ EXPAND_ONLY_PREDEF     = NO
+ 
+ # If the SEARCH_INCLUDES tag is set to YES the includes files in the
+ # INCLUDE_PATH will be searched if a #include is found.
+ # The default value is: YES.
+ # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+ 
+ SEARCH_INCLUDES        = YES
+ 
+ # The INCLUDE_PATH tag can be used to specify one or more directories that
+ # contain include files that are not input files but should be processed by the
+ # preprocessor.
+ # This tag requires that the tag SEARCH_INCLUDES is set to YES.
+ 
+ INCLUDE_PATH           = 
+ 
+ # You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+ # patterns (like *.h and *.hpp) to filter out the header-files in the
+ # directories. If left blank, the patterns specified with FILE_PATTERNS will be
+ # used.
+ # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+ 
+ INCLUDE_FILE_PATTERNS  = 
+ 
+ # The PREDEFINED tag can be used to specify one or more macro names that are
+ # defined before the preprocessor is started (similar to the -D option of e.g.
+ # gcc). The argument of the tag is a list of macros of the form: name or
+ # name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+ # is assumed. To prevent a macro definition from being undefined via #undef or
+ # recursively expanded use the := operator instead of the = operator.
+ # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+ 
+ PREDEFINED             = 
+ 
+ # If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+ # tag can be used to specify a list of macro names that should be expanded. The
+ # macro definition that is found in the sources will be used. Use the PREDEFINED
+ # tag if you want to use a different macro definition that overrules the
+ # definition found in the source code.
+ # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+ 
+ EXPAND_AS_DEFINED      = 
+ 
+ # If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+ # remove all references to function-like macros that are alone on a line, have
+ # an all uppercase name, and do not end with a semicolon. Such function macros
+ # are typically used for boiler-plate code, and will confuse the parser if not
+ # removed.
+ # The default value is: YES.
+ # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+ 
+ SKIP_FUNCTION_MACROS   = YES
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to external references
+ #---------------------------------------------------------------------------
+ 
+ # The TAGFILES tag can be used to specify one or more tag files. For each tag
+ # file the location of the external documentation should be added. The format of
+ # a tag file without this location is as follows:
+ # TAGFILES = file1 file2 ...
+ # Adding location for the tag files is done as follows:
+ # TAGFILES = file1=loc1 "file2 = loc2" ...
+ # where loc1 and loc2 can be relative or absolute paths or URLs. See the
+ # section "Linking to external documentation" for more information about the use
+ # of tag files.
+ # Note: Each tag file must have a unique name (where the name does NOT include
+ # the path). If a tag file is not located in the directory in which doxygen is
+ # run, you must also specify the path to the tagfile here.
+ 
+ TAGFILES               = 
+ 
+ # When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+ # tag file that is based on the input files it reads. See section "Linking to
+ # external documentation" for more information about the usage of tag files.
+ 
+ GENERATE_TAGFILE       = 
+ 
+ # If the ALLEXTERNALS tag is set to YES all external class will be listed in the
+ # class index. If set to NO only the inherited external classes will be listed.
+ # The default value is: NO.
+ 
+ ALLEXTERNALS           = NO
+ 
+ # If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed in
+ # the modules index. If set to NO, only the current project's groups will be
+ # listed.
+ # The default value is: YES.
+ 
+ EXTERNAL_GROUPS        = YES
+ 
+ # If the EXTERNAL_PAGES tag is set to YES all external pages will be listed in
+ # the related pages index. If set to NO, only the current project's pages will
+ # be listed.
+ # The default value is: YES.
+ 
+ EXTERNAL_PAGES         = YES
+ 
+ # The PERL_PATH should be the absolute path and name of the perl script
+ # interpreter (i.e. the result of 'which perl').
+ # The default file (with absolute path) is: /usr/bin/perl.
+ 
+ PERL_PATH              = /usr/bin/perl
+ 
+ #---------------------------------------------------------------------------
+ # Configuration options related to the dot tool
+ #---------------------------------------------------------------------------
+ 
+ # If the CLASS_DIAGRAMS tag is set to YES doxygen will generate a class diagram
+ # (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+ # NO turns the diagrams off. Note that this option also works with HAVE_DOT
+ # disabled, but it is recommended to install and use dot, since it yields more
+ # powerful graphs.
+ # The default value is: YES.
+ 
+ CLASS_DIAGRAMS         = YES
+ 
+ # You can define message sequence charts within doxygen comments using the \msc
+ # command. Doxygen will then run the mscgen tool (see:
+ # http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+ # documentation. The MSCGEN_PATH tag allows you to specify the directory where
+ # the mscgen tool resides. If left empty the tool is assumed to be found in the
+ # default search path.
+ 
+ MSCGEN_PATH            = 
+ 
+ # You can include diagrams made with dia in doxygen documentation. Doxygen will
+ # then run dia to produce the diagram and insert it in the documentation. The
+ # DIA_PATH tag allows you to specify the directory where the dia binary resides.
+ # If left empty dia is assumed to be found in the default search path.
+ 
+ DIA_PATH               = 
+ 
+ # If set to YES, the inheritance and collaboration graphs will hide inheritance
+ # and usage relations if the target is undocumented or is not a class.
+ # The default value is: YES.
+ 
+ HIDE_UNDOC_RELATIONS   = YES
+ 
+ # If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+ # available from the path. This tool is part of Graphviz (see:
+ # http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+ # Bell Labs. The other options in this section have no effect if this option is
+ # set to NO
+ # The default value is: NO.
+ 
+ HAVE_DOT               = NO
+ 
+ # The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+ # to run in parallel. When set to 0 doxygen will base this on the number of
+ # processors available in the system. You can set it explicitly to a value
+ # larger than 0 to get control over the balance between CPU load and processing
+ # speed.
+ # Minimum value: 0, maximum value: 32, default value: 0.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_NUM_THREADS        = 0
+ 
+ # When you want a differently looking font n the dot files that doxygen
+ # generates you can specify the font name using DOT_FONTNAME. You need to make
+ # sure dot is able to find the font, which can be done by putting it in a
+ # standard location or by setting the DOTFONTPATH environment variable or by
+ # setting DOT_FONTPATH to the directory containing the font.
+ # The default value is: Helvetica.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_FONTNAME           = Helvetica
+ 
+ # The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+ # dot graphs.
+ # Minimum value: 4, maximum value: 24, default value: 10.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_FONTSIZE           = 10
+ 
+ # By default doxygen will tell dot to use the default font as specified with
+ # DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+ # the path where dot can find it using this tag.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_FONTPATH           = 
+ 
+ # If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+ # each documented class showing the direct and indirect inheritance relations.
+ # Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ CLASS_GRAPH            = YES
+ 
+ # If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+ # graph for each documented class showing the direct and indirect implementation
+ # dependencies (inheritance, containment, and class references variables) of the
+ # class with other documented classes.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ COLLABORATION_GRAPH    = YES
+ 
+ # If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+ # groups, showing the direct groups dependencies.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ GROUP_GRAPHS           = YES
+ 
+ # If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+ # collaboration diagrams in a style similar to the OMG's Unified Modeling
+ # Language.
+ # The default value is: NO.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ UML_LOOK               = NO
+ 
+ # If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+ # class node. If there are many fields or methods and many nodes the graph may
+ # become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+ # number of items for each type to make the size more manageable. Set this to 0
+ # for no limit. Note that the threshold may be exceeded by 50% before the limit
+ # is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+ # but if the number exceeds 15, the total amount of fields shown is limited to
+ # 10.
+ # Minimum value: 0, maximum value: 100, default value: 10.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ UML_LIMIT_NUM_FIELDS   = 10
+ 
+ # If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+ # collaboration graphs will show the relations between templates and their
+ # instances.
+ # The default value is: NO.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ TEMPLATE_RELATIONS     = NO
+ 
+ # If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+ # YES then doxygen will generate a graph for each documented file showing the
+ # direct and indirect include dependencies of the file with other documented
+ # files.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ INCLUDE_GRAPH          = YES
+ 
+ # If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+ # set to YES then doxygen will generate a graph for each documented file showing
+ # the direct and indirect include dependencies of the file with other documented
+ # files.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ INCLUDED_BY_GRAPH      = YES
+ 
+ # If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+ # dependency graph for every global function or class method.
+ #
+ # Note that enabling this option will significantly increase the time of a run.
+ # So in most cases it will be better to enable call graphs for selected
+ # functions only using the \callgraph command.
+ # The default value is: NO.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ CALL_GRAPH             = YES
+ 
+ # If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+ # dependency graph for every global function or class method.
+ #
+ # Note that enabling this option will significantly increase the time of a run.
+ # So in most cases it will be better to enable caller graphs for selected
+ # functions only using the \callergraph command.
+ # The default value is: NO.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ CALLER_GRAPH           = YES
+ 
+ # If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+ # hierarchy of all classes instead of a textual one.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ GRAPHICAL_HIERARCHY    = YES
+ 
+ # If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+ # dependencies a directory has on other directories in a graphical way. The
+ # dependency relations are determined by the #include relations between the
+ # files in the directories.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DIRECTORY_GRAPH        = YES
+ 
+ # The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+ # generated by dot.
+ # Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+ # to make the SVG files visible in IE 9+ (other browsers do not have this
+ # requirement).
+ # Possible values are: png, jpg, gif and svg.
+ # The default value is: png.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_IMAGE_FORMAT       = png
+ 
+ # If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+ # enable generation of interactive SVG images that allow zooming and panning.
+ #
+ # Note that this requires a modern browser other than Internet Explorer. Tested
+ # and working are Firefox, Chrome, Safari, and Opera.
+ # Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+ # the SVG files visible. Older versions of IE do not have SVG support.
+ # The default value is: NO.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ INTERACTIVE_SVG        = NO
+ 
+ # The DOT_PATH tag can be used to specify the path where the dot tool can be
+ # found. If left blank, it is assumed the dot tool can be found in the path.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_PATH               = 
+ 
+ # The DOTFILE_DIRS tag can be used to specify one or more directories that
+ # contain dot files that are included in the documentation (see the \dotfile
+ # command).
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOTFILE_DIRS           = 
+ 
+ # The MSCFILE_DIRS tag can be used to specify one or more directories that
+ # contain msc files that are included in the documentation (see the \mscfile
+ # command).
+ 
+ MSCFILE_DIRS           = 
+ 
+ # The DIAFILE_DIRS tag can be used to specify one or more directories that
+ # contain dia files that are included in the documentation (see the \diafile
+ # command).
+ 
+ DIAFILE_DIRS           = 
+ 
+ # The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+ # that will be shown in the graph. If the number of nodes in a graph becomes
+ # larger than this value, doxygen will truncate the graph, which is visualized
+ # by representing a node as a red box. Note that doxygen if the number of direct
+ # children of the root node in a graph is already larger than
+ # DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+ # the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+ # Minimum value: 0, maximum value: 10000, default value: 50.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_GRAPH_MAX_NODES    = 50
+ 
+ # The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+ # generated by dot. A depth value of 3 means that only nodes reachable from the
+ # root by following a path via at most 3 edges will be shown. Nodes that lay
+ # further from the root node will be omitted. Note that setting this option to 1
+ # or 2 may greatly reduce the computation time needed for large code bases. Also
+ # note that the size of a graph can be further restricted by
+ # DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+ # Minimum value: 0, maximum value: 1000, default value: 0.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ MAX_DOT_GRAPH_DEPTH    = 0
+ 
+ # Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+ # background. This is disabled by default, because dot on Windows does not seem
+ # to support this out of the box.
+ #
+ # Warning: Depending on the platform used, enabling this option may lead to
+ # badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+ # read).
+ # The default value is: NO.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_TRANSPARENT        = NO
+ 
+ # Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+ # files in one run (i.e. multiple -o and -T options on the command line). This
+ # makes dot run faster, but since only newer versions of dot (>1.8.10) support
+ # this, this feature is disabled by default.
+ # The default value is: NO.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_MULTI_TARGETS      = NO
+ 
+ # If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+ # explaining the meaning of the various boxes and arrows in the dot generated
+ # graphs.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ GENERATE_LEGEND        = YES
+ 
+ # If the DOT_CLEANUP tag is set to YES doxygen will remove the intermediate dot
+ # files that are used to generate the various graphs.
+ # The default value is: YES.
+ # This tag requires that the tag HAVE_DOT is set to YES.
+ 
+ DOT_CLEANUP            = YES
+ 
Binrdateien ./STM8L10x_StdPeriph_Lib_V1.2.1/_htmresc/st_logo.png und ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/_htmresc/st_logo.png sind verschieden.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_awu.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_awu.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_awu.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_awu.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,147 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_awu.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the AWU 
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_AWU_H
+ #define __STM8L10X_AWU_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup AWU_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief AWU TimeBase selection
+   */
+ 
+ typedef enum
+ {
+   AWU_Timebase_No_IT  = (uint8_t)0,    /*!< No AWU interrupt selected */
+   AWU_Timebase_250us  = (uint8_t)1,    /*!< AWU Timebase equals 0.25 ms */
+   AWU_Timebase_500us  = (uint8_t)2,    /*!< AWU Timebase equals 0.5 ms */
+   AWU_Timebase_1ms    = (uint8_t)3,    /*!< AWU Timebase equals 1 ms */
+   AWU_Timebase_2ms    = (uint8_t)4,    /*!< AWU Timebase equals 2 ms */
+   AWU_Timebase_4ms    = (uint8_t)5,    /*!< AWU Timebase equals 4 ms */
+   AWU_Timebase_8ms    = (uint8_t)6,    /*!< AWU Timebase equals 8 ms */
+   AWU_Timebase_16ms   = (uint8_t)7,    /*!< AWU Timebase equals 16 ms */
+   AWU_Timebase_32ms   = (uint8_t)8,    /*!< AWU Timebase equals 32 ms */
+   AWU_Timebase_64ms   = (uint8_t)9,    /*!< AWU Timebase equals 64 ms */
+   AWU_Timebase_128ms  = (uint8_t)10,   /*!< AWU Timebase equals 128 ms */
+   AWU_Timebase_256ms  = (uint8_t)11,   /*!< AWU Timebase equals 256 ms */
+   AWU_Timebase_512ms  = (uint8_t)12,   /*!< AWU Timebase equals 512 ms */
+   AWU_Timebase_1s     = (uint8_t)13,   /*!< AWU Timebase equals 1 s */
+   AWU_Timebase_2s     = (uint8_t)14,   /*!< AWU Timebase equals 2 s */
+   AWU_Timebase_12s    = (uint8_t)15,   /*!< AWU Timebase equals 12 s */
+   AWU_Timebase_30s    = (uint8_t)16    /*!< AWU Timebase equals 30 s */
+ } AWU_Timebase_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /** @addtogroup AWU_Exported_Constants
+   * @{
+   */
+ #define LSI_FREQUENCY_MIN ((uint32_t)25000)   /*!< LSI minimum value in Hertz */
+ #define LSI_FREQUENCY_MAX ((uint32_t)75000)   /*!< LSI maximum value in Hertz */
+ /**
+   * @}
+   */
+ 
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup AWU_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief  Macro used by the assert function to check the AWU timebases
+   */
+ #define IS_AWU_TIMEBASE(TB) \
+   (((TB) == AWU_Timebase_No_IT) || \
+    ((TB) == AWU_Timebase_250us) || \
+    ((TB) == AWU_Timebase_500us) || \
+    ((TB) == AWU_Timebase_1ms)   || \
+    ((TB) == AWU_Timebase_2ms)   || \
+    ((TB) == AWU_Timebase_4ms)   || \
+    ((TB) == AWU_Timebase_8ms)   || \
+    ((TB) == AWU_Timebase_16ms)  || \
+    ((TB) == AWU_Timebase_32ms)  || \
+    ((TB) == AWU_Timebase_64ms)  || \
+    ((TB) == AWU_Timebase_128ms) || \
+    ((TB) == AWU_Timebase_256ms) || \
+    ((TB) == AWU_Timebase_512ms) || \
+    ((TB) == AWU_Timebase_1s)    || \
+    ((TB) == AWU_Timebase_2s)    || \
+    ((TB) == AWU_Timebase_12s)   || \
+    ((TB) == AWU_Timebase_30s))
+ 
+ 
+ /**
+   * @brief   Macro used by the assert function to check the LSI frequency (in Hz)
+   */
+ #define IS_LSI_FREQUENCY(FREQ) \
+   (((FREQ) >= LSI_FREQUENCY_MIN) && \
+    ((FREQ) <= LSI_FREQUENCY_MAX))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ 
+ /** @addtogroup AWU_Exported_Functions
+   * @{
+   */
+ 
+ void AWU_DeInit(void);
+ void AWU_Init(AWU_Timebase_TypeDef AWU_TimeBase);
+ void AWU_Cmd(FunctionalState NewState);
+ void AWU_LSICalibrationConfig(uint32_t LSIFreqHz);
+ void AWU_IdleModeEnable(void);
+ FlagStatus AWU_GetFlagStatus(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_AWU_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_beep.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_beep.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_beep.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_beep.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,117 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_beep.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the BEEP
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_BEEP_H
+ #define __STM8L10X_BEEP_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup BEEP_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief BEEP Frequency selection
+   */
+ typedef enum {
+   BEEP_Frequency_1KHz = (uint8_t)0x00,  /*!< Beep signal output frequency equals to 1 KHz */
+   BEEP_Frequency_2KHz = (uint8_t)0x40,  /*!< Beep signal output frequency equals to 2 KHz */
+   BEEP_Frequency_4KHz = (uint8_t)0x80   /*!< Beep signal output frequency equals to 4 KHz */
+ } BEEP_Frequency_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /** @addtogroup BEEP_Exported_Constants
+   * @{
+   */
+ 
+ #define BEEP_CALIBRATION_DEFAULT ((uint8_t)0x01)   /*!< Default value when calibration is not done */
+ #define LSI_FREQUENCY_MIN ((uint32_t)25000)             /*!< LSI minimum value in Hertz */
+ #define LSI_FREQUENCY_MAX ((uint32_t)75000)             /*!< LSI maximum value in Hertz */
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup BEEP_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the BEEP frequencies.
+   */
+ #define IS_BEEP_FREQUENCY(FREQ) \
+   (((FREQ) == BEEP_Frequency_1KHz) || \
+    ((FREQ) == BEEP_Frequency_2KHz) || \
+    ((FREQ) == BEEP_Frequency_4KHz))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the LSI frequency (in Hz).
+   */
+ #define IS_LSI_FREQUENCY(FREQ) \
+   (((FREQ) >= LSI_FREQUENCY_MIN) && \
+    ((FREQ) <= LSI_FREQUENCY_MAX))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ 
+ /** @addtogroup BEEP_Exported_Functions
+   * @{
+   */
+ 
+ void BEEP_DeInit(void);
+ void BEEP_Init(BEEP_Frequency_TypeDef BEEP_Frequency);
+ void BEEP_Cmd(FunctionalState NewState);
+ void BEEP_LSICalibrationConfig(uint32_t LSIFreqHz);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_BEEP_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_clk.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_clk.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_clk.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_clk.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,150 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_clk.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the CLK 
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_CLK_H
+ #define __STM8L10X_CLK_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup CLK_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief CLK Clock Output
+   */
+ typedef enum {
+   CLK_Output_ClockMaster          = (uint8_t)0x00, /*!< Clock Output CKM */
+   CLK_Output_ClockMasterDiv2      = (uint8_t)0x02, /*!< Clock Output CKM/2 */
+   CLK_Output_ClockMasterDiv4      = (uint8_t)0x04, /*!< Clock Output CKM/4 */
+   CLK_Output_ClockMasterDiv16     = (uint8_t)0x06  /*!< Clock Output CKM/16 */
+ } CLK_Output_TypeDef;
+ 
+ /**
+   * @brief CLK Enable peripheral PCKEN
+   */
+ typedef enum {
+   CLK_Peripheral_TIM2  = (uint8_t)0x01,  /*!< Peripheral Clock Enable 1, TIM2 */
+   CLK_Peripheral_TIM3  = (uint8_t)0x02,  /*!< Peripheral Clock Enable 1, TIM3 */
+   CLK_Peripheral_TIM4  = (uint8_t)0x04,  /*!< Peripheral Clock Enable 1, TIM4 */
+   CLK_Peripheral_I2C     = (uint8_t)0x08,  /*!< Peripheral Clock Enable 1, I2C */
+   CLK_Peripheral_SPI     = (uint8_t)0x10,  /*!< Peripheral Clock Enable 1, SPI */
+   CLK_Peripheral_USART   = (uint8_t)0x20,  /*!< Peripheral Clock Enable 1, USART */
+   CLK_Peripheral_AWU     = (uint8_t)0x40  /*!< Peripheral Clock Enable 1, AWU */
+ } CLK_Peripheral_TypeDef;
+ 
+ /**
+   * @brief CLK Clock Divisor
+   */
+ typedef enum {
+   CLK_MasterPrescaler_HSIDiv1   = (uint8_t)0x00,  /*!< High speed internal clock prescaler: 1 */
+   CLK_MasterPrescaler_HSIDiv2   = (uint8_t)0x01,  /*!< High speed internal clock prescaler: 2 */
+   CLK_MasterPrescaler_HSIDiv4   = (uint8_t)0x02,  /*!< High speed internal clock prescaler: 4 */
+   CLK_MasterPrescaler_HSIDiv8   = (uint8_t)0x03  /*!< High speed internal clock prescaler: 8 */
+ } CLK_MasterPrescaler_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /** @addtogroup CLK_Exported_Constants
+   * @{
+   */
+ 
+ #define HSI_VALUE   ((uint32_t)16000000)  /*!< Typical Value of the HSI in Hz */
+ #define LSI_VALUE   ((uint32_t)32000)     /*!< Typical Value of the LSI in Hz */
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup CLK_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different Output clock.
+   */
+ #define IS_CLK_OUTPUT(OUTPUT) \
+   (((OUTPUT) == CLK_Output_ClockMaster)  ||\
+    ((OUTPUT) == CLK_Output_ClockMasterDiv2) ||\
+    ((OUTPUT) == CLK_Output_ClockMasterDiv4) ||\
+    ((OUTPUT) == CLK_Output_ClockMasterDiv16))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different periheral to clock.
+   */
+ #define IS_CLK_PERIPHERAL(PERIPHERAL) ((((PERIPHERAL) & (uint8_t)0x80) == (uint8_t)0x00) && ((PERIPHERAL) != (uint8_t)0x00))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different clock prescaler.
+   */
+ #define IS_CLK_MASTER_PRESCALER(PRESCALER) \
+   (((PRESCALER) == CLK_MasterPrescaler_HSIDiv1 ) ||\
+    ((PRESCALER) == CLK_MasterPrescaler_HSIDiv2 ) ||\
+    ((PRESCALER) == CLK_MasterPrescaler_HSIDiv4 ) ||\
+    ((PRESCALER) == CLK_MasterPrescaler_HSIDiv8))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup CLK_Exported_Functions
+   * @{
+   */
+ 
+ void CLK_DeInit(void);
+ void CLK_CCOCmd(FunctionalState NewState);
+ void CLK_PeripheralClockConfig(CLK_Peripheral_TypeDef CLK_Peripheral,
+                                FunctionalState NewState);
+ void CLK_MasterPrescalerConfig(CLK_MasterPrescaler_TypeDef CLK_MasterPrescaler);
+ void CLK_CCOConfig(CLK_Output_TypeDef CLK_Output);
+ uint32_t CLK_GetClockFreq(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_CLK_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_comp.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_comp.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_comp.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_comp.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,266 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_comp.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototype and macros for the COMP 
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_COMP_H
+ #define __STM8L10x_COMP_H
+ 
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup COMP_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief COMP TIM2 configuration
+   */
+ typedef enum
+ {
+   COMP_TIM2Config_IC1 = ((uint8_t)0x00), /*!< Input capture 1 selection. */
+   COMP_TIM2Config_BK = ((uint8_t)0x80)  /*!<  Break selection */
+ }COMP_TIM2Config_TypeDef;
+ 
+ /**
+   * @brief COMPs Selection
+   */
+ typedef enum
+ {
+   COMP_Selection_None    = ((uint8_t)0x00), /*!< None comparator enable. */
+   COMP_Selection_COMP1   = ((uint8_t)0x02), /*!< First comparator enable.*/
+   COMP_Selection_COMP2   = ((uint8_t)0x04), /*!< Second comparator enable. */
+   COMP_Selection_All     = ((uint8_t)0x06)  /*!< Both comparator enable. */
+ }COMP_Selection_TypeDef;
+ 
+ /**
+   * @brief COMP Polarity
+   */
+ typedef enum
+ {
+   COMP_Polarity_High  = ((uint8_t)0x00), /*!< For a detected event, output comparator is 1 */
+   COMP_Polarity_Low     = ((uint8_t)0x10)  /*!< For a detected event, output comparator is 0 */
+ }COMP_Polarity_TypeDef;
+ 
+ /**
+   * @brief COMP reference
+   */
+ typedef enum
+ {
+   COMP_Reference_Internal = ((uint8_t)0x00), /*!< Comparator reference is internal */
+   COMP_Reference_External = ((uint8_t)0x08)  /*!< Comparator reference is external */
+ }COMP_Reference_TypeDef;
+ 
+ /**
+   * @brief COMP interrupt sources
+   */
+ typedef enum
+ {
+   COMP_IT_ITEN1    = ((uint8_t)0x20), /*!< First comparator interrupt enable */
+   COMP_IT_ITEN2    = ((uint8_t)0x80), /*!< Second comparator interrupt enable */
+   COMP_IT_CEF1     = ((uint8_t)0x10), /*!< First comparator pending bit */
+   COMP_IT_CEF2     = ((uint8_t)0x40)  /*!< Second comparator pending bit */
+ }COMP_IT_TypeDef;
+ 
+ /**
+   * @brief COMP Flags
+   */
+ typedef enum
+ {
+   COMP_FLAG_COMP1 = ((uint8_t)0x10),  /*!< First comparator event flag. */
+   COMP_FLAG_COMP2 = ((uint8_t)0x40)   /*!< Second comparator event flag. */
+ }COMP_FLAG_TypeDef;
+ 
+ /**
+   * @brief COMP Output
+   */
+ typedef enum
+ {
+   COMP_Output_COMP1 = ((uint8_t)0x01),  /*!< First comparator output. */
+   COMP_Output_COMP2 = ((uint8_t)0x02)   /*!< Second comparator output. */
+ }COMP_Output_TypeDef;
+ 
+ 
+ /**
+   * @brief COMP w/ TIMx Connection Mode
+   */
+ typedef enum
+ {
+   COMP_TimersConnection_None                             = ((uint8_t)0x00), /*!< No connection */
+   COMP_TimersConnection_COMP1ToTIM2IC1BK                 = ((uint8_t)0x20), /*!< Comparator 1 sent to Input capture 1/ Break TIM2 */
+   COMP_TimersConnection_COMP1ToTIM2IC1BK_COMP2ToTIM2IC2  = ((uint8_t)0x40), /*!< Comparator 1 sent to Input capture 1/ Break TIM2 and comparator 2 sent to Input capture 2 TIM2 */
+   COMP_TimersConnection_COMP1ToTIM2IC1BK_COMP2ToTIM3IC2  = ((uint8_t)0x60)  /*!< Comparator 1 sent to Input capture 1/ Break TIM2 and comparator 2 sent to Input capture 1 TIM3 */
+ }COMP_TimersConnection_TypeDef;
+ 
+ 
+ /**
+   * @brief COMP Switch
+   */
+ typedef enum
+ {
+   COMP_Switch_COMP1Ch1   = ((uint8_t)0x01), /*!< Comparator 1 Switch 1 Enable. */
+   COMP_Switch_COMP1Ch2   = ((uint8_t)0x02), /*!< Comparator 1 Switch 2 Enable. */
+   COMP_Switch_COMP1Ch3   = ((uint8_t)0x04), /*!< Comparator 1 Switch 3 Enable. */
+   COMP_Switch_COMP1Ch4   = ((uint8_t)0x08), /*!< Comparator 1 Switch 4 Enable. */
+   COMP_Switch_COMP2Ch1   = ((uint8_t)0x10), /*!< Comparator 2 Switch 1 Enable. */
+   COMP_Switch_COMP2Ch2   = ((uint8_t)0x20), /*!< Comparator 2 Switch 2 Enable. */
+   COMP_Switch_COMP2Ch3   = ((uint8_t)0x40), /*!< Comparator 2 Switch 3 Enable. */
+   COMP_Switch_COMP2Ch4   = ((uint8_t)0x80)  /*!< Comparator 2 Switch 4 Enable. */
+ }COMP_Switch_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup COMP_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different TIM2 configuration .
+   */
+ #define IS_COMP_TIM2CONFIG(TIM2CONFIG) \
+   (((TIM2CONFIG) == COMP_TIM2Config_IC1) || \
+    ((TIM2CONFIG) == COMP_TIM2Config_BK))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different Comparator selection.
+   */
+ #define IS_COMP_SELECTION(SELECTION) \
+   (((SELECTION) == COMP_Selection_None) || \
+    ((SELECTION) == COMP_Selection_COMP1)  || \
+    ((SELECTION) == COMP_Selection_COMP2)  || \
+    ((SELECTION) == COMP_Selection_All))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator polarity.
+   */
+ #define IS_COMP_POLARITY(POLARITY) \
+   (((POLARITY) == COMP_Polarity_High) || \
+    ((POLARITY) == COMP_Polarity_Low))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator reference.
+   */
+ #define IS_COMP_REFERENCE(REFERENCE) \
+   (((REFERENCE) == COMP_Reference_Internal) || \
+    ((REFERENCE) == COMP_Reference_External))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator interrupts.
+   */
+ #define IS_COMP_IT(IT) \
+   (((IT) == COMP_IT_ITEN1) || \
+    ((IT) == COMP_IT_ITEN2))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator flags.
+   */
+ #define IS_COMP_FLAG(FLAG) \
+   (((FLAG) == COMP_FLAG_COMP1) || \
+    ((FLAG) == COMP_FLAG_COMP2) || \
+    ((FLAG) == ((uint8_t)COMP_FLAG_COMP2|(uint8_t)COMP_FLAG_COMP2)))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator output.
+   */
+ #define IS_COMP_OUTPUT(OUTPUT) \
+   (((OUTPUT) == COMP_Output_COMP1) || \
+    ((OUTPUT) == COMP_Output_COMP2))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator pending bits.
+   */
+ #define IS_COMP_ITPENDINGBIT(PENDINGBIT) \
+   (((PENDINGBIT) == COMP_IT_CEF1) || \
+    ((PENDINGBIT) == COMP_IT_CEF2))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator connection to timer1/2.
+   */
+ #define IS_COMP_TIMCONNECTION(CONNECTION) \
+   (((CONNECTION) == COMP_TimersConnection_None)                        || \
+    ((CONNECTION) == COMP_TimersConnection_COMP1ToTIM2IC1BK)             || \
+    ((CONNECTION) == COMP_TimersConnection_COMP1ToTIM2IC1BK_COMP2ToTIM2IC2) || \
+    ((CONNECTION) == COMP_TimersConnection_COMP1ToTIM2IC1BK_COMP2ToTIM3IC2))
+ 
+ /**
+   * @brief Macro used by the assert function to check the different comparator switches.
+   */
+ #define IS_COMP_SWITCH(SWITCH) \
+   (((SWITCH) == COMP_Switch_COMP1Ch1) || \
+    ((SWITCH) == COMP_Switch_COMP1Ch2) || \
+    ((SWITCH) == COMP_Switch_COMP1Ch3) || \
+    ((SWITCH) == COMP_Switch_COMP1Ch4) || \
+    ((SWITCH) == COMP_Switch_COMP2Ch1) || \
+    ((SWITCH) == COMP_Switch_COMP2Ch2) || \
+    ((SWITCH) == COMP_Switch_COMP2Ch3) || \
+    ((SWITCH) == COMP_Switch_COMP2Ch4))
+ /**
+   * @}
+   */
+ 
+ /* Exported functions --------------------------------------------------------*/
+ /** @addtogroup COMP_Exported_Functions
+   * @{
+   */
+ 
+ void COMP_DeInit(void);
+ void COMP_Init(COMP_Selection_TypeDef COMP_Selection, COMP_Reference_TypeDef COMP_Reference, \
+                COMP_Polarity_TypeDef COMP_Polarity);
+ void COMP_Cmd(FunctionalState NewState);
+ void COMP_SelectionConfig(COMP_Selection_TypeDef COMP_Selection, FunctionalState NewState);
+ void COMP_ITConfig(COMP_IT_TypeDef COMP_IT, FunctionalState NewState);
+ void COMP_TIM2Config(COMP_TIM2Config_TypeDef COMP_TIM2Config);
+ void COMP_SwitchConfig(COMP_Switch_TypeDef COMP_Switch, FunctionalState NewState);
+ void COMP_TIMConnect(COMP_TimersConnection_TypeDef COMP_TIMConnection);
+ void COMP_SelectPolarity(COMP_Polarity_TypeDef COMP_Polarity);
+ void COMP_SetReference(COMP_Reference_TypeDef COMP_Reference);
+ FlagStatus COMP_GetOutputStatus(COMP_Output_TypeDef COMP_Output);
+ FlagStatus COMP_GetFlagStatus(COMP_FLAG_TypeDef COMP_Flag);
+ void COMP_ClearFlag(COMP_FLAG_TypeDef COMP_Flag);
+ ITStatus COMP_GetITStatus(COMP_IT_TypeDef COMP_ITPendingBit);
+ void COMP_ClearITPendingBit(COMP_IT_TypeDef COMP_ITPendingBit);
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10x_COMP_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_exti.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_exti.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_exti.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_exti.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,203 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_exti.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the EXTI
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_EXTI_H
+ #define __STM8L10X_EXTI_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup EXTI_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief EXTI Sensitivity values for PORTB & PORTE
+   */
+ typedef enum
+ {
+   EXTI_Trigger_Falling_Low    = (uint8_t)0x00, /*!< Interrupt on Falling edge and Low level */
+   EXTI_Trigger_Rising         = (uint8_t)0x01, /*!< Interrupt on Rising edge only */
+   EXTI_Trigger_Falling        = (uint8_t)0x02, /*!< Interrupt on Falling edge only */
+   EXTI_Trigger_Rising_Falling = (uint8_t)0x03  /*!< Interrupt on Rising and Falling edges */
+ } EXTI_Trigger_TypeDef;
+ 
+ /**
+   * @brief EXTI halfPort possible values
+   */
+ typedef enum
+ {
+   EXTI_HalfPort_B_LSB  = (uint8_t)0x01, /*!< Interrupt selector PB(3:0) */
+   EXTI_HalfPort_B_MSB  = (uint8_t)0x02, /*!< Interrupt selector PB(7:4) */
+   EXTI_HalfPort_D_LSB  = (uint8_t)0x04, /*!< Interrupt selector PD(3:0) */
+   EXTI_HalfPort_D_MSB  = (uint8_t)0x08  /*!< Interrupt selector PD(7:4) */
+ } EXTI_HalfPort_TypeDef;
+ 
+ /**
+   * @brief EXTI Port possible values
+   */
+ typedef enum
+ {
+   EXTI_Port_B = (uint8_t)0x00, /*!< GPIO Port B */
+   EXTI_Port_D = (uint8_t)0x02  /*!< GPIO Port D */
+ } EXTI_Port_TypeDef;
+ 
+ /**
+   * @brief EXTI PinNum possible values
+   */
+ typedef enum
+ {
+   EXTI_Pin_0 = (uint8_t)0x00, /*!< GPIO Pin 0 */
+   EXTI_Pin_1 = (uint8_t)0x02, /*!< GPIO Pin 1 */
+   EXTI_Pin_2 = (uint8_t)0x04, /*!< GPIO Pin 2 */
+   EXTI_Pin_3 = (uint8_t)0x06, /*!< GPIO Pin 3 */
+   EXTI_Pin_4 = (uint8_t)0x10, /*!< GPIO Pin 4 */
+   EXTI_Pin_5 = (uint8_t)0x12, /*!< GPIO Pin 5 */
+   EXTI_Pin_6 = (uint8_t)0x14, /*!< GPIO Pin 6 */
+   EXTI_Pin_7 = (uint8_t)0x16  /*!< GPIO Pin 7 */
+ } EXTI_Pin_TypeDef;
+ 
+ /**
+   * @brief EXTI IT pending bit possible values
+   */
+ typedef enum
+ {
+   EXTI_IT_Pin0 = (uint8_t)0x01, /*!< GPIO Pin pos 0 */
+   EXTI_IT_Pin1 = (uint8_t)0x02, /*!< GPIO Pin pos 1 */
+   EXTI_IT_Pin2 = (uint8_t)0x04, /*!< GPIO Pin pos 2 */
+   EXTI_IT_Pin3 = (uint8_t)0x08, /*!< GPIO Pin pos 3 */
+   EXTI_IT_Pin4 = (uint8_t)0x10, /*!< GPIO Pin pos 4 */
+   EXTI_IT_Pin5 = (uint8_t)0x20, /*!< GPIO Pin pos 5 */
+   EXTI_IT_Pin6 = (uint8_t)0x40, /*!< GPIO Pin pos 6 */
+   EXTI_IT_Pin7 = (uint8_t)0x80, /*!< GPIO Pin pos 7 */
+   EXTI_IT_PortB   = (uint8_t)0xF1, /*!< GPIO Port B */
+   EXTI_IT_PortD   = (uint8_t)0xF2  /*!< GPIO Port D */
+ } EXTI_IT_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup EXTI_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values for PORTA to PORTE.
+   */
+ #define IS_EXTI_Trigger_VALUE(SensitivityValue) \
+   (((SensitivityValue) == EXTI_Trigger_Falling_Low)  || \
+    ((SensitivityValue) == EXTI_Trigger_Rising) || \
+    ((SensitivityValue) == EXTI_Trigger_Falling) || \
+    ((SensitivityValue) == EXTI_Trigger_Rising_Falling))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different half ports values for configuration.
+   */
+ #define IS_EXTI_HALFPORT(HALFPORT) \
+   (((HALFPORT) == EXTI_HalfPort_B_LSB) ||\
+    ((HALFPORT) == EXTI_HalfPort_B_MSB) ||\
+    ((HALFPORT) == EXTI_HalfPort_D_LSB) ||\
+    ((HALFPORT) == EXTI_HalfPort_D_MSB))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different Port Number values
+   */
+ #define IS_EXTI_PORT(PORT) \
+   (((PORT) == EXTI_Port_B) ||\
+    ((PORT) == EXTI_Port_D))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different Pin numbers values
+   */
+ #define IS_EXTI_PINNUM(PINNUM) \
+   (((PINNUM) == EXTI_Pin_0) ||\
+    ((PINNUM) == EXTI_Pin_1) ||\
+    ((PINNUM) == EXTI_Pin_2) ||\
+    ((PINNUM) == EXTI_Pin_3) ||\
+    ((PINNUM) == EXTI_Pin_4) ||\
+    ((PINNUM) == EXTI_Pin_5) ||\
+    ((PINNUM) == EXTI_Pin_6) ||\
+    ((PINNUM) == EXTI_Pin_7))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different flags values
+   */
+ #define IS_EXTI_ITPENDINGBIT(ITPENDINGBIT) \
+   (((ITPENDINGBIT) == EXTI_IT_Pin0) ||\
+    ((ITPENDINGBIT) == EXTI_IT_Pin1) ||\
+    ((ITPENDINGBIT) == EXTI_IT_Pin2) ||\
+    ((ITPENDINGBIT) == EXTI_IT_Pin3) ||\
+    ((ITPENDINGBIT) == EXTI_IT_Pin4) ||\
+    ((ITPENDINGBIT) == EXTI_IT_Pin5) ||\
+    ((ITPENDINGBIT) == EXTI_IT_Pin6) ||\
+    ((ITPENDINGBIT) == EXTI_IT_Pin7) ||\
+    ((ITPENDINGBIT) == EXTI_IT_PortB)   ||\
+    ((ITPENDINGBIT) == EXTI_IT_PortD))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup EXTI_Exported_Functions
+   * @{
+   */
+ 
+ void EXTI_DeInit(void);
+ void EXTI_SetPortSensitivity(EXTI_Port_TypeDef EXTI_Port,
+                              EXTI_Trigger_TypeDef EXTI_TriggerValue);
+ void EXTI_SetPinSensitivity(EXTI_Pin_TypeDef EXTI_PinNum,
+                             EXTI_Trigger_TypeDef EXTI_TriggerValue);
+ void EXTI_SetHalfPortSelection(EXTI_HalfPort_TypeDef EXTI_HalfPort,
+                                FunctionalState NewState);
+ EXTI_Trigger_TypeDef EXTI_GetPortSensitivity(EXTI_Port_TypeDef EXTI_Port);
+ EXTI_Trigger_TypeDef EXTI_GetPinSensitivity(EXTI_Pin_TypeDef EXTI_PinNum);
+ FunctionalState EXTI_GetHalfPortSelection(EXTI_HalfPort_TypeDef EXTI_HalfPort);
+ ITStatus EXTI_GetITStatus(EXTI_IT_TypeDef EXTI_IT);
+ void EXTI_ClearITPendingBit(EXTI_IT_TypeDef EXTI_IT);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_EXTI_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_flash.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_flash.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_flash.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_flash.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,213 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_flash.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the FLASH
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_FLASH_H
+ #define __STM8L10X_FLASH_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /** @addtogroup FLASH_Exported_Constants
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ #define FLASH_START_PHYSICAL_ADDRESS  ((uint16_t)0x8000) /*!< Flash: start address */ 
+ #define FLASH_END_PHYSICAL_ADDRESS    ((uint16_t)0x9FFF)   /*!< Flash: end address */
+ #define FLASH_BLOCK_NUMBER            ((uint8_t)0x80)       /*!< Flash memory: total number of Block */
+ #define FLASH_BLOCK_SIZE              ((uint8_t)0x40)        /*!< Number of bytes in a Block 
+                                                                               (common for Program and Data EEprom memories) */
+ #define FLASH_RASS_KEY1               ((uint8_t)0x56)    /*!< First RASS key */
+ #define FLASH_RASS_KEY2               ((uint8_t)0xAE)    /*!< Second RASS key */
+ #define FLASH_READOUTPROTECTION_KEY   ((uint8_t)0xAA)     /*!< Read out protection key */
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup FLASH_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief FLASH Memory types
+   */
+ typedef enum
+ {
+   FLASH_MemType_Program      = (uint8_t)0xFD, /*!< Program memory */
+   FLASH_MemType_Data         = (uint8_t)0xF7  /*!< Data EEPROM memory */
+ } FLASH_MemType_TypeDef;
+ 
+ /**
+   * @brief FLASH programming modes
+   */
+ typedef enum
+ {
+   FLASH_ProgramMode_Standard = (uint8_t)0x00, /*!< Standard programming mode */
+   FLASH_ProgramMode_Fast     = (uint8_t)0x10  /*!< Fast programming mode */
+ } FLASH_ProgramMode_TypeDef;
+ 
+ /**
+   * @brief FLASH fixed programming time
+   */
+ typedef enum
+ {
+   FLASH_ProgramTime_Standard = (uint8_t)0x00, /*!< Standard programming time fixed at 1/2 tprog */
+   FLASH_ProgramTime_TProg    = (uint8_t)0x01  /*!< Programming time fixed at tprog */
+ } FLASH_ProgramTime_TypeDef;
+ 
+ /**
+   * @brief FLASH status of the last operation
+   */
+ typedef enum
+ {
+   FLASH_Status_Write_Protection_Error = (uint8_t)0x01, /*!< Write attempted to protected Block */
+   FLASH_Status_TimeOut = (uint8_t)0x02, /*!< Time out error */
+   FLASH_Status_Successful_Operation   = (uint8_t)0x04  /*!< End of operation flag */
+ } FLASH_Status_TypeDef;
+ 
+ /**
+   * @brief FLASH flags definition
+  * - Warning : FLAG value = mapping position register
+   */
+ typedef enum {
+   FLASH_FLAG_DUL       = (uint8_t)0x08,     /*!< Data EEPROM unlocked flag */
+   FLASH_FLAG_EOP       = (uint8_t)0x04,     /*!< End of programming (write or erase operation) flag */
+   FLASH_FLAG_PUL       = (uint8_t)0x02,     /*!< Flash Program memory unlocked flag */
+   FLASH_FLAG_WR_PG_DIS = (uint8_t)0x01      /*!< Write attempted to protected page flag */
+ } FLASH_FLAG_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup FLASH_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values for the flash Address
+   */
+ 
+ #define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= FLASH_START_PHYSICAL_ADDRESS) && \
+                                    ((ADDRESS) <= FLASH_END_PHYSICAL_ADDRESS))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values for the flash Block number
+   */
+ #define IS_FLASH_BLOCK_NUMBER(BLOCKNUM) ((BLOCKNUM) < FLASH_BLOCK_NUMBER)
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values for the flash memory type
+   */
+ #define IS_MEMORY_TYPE(MEMTYPE) (((MEMTYPE) == FLASH_MemType_Program) || \
+                                  ((MEMTYPE) == FLASH_MemType_Data))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values for the flash program block mode
+   */
+ #define IS_FLASH_PROGRAM_MODE(MODE) (((MODE) == FLASH_ProgramMode_Standard) || \
+                                      ((MODE) == FLASH_ProgramMode_Fast))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the program time mode
+   */
+ #define IS_FLASH_PROGRAM_TIME(TIME) (((TIME) == FLASH_ProgramTime_Standard) || \
+                                      ((TIME) == FLASH_ProgramTime_TProg))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different flags values
+   */
+ #define IS_FLASH_FLAGS(FLAG) (((FLAG) == FLASH_FLAG_EOP) || \
+                               ((FLAG) == FLASH_FLAG_PUL) || \
+                               ((FLAG) == FLASH_FLAG_DUL) || \
+                               ((FLAG) == FLASH_FLAG_WR_PG_DIS))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /* FLASH program and Data EEPROM memories interface configuration functions ***/
+ FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void);
+ void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgramTime);
+ 
+ /* FLASH program and Data EEPROM memories Programming functions ***************/
+ void FLASH_DeInit(void);
+ void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType);
+ void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType);
+ void FLASH_ProgramByte(uint16_t Address, uint8_t Data);
+ void FLASH_EraseByte(uint16_t Address);
+ void FLASH_ProgramWord(uint16_t Address, uint32_t Data);
+ uint8_t FLASH_ReadByte(uint16_t Address);
+ 
+ /* Option Bytes Programming functions *****************************************/
+ uint16_t FLASH_GetBootSize(void);
+ uint16_t FLASH_GetDataSize(void);
+ FunctionalState FLASH_GetReadOutProtectionStatus(void);
+ 
+ /* Interrupts and flags management functions **********************************/
+ void FLASH_ITConfig(FunctionalState NewState);
+ FlagStatus FLASH_GetFlagStatus(FLASH_FLAG_TypeDef FLASH_FLAG);
+ 
+ /* Functions to be executed from RAM ******************************************/
+ /**
+ @code
+  All the functions declared below must be executed from RAM exclusively, except 
+  for the FLASH_WaitForLastOperation function which can be executed from Flash.
+  
+  Steps of the execution from RAM differs from one toolchain to another.
+  for more details refer to stm8l10x_flash.c file.
+  
+  To enable execution from RAM you can either uncomment the following define 
+  in the stm8l10x.h file or define it in your toolchain compiler preprocessor
+  - #define RAM_EXECUTION  (1) 
+ 
+ @endcode
+ */
+ IN_RAM(void FLASH_ProgramBlock(uint8_t BlockNum, FLASH_ProgramMode_TypeDef FLASH_ProgramMode, uint8_t *Buffer));
+ IN_RAM(void FLASH_EraseBlock(uint8_t BlockNum));
+ IN_RAM(FLASH_Status_TypeDef FLASH_WaitForLastOperation(void));
+ 
+ 
+ 
+ #endif /*__STM8L10X_FLASH_H*/
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_gpio.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_gpio.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_gpio.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_gpio.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,159 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_gpio.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the GPIO
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_GPIO_H
+ #define __STM8L10X_GPIO_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup GPIO_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief GPIO modes
+   *
+   * Bits definitions:
+   * - Bit 7: 0 = INPUT mode
+   *          1 = OUTPUT mode
+   *          1 = PULL-UP (input) or PUSH-PULL (output)
+   * - Bit 5: 0 = No external interrupt (input) or No slope control (output)
+   *          1 = External interrupt (input) or Slow control enabled (output)
+   * - Bit 4: 0 = Low level (output)
+   *          1 = High level (output push-pull) or HI-Z (output open-drain)
+   */
+ typedef enum
+ {
+   GPIO_Mode_In_FL_No_IT      = (uint8_t)0x00,   /*!< Input floating, no external interrupt */
+   GPIO_Mode_In_PU_No_IT      = (uint8_t)0x40,   /*!< Input pull-up, no external interrupt */
+   GPIO_Mode_In_FL_IT         = (uint8_t)0x20,   /*!< Input floating, external interrupt */
+   GPIO_Mode_In_PU_IT         = (uint8_t)0x60,   /*!< Input pull-up, external interrupt */
+   GPIO_Mode_Out_OD_Low_Fast  = (uint8_t)0xA0,   /*!< Output open-drain, low level, 10MHz */
+   GPIO_Mode_Out_PP_Low_Fast  = (uint8_t)0xE0,   /*!< Output push-pull, low level, 10MHz */
+   GPIO_Mode_Out_OD_Low_Slow  = (uint8_t)0x80,   /*!< Output open-drain, low level, 2MHz */
+   GPIO_Mode_Out_PP_Low_Slow  = (uint8_t)0xC0,   /*!< Output push-pull, low level, 2MHz */
+   GPIO_Mode_Out_OD_HiZ_Fast  = (uint8_t)0xB0,   /*!< Output open-drain, high-impedance level, 10MHz */
+   GPIO_Mode_Out_PP_High_Fast = (uint8_t)0xF0,   /*!< Output push-pull, high level, 10MHz */
+   GPIO_Mode_Out_OD_HiZ_Slow  = (uint8_t)0x90,   /*!< Output open-drain, high-impedance level, 2MHz */
+   GPIO_Mode_Out_PP_High_Slow = (uint8_t)0xD0    /*!< Output push-pull, high level, 2MHz */
+ }GPIO_Mode_TypeDef;
+ 
+ /**
+   * @brief Definition of the GPIO pins. Used by the @ref GPIO_Init function in
+   * order to select the pins to be initialized.
+   */
+ 
+ typedef enum
+ {
+   GPIO_Pin_0    = ((uint8_t)0x01),  /*!< Pin 0 selected */
+   GPIO_Pin_1    = ((uint8_t)0x02),  /*!< Pin 1 selected */
+   GPIO_Pin_2    = ((uint8_t)0x04),  /*!< Pin 2 selected */
+   GPIO_Pin_3    = ((uint8_t)0x08),   /*!< Pin 3 selected */
+   GPIO_Pin_4    = ((uint8_t)0x10),  /*!< Pin 4 selected */
+   GPIO_Pin_5    = ((uint8_t)0x20),  /*!< Pin 5 selected */
+   GPIO_Pin_6    = ((uint8_t)0x40),  /*!< Pin 6 selected */
+   GPIO_Pin_7    = ((uint8_t)0x80),  /*!< Pin 7 selected */
+   GPIO_Pin_LNib = ((uint8_t)0x0F),  /*!< Low nibble pins selected */
+   GPIO_Pin_HNib = ((uint8_t)0xF0),  /*!< High nibble pins selected */
+   GPIO_Pin_All  = ((uint8_t)0xFF)   /*!< All pins selected */
+ }GPIO_Pin_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup GPIO_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different
+   * values of GPIOMode_TypeDef.
+   */
+ #define IS_GPIO_MODE(MODE) \
+   (((MODE) == GPIO_Mode_In_FL_No_IT)    || \
+    ((MODE) == GPIO_Mode_In_PU_No_IT)    || \
+    ((MODE) == GPIO_Mode_In_FL_IT)       || \
+    ((MODE) == GPIO_Mode_In_PU_IT)       || \
+    ((MODE) == GPIO_Mode_Out_OD_Low_Fast)  || \
+    ((MODE) == GPIO_Mode_Out_PP_Low_Fast)  || \
+    ((MODE) == GPIO_Mode_Out_OD_Low_Slow)  || \
+    ((MODE) == GPIO_Mode_Out_PP_Low_Slow)  || \
+    ((MODE) == GPIO_Mode_Out_OD_HiZ_Fast)  || \
+    ((MODE) == GPIO_Mode_Out_PP_High_Fast)  || \
+    ((MODE) == GPIO_Mode_Out_OD_HiZ_Slow)  || \
+    ((MODE) == GPIO_Mode_Out_PP_High_Slow))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different
+   * values of GPIO_Pins.
+   */
+ #define IS_GPIO_PIN(PIN) ((PIN) != (uint8_t)0x00)
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup GPIO_Exported_Functions
+   * @{
+   */
+ 
+ void GPIO_DeInit(GPIO_TypeDef* GPIOx);
+ void GPIO_Init(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin, GPIO_Mode_TypeDef GPIO_Mode);
+ void GPIO_Write(GPIO_TypeDef* GPIOx, uint8_t GPIO_PortVal);
+ void GPIO_WriteBit(GPIO_TypeDef* GPIOx, GPIO_Pin_TypeDef GPIO_Pin, BitAction GPIO_BitVal);
+ void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin);
+ void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin);
+ void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin);
+ uint8_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
+ uint8_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
+ BitStatus GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, GPIO_Pin_TypeDef GPIO_Pin);
+ BitStatus GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, GPIO_Pin_TypeDef GPIO_Pin);
+ void GPIO_ExternalPullUpConfig(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin, FunctionalState NewState);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_GPIO_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x.h	2017-09-02 18:43:16.000000000 +0200
***************
*** 0 ****
--- 1,1479 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all HW registers definitions and memory mapping.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_H
+ #define __STM8L10x_H
+ 
+ /******************************************************************************/
+ /*                   Library configuration section                            */
+ /******************************************************************************/
+ 
+ /* Check the used compiler */
+ #if defined(__CSMC__)
+  #define _COSMIC_
+ #elif defined(__RCST7__)
+  #define _RAISONANCE_
+ #elif defined(__ICCSTM8__)
+  #define _IAR_
+ #elif defined(__SDCC)                    /* SDCC patch: add compiler and version */
+  #define _SDCC_
+  #define SDCC_VERSION (__SDCC_VERSION_MAJOR * 10000 \
+                      + __SDCC_VERSION_MINOR * 100 \
+                      + __SDCC_VERSION_PATCH)
+ #else
+  #error "Unsupported Compiler!"          /* Compiler defines not found */
+ #endif
+ 
+ #if !defined  USE_STDPERIPH_DRIVER
+ /* Comment the line below if you will not use the peripherals drivers.
+    In this case, these drivers will not be included and the application code will be
+    based on direct access to peripherals registers */
+  #define USE_STDPERIPH_DRIVER
+ #endif
+ 
+ #if defined(_COSMIC_)
+  #define FAR  @far
+  #define NEAR @near
+  #define TINY @tiny
+  #define EEPROM @eeprom
+  #define CONST  const
+ #elif defined(_RAISONANCE_)
+  #define FAR  far
+  #define NEAR data
+  #define TINY page0
+  #define EEPROM eeprom
+  #define CONST  code
+  #define MEMCPY memcpy /*!< Used with memory Models for code less than 64K */
+ #elif defined (_SDCC_)                    /* SDCC patch: mostly not required / not supported */
+  #define FAR
+  #define NEAR
+  #define TINY
+  #define EEPROM
+  #define CONST  const
+ #else /* _IAR_ */
+  #define FAR  __far
+  #define NEAR __near
+  #define TINY __tiny
+  #define EEPROM __eeprom
+  #define CONST  const
+ #endif
+ 
+ /* SDCC patch: simplify maintenance over different SPLs. All STM8L10x have <64kB memory range */
+ #undef _SDCC_BIGMEM_
+ 
+ /**
+   * @brief Legacy definition
+   */
+ #define __CONST  CONST
+ 
+ /*!< Used with memory Models for code smaller than 64K */
+ #define PointerAttr NEAR
+ 
+ /* Uncomment the line below to enable the FLASH functions execution from RAM */
+ #if !defined (RAM_EXECUTION)
+ /* #define RAM_EXECUTION  (1) */
+ #endif /* RAM_EXECUTION */
+ 
+ #ifdef RAM_EXECUTION
+  #ifdef _COSMIC_
+    #define IN_RAM(a) a
+  #elif defined (_RAISONANCE_) /* __RCST7__ */
+    #define IN_RAM(a) a inram
+  #elif defined (_SDCC_)                    /* SDCC patch: code in RAM not yet patched */
+   #error RAM execution not yet implemented in patch, comment RAM_EXECUTION in stm8l10x.h
+  #else /*_IAR_*/
+   #define IN_RAM(a) __ramfunc a
+  #endif /* _COSMIC_ */
+ #else /*_IAR_*/
+   #define IN_RAM(a) a
+ #endif /* RAM_EXECUTION */
+ 
+ /*!< [31:16] STM8L10x Standard Peripheral Library main version */
+ #define __STM8L10X_STDPERIPH_VERSION_MAIN   ((uint8_t)0x01) /*!< [31:24] main version */                                  
+ #define __STM8L10X_STDPERIPH_VERSION_SUB1   ((uint8_t)0x02) /*!< [23:16] sub1 version */
+ #define __STM8L10X_STDPERIPH_VERSION_SUB2   ((uint8_t)0x01) /*!< [15:8]  sub2 version */
+ #define __STM8L10X_STDPERIPH_VERSION_RC     ((uint8_t)0x00) /*!< [7:0]  release candidate */ 
+ #define __STM8L10X_STDPERIPH_VERSION       ( (__STM8L10X_STDPERIPH_VERSION_MAIN << 24)\
+                                           |(__STM8L10X_STDPERIPH_VERSION_SUB1 << 16)\
+                                           |(__STM8L10X_STDPERIPH_VERSION_SUB2 << 8)\
+                                           |(__STM8L10X_STDPERIPH_VERSION_RC))
+ 
+ 
+ /******************************************************************************/
+ 
+ /* Includes ------------------------------------------------------------------*/
+ 
+ /* Exported types and constants-----------------------------------------------*/
+ 
+ /** @addtogroup Exported_types
+   * @{
+   */
+ 
+ /**
+  * IO definitions
+  *
+  * define access restrictions to peripheral registers
+  */
+ #define     __I     volatile const            /*!< defines 'read only' permissions      */
+ #define     __O     volatile                  /*!< defines 'write only' permissions     */
+ #define     __IO    volatile                  /*!< defines 'read / write' permissions   */
+ 
+ /*!< Signed integer types  */
+ typedef   signed char     int8_t;
+ typedef   signed short    int16_t;
+ typedef   signed long     int32_t;
+ 
+ /*!< Unsigned integer types  */
+ typedef unsigned char     uint8_t;
+ typedef unsigned short    uint16_t;
+ typedef unsigned long     uint32_t;
+ 
+ /*!< STM8L10x Standard Peripheral Library old types (maintained for legacy prupose) */
+ 
+ typedef int32_t  s32;
+ typedef int16_t s16;
+ typedef int8_t  s8;
+ 
+ typedef uint32_t  u32;
+ typedef uint16_t u16;
+ typedef uint8_t  u8;
+ 
+ 
+ typedef enum {FALSE = 0, TRUE = !FALSE} bool;
+ 
+ typedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus, BitStatus, BitAction;
+ 
+ typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
+ #define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
+ 
+ typedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
+ 
+ #define U8_MAX     (255)
+ #define S8_MAX     (127)
+ #define S8_MIN     (-128)
+ #define U16_MAX    (65535u)
+ #define S16_MAX    (32767)
+ #define S16_MIN    (-32768)
+ #define U32_MAX    (4294967295uL)
+ #define S32_MAX    (2147483647)
+ #define S32_MIN    (-2147483648uL)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup MAP_FILE_Exported_Types_and_Constants
+   * @{
+   */
+ 
+ /******************************************************************************/
+ /*                          IP registers structures                           */
+ /******************************************************************************/
+ 
+ /*----------------------------------------------------------------------------*/
+ /**
+   * @brief General Purpose I/Os (GPIO)
+   */
+ typedef struct GPIO_struct
+ {
+   __IO uint8_t ODR; /*!< Output Data Register */
+   __IO uint8_t IDR; /*!< Input Data Register */
+   __IO uint8_t DDR; /*!< Data Direction Register */
+   __IO uint8_t CR1; /*!< Configuration Register 1 */
+   __IO uint8_t CR2; /*!< Configuration Register 2 */
+ }
+ GPIO_TypeDef;
+ 
+ /** @addtogroup GPIO_Registers_Reset_Value
+   * @{
+   */
+ #define GPIO_ODR_RESET_VALUE ((uint8_t)0x00)
+ #define GPIO_DDR_RESET_VALUE ((uint8_t)0x00)
+ #define GPIO_CR1_RESET_VALUE ((uint8_t)0x00)
+ #define GPIO_CR2_RESET_VALUE ((uint8_t)0x00)
+ /**
+   * @}
+   */
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief Auto Wake Up (AWU) peripheral registers.
+   */
+ typedef struct AWU_struct
+ {
+   __IO uint8_t CSR; /*!< AWU Control status register */
+   __IO uint8_t APR; /*!< AWU Asynchronous prescalar buffer */
+   __IO uint8_t TBR; /*!< AWU Time base selection register */
+ }
+ AWU_TypeDef;
+ 
+ /** @addtogroup AWU_Registers_Reset_Value
+   * @{
+   */
+ 
+ #define AWU_CSR_RESET_VALUE ((uint8_t)0x00)
+ #define AWU_APR_RESET_VALUE ((uint8_t)0x3F)
+ #define AWU_TBR_RESET_VALUE ((uint8_t)0x00)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup AWU_Registers_Bits_Definition
+   * @{
+   */
+ 
+ #define AWU_CSR_AWUF  ((uint8_t)0x20) /*!< Interrupt flag mask */
+ #define AWU_CSR_AWUEN ((uint8_t)0x10) /*!< Auto Wake-up enable mask */
+ #define AWU_CSR_MSR   ((uint8_t)0x01) /*!< Measurement enable mask */
+ 
+ #define AWU_APR_APR ((uint8_t)0x3F) /*!< Asynchronous Prescaler divider mask */
+ 
+ #define AWU_TBR_AWUTB ((uint8_t)0x0F) /*!< Timebase selection mask */
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /*----------------------------------------------------------------------------*/
+ /**
+   * @brief Beeper (BEEP) peripheral registers.
+   */
+ 
+ typedef struct BEEP_struct
+ {
+   __IO uint8_t CSR; /*!< BEEP Control status register */
+ }
+ BEEP_TypeDef;
+ 
+ /** @addtogroup BEEP_Registers_Reset_Value
+   * @{
+   */
+ 
+ #define BEEP_CSR_RESET_VALUE ((uint8_t)0x1F)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup BEEP_Registers_Bits_Definition
+   * @{
+   */
+ 
+ #define BEEP_CSR_BEEPSEL ((uint8_t)0xC0) /*!< Beeper frequency selection mask */
+ #define BEEP_CSR_BEEPEN  ((uint8_t)0x20) /*!< Beeper enable mask */
+ #define BEEP_CSR_BEEPDIV ((uint8_t)0x1F) /*!< Beeper Divider prescalar mask */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------ok*/
+ 
+ /**
+   * @brief Configuration Registers (CFG)
+   */
+ 
+ typedef struct CFG_struct
+ {
+   __IO uint8_t GCR; /*!< Global Configuration register */
+ }
+ CFG_TypeDef;
+ 
+ /** @addtogroup CFG_Registers_Reset_Value
+   * @{
+   */
+ 
+ #define CFG_GCR_RESET_VALUE ((uint8_t)0x00)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup CFG_Registers_Bits_Definition
+   * @{
+   */
+ 
+ #define CFG_GCR_SWD ((uint8_t)0x01) /*!< Swim disable bit mask */
+ #define CFG_GCR_AL  ((uint8_t)0x02) /*!< Activation Level bit mask */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------ok*/
+ 
+ /**
+   * @brief Clock Controller (CLK)
+   */
+ typedef struct CLK_struct
+ {
+   __IO uint8_t CKDIVR;      /*!< Clock Divider Register */
+   uint8_t RESERVED1;
+   uint8_t RESERVED2;
+   __IO uint8_t PCKENR;     /*!< Peripheral Clock Gating Register  */
+   uint8_t RESERVED3;
+   __IO uint8_t CCOR;       /*!< Configurable Clock Output Register */
+ }
+ CLK_TypeDef;
+ 
+ /** @addtogroup CLK_Registers_Reset_Value
+   * @{
+   */
+ #define CLK_CKDIVR_RESET_VALUE      ((uint8_t)0x03)
+ #define CLK_PCKENR_RESET_VALUE      ((uint8_t)0x00)
+ #define CLK_CCOR_RESET_VALUE        ((uint8_t)0x00)
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup CLK_Registers_Bits_Definition
+   * @{
+   */
+ 
+ #define CLK_CKDIVR_HSIDIV  ((uint8_t)0x03) /*!< clock prescaler */
+ 
+ #define CLK_PCKENR_TIM2  ((uint8_t)0x01) /*!< Peripheral Clock Enable 1, TIM2 */
+ #define CLK_PCKENR_TIM3  ((uint8_t)0x02) /*!< Peripheral Clock Enable 1, TIM3 */
+ #define CLK_PCKENR_TIM4  ((uint8_t)0x04) /*!< Peripheral Clock Enable 1, TIM4 */
+ #define CLK_PCKENR_I2C     ((uint8_t)0x08) /*!< Peripheral Clock Enable 1, I2C */
+ #define CLK_PCKENR_SPI     ((uint8_t)0x10) /*!< Peripheral Clock Enable 1, SPI */
+ #define CLK_PCKENR_USART   ((uint8_t)0x20) /*!< Peripheral Clock Enable 1, USART */
+ #define CLK_PCKENR_AWU     ((uint8_t)0x40) /*!< Peripheral Clock Enable 1, AWU */
+ #define CLK_PCKENR_PXS     ((uint8_t)0x80) /*!< Peripheral Clock Enable 1, PXS */
+ 
+ #define CLK_CCOR_CCOSEL    ((uint8_t)0x06) /*!< Configurable clock output selection */
+ #define CLK_CCOR_CCOEN     ((uint8_t)0x01) /*!< Configurable clock output enable */
+ 
+ /**
+   * @}
+   */
+ /*----------------------------------------------------------------------------ok*/
+ 
+ /**
+   * @brief Comparator interface (COMP)
+   */
+ typedef struct COMP_struct
+ {
+   __IO uint8_t CR;    /*!< Control register  */
+   __IO uint8_t CSR;   /*!< Control status register   */
+   __IO uint8_t CCS;   /*!< Comparator Channel Selection   */
+ }
+ COMP_TypeDef;
+ 
+ /** @addtogroup COMP_Registers_Reset_Value
+   * @{
+   */
+ #define COMP_CR_RESET_VALUE  ((uint8_t)0x00)
+ #define COMP_CSR_RESET_VALUE  ((uint8_t)0x50)
+ #define COMP_CCS_RESET_VALUE ((uint8_t)0x00)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup COMP_Registers_Bits_Definition
+   * @{
+   */
+ 
+ /* CR*/
+ #define COMP_CR_IC1BK         ((uint8_t)0x80) /*!< TIM2 input capture/break  Mask. */
+ #define COMP_CR_CNFTIM        ((uint8_t)0x60) /*!< Connect output comparator configuration Mask. */
+ #define COMP_CR_POL           ((uint8_t)0x10) /*!< Comparator Polarity Mask. */
+ #define COMP_CR_COMPREF       ((uint8_t)0x08) /*!< Comparator Reference Mask. */
+ #define COMP_CR_COMP2EN       ((uint8_t)0x04) /*!< Second Comparator Enable Mask. */
+ #define COMP_CR_COMP1EN       ((uint8_t)0x02) /*!< First Comparator Enable Mask. */
+ #define COMP_CR_BIASEN        ((uint8_t)0x01) /*!< Bias Enable Mask. */
+ 
+ /* CSR*/
+ #define COMP_CSR_ITEN2       ((uint8_t)0x80) /*!<  Second Comparator Interrupt Enable Mask. */
+ #define COMP_CSR_CEF2         ((uint8_t)0x40) /*!<  Second Comparator Ecevt Flag Mask. */
+ #define COMP_CSR_ITEN1       ((uint8_t)0x20) /*!<  First Comparator Interrupt Enable Mask. */
+ #define COMP_CSR_CEF1         ((uint8_t)0x10) /*!<  First Comparator Event Flag Mask. */
+ #define COMP_CSR_COMP2OUT     ((uint8_t)0x02) /*!<  Second Comparator Output Mask. */
+ #define COMP_CSR_COMP1OUT     ((uint8_t)0x01) /*!<  First Comparator Output Mask. */
+ 
+ /* CCS*/
+ #define COMP_CCS_COMP2CH4     ((uint8_t)0x80) /*!< Comparator 2 switch 4 Enable Mask. */
+ #define COMP_CCS_COMP2CH3     ((uint8_t)0x40) /*!< Comparator 2 switch 3 Enable Mask. */
+ #define COMP_CCS_COMP2CH2     ((uint8_t)0x20) /*!< Comparator 2 switch 2 Enable Mask. */
+ #define COMP_CCS_COMP2CH1     ((uint8_t)0x10) /*!< Comparator 2 switch 1 Enable Mask. */
+ #define COMP_CCS_COMP1CH4     ((uint8_t)0x08) /*!< Comparator 1 switch 4 Enable Mask. */
+ #define COMP_CCS_COMP1CH3     ((uint8_t)0x04) /*!< Comparator 1 switch 3 Enable Mask. */
+ #define COMP_CCS_COMP1CH2     ((uint8_t)0x02) /*!< Comparator 1 switch 2 Enable Mask. */
+ #define COMP_CCS_COMP1CH1     ((uint8_t)0x01) /*!< Comparator 1 switch 1 Enable Mask. */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------ok*/
+ 
+ /**
+   * @brief External Interrupt Controller (EXTI)
+   */
+ typedef struct EXTI_struct
+ {
+   __IO uint8_t CR1;  /*!<  The four LSB EXTI  pin sensitivity */
+   __IO uint8_t CR2;  /*!<  The four MSB EXTI  pin sensitivity */
+   __IO uint8_t CR3;  /*!<  EXTI port B & port D sensitivity */
+   __IO uint8_t SR1;  /*!<  Pins Status flag register 1 */
+   __IO uint8_t SR2;  /*!<  Ports Status flag register 2 */
+   __IO uint8_t CONF; /*!<  Port interrupt selector */
+ }
+ EXTI_TypeDef;
+ 
+ /** @addtogroup EXTI_Registers_Reset_Value
+   * @{
+   */
+ 
+ #define EXTI_CR1_RESET_VALUE ((uint8_t)0x00)
+ #define EXTI_CR2_RESET_VALUE ((uint8_t)0x00)
+ #define EXTI_CR3_RESET_VALUE ((uint8_t)0x00)
+ #define EXTI_CONF_RESET_VALUE ((uint8_t)0x00)
+ #define EXTI_SR1_RESET_VALUE ((uint8_t)0x00)
+ #define EXTI_SR2_RESET_VALUE ((uint8_t)0x00)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup EXTI_Registers_Bits_Definition
+   * @{
+   */
+ /* CR1 */
+ #define EXTI_CR1_P3IS ((uint8_t)0xC0) /*!< EXTI Pin 3 external interrupt sensitivity bit Mask */
+ #define EXTI_CR1_P2IS ((uint8_t)0x30) /*!< EXTI Pin 2 external interrupt sensitivity bit Mask */
+ #define EXTI_CR1_P1IS ((uint8_t)0x0C) /*!< EXTI Pin 1  external interrupt sensitivity bit Mask */
+ #define EXTI_CR1_P0IS ((uint8_t)0x03) /*!< EXTI Pin 0 external interrupt sensitivity bit Mask */
+ 
+ /* CR2 */
+ #define EXTI_CR2_P7IS ((uint8_t)0xC0) /*!< EXTI Pin 7 external interrupt sensitivity bit Mask */
+ #define EXTI_CR2_P6IS ((uint8_t)0x30) /*!< EXTI Pin 6 external interrupt sensitivity bit Mask */
+ #define EXTI_CR2_P5IS ((uint8_t)0x0C) /*!< EXTI Pin 5  external interrupt sensitivity bit Mask */
+ #define EXTI_CR2_P4IS ((uint8_t)0x03) /*!< EXTI Pin 4 external interrupt sensitivity bit Mask */
+ 
+ /* CR3 */
+ #define EXTI_CR3_PBIS ((uint8_t)0x03) /*!< EXTI PORTB external interrupt sensitivity bits Mask */
+ #define EXTI_CR3_PDIS ((uint8_t)0x0C) /*!< EXTI PORTD external interrupt sensitivity bits Mask */
+ 
+ /* CONF */
+ #define EXTI_CONF_PBL ((uint8_t)0x01) /*!< EXTI PORTB low interrupt selector bit Mask */
+ #define EXTI_CONF_PBH ((uint8_t)0x02) /*!< EXTI PORTB high interrupt selector bit Mask */
+ #define EXTI_CONF_PDL ((uint8_t)0x04) /*!< EXTI PORTD low interrupt selector bit Mask */
+ #define EXTI_CONF_PDH ((uint8_t)0x08) /*!< EXTI PORTD high interrupt selector bit Mask */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------ok*/
+ 
+ /**
+   * @brief FLASH and Data EEPROM
+   */
+ typedef struct FLASH_struct
+ {
+   __IO uint8_t CR1;        /*!< Flash control register 1 */
+   __IO uint8_t CR2;        /*!< Flash control register 2 */
+   __IO uint8_t PUKR;       /*!< Flash program memory unprotection register */
+   __IO uint8_t DUKR;       /*!< Data EEPROM unprotection register */
+   __IO uint8_t IAPSR;      /*!< Flash in-application programming status register */
+ }
+ FLASH_TypeDef;
+ 
+ /** @addtogroup FLASH_Registers_Reset_Value
+   * @{
+   */
+ #define FLASH_CR1_RESET_VALUE   ((uint8_t)0x00)
+ #define FLASH_CR2_RESET_VALUE   ((uint8_t)0x00)
+ #define FLASH_PUKR_RESET_VALUE   ((uint8_t)0xAE)
+ #define FLASH_DUKR_RESET_VALUE   ((uint8_t)0x56)
+ #define FLASH_IAPSR_RESET_VALUE ((uint8_t)0x40)
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup FLASH_Registers_Bits_Definition
+   * @{
+   */
+ #define FLASH_CR1_IE             ((uint8_t)0x02) /*!< Flash Interrupt enable Mask */
+ #define FLASH_CR1_FIX            ((uint8_t)0x01) /*!< Fix programming time Mask */
+ 
+ #define FLASH_CR2_WPRG           ((uint8_t)0x40) /*!< Word write once Mask */
+ #define FLASH_CR2_ERASE          ((uint8_t)0x20) /*!< Erase block Mask */
+ #define FLASH_CR2_FPRG           ((uint8_t)0x10) /*!< Fast programming mode Mask */
+ #define FLASH_CR2_PRG            ((uint8_t)0x01) /*!< Program block Mask */
+ 
+ #define FLASH_IAPSR_HVOFF        ((uint8_t)0x40) /*!< End of high voltage flag Mask */
+ #define FLASH_IAPSR_DUL          ((uint8_t)0x08) /*!< Data EEPROM unlocked flag Mask */
+ #define FLASH_IAPSR_EOP          ((uint8_t)0x04) /*!< End of operation flag Mask */
+ #define FLASH_IAPSR_PUL          ((uint8_t)0x02) /*!< Program memory unlocked flag Mask */
+ #define FLASH_IAPSR_WR_PG_DIS    ((uint8_t)0x01) /*!< Write attempted to protected page Mask */
+ 
+ #define FLASH_PUKR_PUK ((uint8_t)0xFF) /*!< Flash Program memory unprotection mask */
+ 
+ #define FLASH_DUKR_DUK ((uint8_t)0xFF) /*!< Data EEPROM unprotection mask */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief Inter-Integrated Circuit (I2C)
+   */
+ typedef struct I2C_struct
+ {
+   __IO uint8_t CR1;    /*!< I2C control register 1 */
+   __IO uint8_t CR2;    /*!< I2C control register 2 */
+   __IO uint8_t FREQR;  /*!< I2C frequency register */
+   __IO uint8_t OARL;   /*!< I2C own address register LSB */
+   __IO uint8_t OARH;   /*!< I2C own address register MSB */
+   uint8_t RESERVED;
+   __IO uint8_t DR;     /*!< I2C data register */
+   __IO uint8_t SR1;    /*!< I2C status register 1 */
+   __IO uint8_t SR2;    /*!< I2C status register 2 */
+   __IO uint8_t SR3;    /*!< I2C status register 3 */
+   __IO uint8_t ITR;    /*!< I2C interrupt register */
+   __IO uint8_t CCRL;   /*!< I2C clock control register low */
+   __IO uint8_t CCRH;   /*!< I2C clock control register high */
+   __IO uint8_t TRISER; /*!< I2C maximum rise time register */
+ }
+ I2C_TypeDef;
+ 
+ /** @addtogroup I2C_Registers_Reset_Value
+   * @{
+   */
+ #define I2C_CR1_RESET_VALUE    ((uint8_t)0x00)
+ #define I2C_CR2_RESET_VALUE    ((uint8_t)0x00)
+ #define I2C_FREQR_RESET_VALUE  ((uint8_t)0x00)
+ #define I2C_OARL_RESET_VALUE   ((uint8_t)0x00)
+ #define I2C_OARH_RESET_VALUE   ((uint8_t)0x00)
+ #define I2C_DR_RESET_VALUE     ((uint8_t)0x00)
+ #define I2C_SR1_RESET_VALUE    ((uint8_t)0x00)
+ #define I2C_SR2_RESET_VALUE    ((uint8_t)0x00)
+ #define I2C_SR3_RESET_VALUE    ((uint8_t)0x00)
+ #define I2C_ITR_RESET_VALUE    ((uint8_t)0x00)
+ #define I2C_CCRL_RESET_VALUE   ((uint8_t)0x00)
+ #define I2C_CCRH_RESET_VALUE   ((uint8_t)0x00)
+ #define I2C_TRISER_RESET_VALUE ((uint8_t)0x02)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup I2C_Registers_Bits_Definition
+   * @{
+   */
+ 
+ #define I2C_CR1_NOSTRETCH ((uint8_t)0x80) /*!< Clock Stretching Disable (Slave mode) */
+ #define I2C_CR1_ENGC      ((uint8_t)0x40) /*!< General Call Enable */
+ #define I2C_CR1_PE        ((uint8_t)0x01) /*!< Peripheral Enable */
+ 
+ #define I2C_CR2_SWRST ((uint8_t)0x80) /*!< Software Reset */
+ #define I2C_CR2_POS   ((uint8_t)0x08) /*!< Acknowledge */
+ #define I2C_CR2_ACK   ((uint8_t)0x04) /*!< Acknowledge Enable */
+ #define I2C_CR2_STOP  ((uint8_t)0x02) /*!< Stop Generation */
+ #define I2C_CR2_START ((uint8_t)0x01) /*!< Start Generation */
+ 
+ #define I2C_FREQR_FREQ ((uint8_t)0x3F) /*!< Peripheral Clock Frequency */
+ 
+ #define I2C_OARL_ADD  ((uint8_t)0xFE) /*!< Interface Address bits [7..1] */
+ #define I2C_OARL_ADD0 ((uint8_t)0x01) /*!< Interface Address bit0 */
+ 
+ #define I2C_OARH_ADDMODE ((uint8_t)0x80) /*!< Addressing Mode (Slave mode) */
+ #define I2C_OARH_ADDCONF ((uint8_t)0x40) /*!< Address mode configuration */
+ #define I2C_OARH_ADD     ((uint8_t)0x06) /*!< Interface Address bits [9..8] */
+ 
+ #define I2C_DR_DR ((uint8_t)0xFF) /*!< Data Register */
+ 
+ #define I2C_SR1_TXE   ((uint8_t)0x80) /*!< Data Register Empty (transmitters) */
+ #define I2C_SR1_RXNE  ((uint8_t)0x40) /*!< Data Register not Empty (receivers) */
+ #define I2C_SR1_STOPF ((uint8_t)0x10) /*!< Stop detection (Slave mode) */
+ #define I2C_SR1_ADD10 ((uint8_t)0x08) /*!< 10-bit header sent (Master mode) */
+ #define I2C_SR1_BTF   ((uint8_t)0x04) /*!< Byte Transfer Finished */
+ #define I2C_SR1_ADDR  ((uint8_t)0x02) /*!< Address sent (master mode)/matched (slave mode) */
+ #define I2C_SR1_SB    ((uint8_t)0x01) /*!< Start Bit (Master mode) */
+ 
+ #define I2C_SR2_WUFH    ((uint8_t)0x20) /*!< Wake-up from Halt */
+ #define I2C_SR2_OVR     ((uint8_t)0x08) /*!< Overrun/Underrun */
+ #define I2C_SR2_AF      ((uint8_t)0x04) /*!< Acknowledge Failure */
+ #define I2C_SR2_ARLO    ((uint8_t)0x02) /*!< Arbitration Lost (master mode) */
+ #define I2C_SR2_BERR    ((uint8_t)0x01) /*!< Bus Error */
+ 
+ #define I2C_SR3_GENCALL ((uint8_t)0x10) /*!< General Call Header (Slave mode) */
+ #define I2C_SR3_TRA     ((uint8_t)0x04) /*!< Transmitter/Receiver */
+ #define I2C_SR3_BUSY    ((uint8_t)0x02) /*!< Bus Busy */
+ #define I2C_SR3_MSL     ((uint8_t)0x01) /*!< Master/Slave */
+ 
+ #define I2C_ITR_ITBUFEN ((uint8_t)0x04) /*!< Buffer Interrupt Enable */
+ #define I2C_ITR_ITEVTEN ((uint8_t)0x02) /*!< Event Interrupt Enable */
+ #define I2C_ITR_ITERREN ((uint8_t)0x01) /*!< Error Interrupt Enable */
+ 
+ #define I2C_CCRL_CCR ((uint8_t)0xFF) /*!< Clock Control Register (Master mode) */
+ 
+ #define I2C_CCRH_FS   ((uint8_t)0x80) /*!< Master Mode Selection */
+ #define I2C_CCRH_DUTY ((uint8_t)0x40) /*!< Fast Mode Duty Cycle */
+ #define I2C_CCRH_CCR  ((uint8_t)0x0F) /*!< Clock Control Register in Fast/Standard mode (Master mode) bits [11..8] */
+ 
+ #define I2C_TRISER_TRISE ((uint8_t)0x3F) /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief IR digital interface (IRTIM)
+   */
+ typedef struct IRTIM_struct
+ {
+   __IO uint8_t CR; /*!< control register */
+ }
+ IRTIM_TypeDef;
+ /** @addtogroup IRTIM_Registers_Reset_Value
+   * @{
+   */
+ #define IRTIM_CR_RESET_VALUE    ((uint8_t)0x00)
+ 
+ 
+ /**
+ * @}
+ */
+ 
+ /** @addtogroup IRTIM_Registers_Bits_Definition
+   * @{
+   */
+ /* CR*/
+ #define IRTIM_CR_EN     ((uint8_t)0x01) /*!< IRTIM_OUT enable Mask. */
+ #define IRTIM_CR_HSEN   ((uint8_t)0x02) /*!< High sink open drain buffer enable Mask */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief Interrupt Controller (ITC)
+   */
+ typedef struct ITC_struct
+ {
+   __IO uint8_t ISPR1; /*!<  Interrupt Software Priority register 1 */
+   __IO uint8_t ISPR2; /*!<  Interrupt Software Priority register 2 */
+   __IO uint8_t ISPR3; /*!<  Interrupt Software Priority register 3 */
+   __IO uint8_t ISPR4; /*!<  Interrupt Software Priority register 4 */
+   __IO uint8_t ISPR5; /*!<  Interrupt Software Priority register 5 */
+   __IO uint8_t ISPR6; /*!<  Interrupt Software Priority register 6 */
+   __IO uint8_t ISPR7; /*!<  Interrupt Software Priority register 7 */
+   __IO uint8_t ISPR8; /*!< Interrupt Software Priority register 8 */
+ }
+ ITC_TypeDef;
+ 
+ /** @addtogroup ITC_Registers_Reset_Value
+   * @{
+   */
+ #define ITC_SPR1_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 1 */
+ #define ITC_SPR2_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 2 */
+ #define ITC_SPR3_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 3 */
+ #define ITC_SPR4_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 4 */
+ #define ITC_SPR5_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 5 */
+ #define ITC_SPR6_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 6 */
+ #define ITC_SPR7_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 7 */
+ #define ITC_SPR8_RESET_VALUE ((uint8_t)0xFF) /*!< Reset value of Software Priority registers 8 */
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief Internal Low Speed Watchdog (IWDG)
+   */
+ typedef struct IWDG_struct
+ {
+   __IO uint8_t KR;  /*!<  Low Speed Watchdog Key Register */
+   __IO uint8_t PR;  /*!<  Low Speed Watchdog Prescaler Register */
+   __IO uint8_t RLR; /*!<  Low Speed Watchdog Reload Register */
+ }
+ IWDG_TypeDef;
+ 
+ /** @addtogroup IWDG_Registers_Reset_Value
+   * @{
+   */
+ #define IWDG_RLR_RESET_VALUE    ((uint8_t)0xFF)  /*! <Reload Register Default Value */
+ #define IWDG_PR_RESET_VALUE     ((uint8_t)0x00)  /*! <Prescaler Register Default Value */
+ /**
+   * @}
+   */
+ /*----------------------------------------------------------------------------*/
+ 
+ 
+ /**
+   * @brief Wait For Event (WFE) peripheral registers.
+   */
+ /** @addtogroup WFE_Registers
+   * @{
+   */
+ typedef struct WFE_struct
+ {
+   __IO uint8_t CR1;   /*!<  Wait for event control register 1 */
+   __IO uint8_t CR2;   /*!<  Wait for event control register 2 */
+ }
+ WFE_TypeDef;
+ /**
+   * @}
+   */
+ /** @addtogroup WFE_Registers_Reset_Value
+   * @{
+   */
+ 
+ #define WFE_CR1_RESET_VALUE ((uint8_t)0x00) /*!< Reset value wait for event control register1*/
+ #define WFE_CR2_RESET_VALUE ((uint8_t)0x00) /*!< Reset value wait for event control register2*/
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup WFE_Registers_Bits_Definition
+   * @{
+   */
+ 
+ #define WFE_CR1_EXTI_EV3     ((uint8_t)0x80) /*!< External interrupt event 3*/
+ #define WFE_CR1_EXTI_EV2     ((uint8_t)0x40) /*!< External interrupt event 2*/
+ #define WFE_CR1_EXTI_EV1     ((uint8_t)0x20) /*!< External interrupt event 1*/
+ #define WFE_CR1_EXTI_EV0     ((uint8_t)0x10) /*!< External interrupt event 0*/
+ #define WFE_CR1_TIM2_EV1     ((uint8_t)0x02) /*!< TIM2 event 1*/
+ #define WFE_CR1_TIM2_EV0     ((uint8_t)0x01) /*!< TIM2 event 0*/
+ 
+ #define WFE_CR2_EXTI_EVD     ((uint8_t)0x20) /*!< External interrupt event on Port D*/
+ #define WFE_CR2_EXTI_EVB     ((uint8_t)0x10) /*!< External interrupt event on Port B*/
+ #define WFE_CR2_EXTI_EV7     ((uint8_t)0x08) /*!< External interrupt event 7*/
+ #define WFE_CR2_EXTI_EV6     ((uint8_t)0x04) /*!< External interrupt event 6*/
+ #define WFE_CR2_EXTI_EV5     ((uint8_t)0x02) /*!< External interrupt event 5*/
+ #define WFE_CR2_EXTI_EV4     ((uint8_t)0x01) /*!< External interrupt event 4*/
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ /**
+   * @brief Option Bytes (OPT)
+   */
+ typedef struct OPT_struct
+ {
+   __IO uint8_t OPT0_LOCKBYTE;   /*!< Option byte 0 */
+   __IO uint8_t OPT1_PCODESIZE;  /*!< Option byte 1 */
+   __IO uint8_t OPT2_BOOTSIZE;   /*!< Option byte 2 */
+   __IO uint8_t OPT3_DATASIZE;   /*!< Option byte 3 */
+ }
+ OPT_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief Reset Controller (RST)
+   */
+ typedef struct RST_struct
+ {
+   __IO uint8_t CR;  /*!< Multiplex Reset Pad */
+   __IO uint8_t SR;  /*!< Reset status register */
+ 
+ }
+ RST_TypeDef;
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup RST_Registers_Reset_Value
+   * @{
+   */
+ 
+ #define RST_CR_RESET_VALUE    ((uint8_t)0x00) /*!< Reset pin configuration register  1 reset value */
+ #define RST_SR_RESET_VALUE    ((uint8_t)0x01) /*!< Reset status register 2 reset value */
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup RST_Registers_Bits_Definition
+   * @{
+   */
+ #define RST_SR_SWIMF  ((uint8_t)0x08) /*!< SWIM reset flag mask */
+ #define RST_SR_ILLOPF ((uint8_t)0x04) /*!< Illegal opcode reset flag mask */
+ #define RST_SR_IWDGF  ((uint8_t)0x02) /*!< Independent Watchdog reset flag mask */
+ #define RST_SR_PORF   ((uint8_t)0x01) /*!< Power On Reset (POR) flag mask */
+ 
+ /**
+   * @}
+   */
+ /*----------------------------------------------------------------------------ok*/
+ 
+ /**
+   * @brief Serial Peripheral Interface (SPI)
+   */
+ typedef struct SPI_struct
+ {
+   __IO uint8_t CR1;    /*!< SPI control register 1 */
+   __IO uint8_t CR2;    /*!< SPI control register 2 */
+   __IO uint8_t ICR;    /*!< SPI interrupt control register */
+   __IO uint8_t SR;     /*!< SPI status register */
+   __IO uint8_t DR;     /*!< SPI data I/O register */
+ }
+ SPI_TypeDef;
+ 
+ /** @addtogroup SPI_Registers_Reset_Value
+   * @{
+   */
+ 
+ #define SPI_CR1_RESET_VALUE    ((uint8_t)0x00) /*!< Control Register 1 reset value */
+ #define SPI_CR2_RESET_VALUE    ((uint8_t)0x00) /*!< Control Register 2 reset value */
+ #define SPI_ICR_RESET_VALUE    ((uint8_t)0x00) /*!< Interrupt Control Register reset value */
+ #define SPI_SR_RESET_VALUE     ((uint8_t)0x02) /*!< Status Register reset value */
+ #define SPI_DR_RESET_VALUE     ((uint8_t)0x00) /*!< Data Register reset value */
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup SPI_Registers_Bits_Definition
+   * @{
+   */
+ 
+ #define SPI_CR1_LSBFIRST ((uint8_t)0x80) /*!< Frame format mask */
+ #define SPI_CR1_SPE      ((uint8_t)0x40) /*!< Enable bits mask */
+ #define SPI_CR1_BR       ((uint8_t)0x38) /*!< Baud rate control mask */
+ #define SPI_CR1_MSTR     ((uint8_t)0x04) /*!< Master Selection mask */
+ #define SPI_CR1_CPOL     ((uint8_t)0x02) /*!< Clock Polarity mask */
+ #define SPI_CR1_CPHA     ((uint8_t)0x01) /*!< Clock Phase mask */
+ 
+ #define SPI_CR2_BDM     ((uint8_t)0x80) /*!< Bi-directional data mode enable mask */
+ #define SPI_CR2_BDOE    ((uint8_t)0x40) /*!< Output enable in bi-directional mode mask */
+ #define SPI_CR2_RXONLY  ((uint8_t)0x04) /*!< Receive only mask */
+ #define SPI_CR2_SSM     ((uint8_t)0x02) /*!< Software slave management mask */
+ #define SPI_CR2_SSI     ((uint8_t)0x01) /*!< Internal slave select mask */
+ 
+ #define SPI_ICR_TXIE    ((uint8_t)0x80) /*!< Tx buffer empty interrupt enable mask */
+ #define SPI_ICR_RXIE    ((uint8_t)0x40) /*!< Rx buffer empty interrupt enable mask */
+ #define SPI_ICR_ERRIE   ((uint8_t)0x20) /*!< Error interrupt enable mask */
+ #define SPI_ICR_WKIE    ((uint8_t)0x10) /*!< Wake-up interrupt enable mask */
+ 
+ #define SPI_SR_BSY    ((uint8_t)0x80) /*!< Busy flag */
+ #define SPI_SR_OVR    ((uint8_t)0x40) /*!< Overrun flag */
+ #define SPI_SR_MODF   ((uint8_t)0x20) /*!< Mode fault */
+ #define SPI_SR_WKUP   ((uint8_t)0x08) /*!< Wake-Up flag */
+ #define SPI_SR_TXE    ((uint8_t)0x02) /*!< Transmit buffer empty */
+ #define SPI_SR_RXNE   ((uint8_t)0x01) /*!< Receive buffer not empty */
+ 
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief 16 bit timer with complementary PWM outputs (TIM2 & TIM3)
+   */
+ typedef struct TIM_struct
+ {
+   __IO uint8_t CR1;  /*!< control register 1   */
+   __IO uint8_t CR2;  /*!< control register 2   */
+   __IO uint8_t SMCR;  /*!< Synchro mode control register */
+   __IO uint8_t ETR;  /*!< external trigger register */
+   __IO uint8_t IER;  /*!< interrupt enable register*/
+   __IO uint8_t SR1;  /*!< status register 1   */
+   __IO uint8_t SR2;  /*!< status register 2   */
+   __IO uint8_t EGR;  /*!< event generation register */
+   __IO uint8_t CCMR1;  /*!< CC mode register 1      */
+   __IO uint8_t CCMR2;  /*!< CC mode register 2      */
+   __IO uint8_t CCER1;  /*!< CC enable register 1     */
+   __IO uint8_t CNTRH;  /*!< counter high       */
+   __IO uint8_t CNTRL;  /*!< counter low       */
+   __IO uint8_t PSCR;  /*!< prescaler     */
+   __IO uint8_t ARRH;  /*!< auto-reload register high  */
+   __IO uint8_t ARRL;  /*!< auto-reload register low    */
+   __IO uint8_t CCR1H;  /*!< capture/compare register 1 high   */
+   __IO uint8_t CCR1L;  /*!< capture/compare register 1 low     */
+   __IO uint8_t CCR2H;  /*!< capture/compare register 2 high   */
+   __IO uint8_t CCR2L;  /*!< capture/compare register 2 low     */
+   __IO uint8_t BKR;  /*!< Break Register */
+   __IO uint8_t OISR;  /*!< Output idle register */
+ }
+ TIM_TypeDef;
+ 
+ /** @addtogroup TIM2_TIM3_Registers_Reset_Value
+   * @{
+   */
+ #define TIM_CR1_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_CR2_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_SMCR_RESET_VALUE ((uint8_t)0x00)
+ #define TIM_ETR_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_IER_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_SR1_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_SR2_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_EGR_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_CCMR1_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_CCMR2_RESET_VALUE  ((uint8_t)0x00)
+ 
+ #define TIM_CCER1_RESET_VALUE  ((uint8_t)0x00)
+ 
+ #define TIM_CNTRH_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_CNTRL_RESET_VALUE  ((uint8_t)0x00)
+ 
+ #define TIM_PSCR_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_ARRH_RESET_VALUE  ((uint8_t)0xFF)
+ #define TIM_ARRL_RESET_VALUE  ((uint8_t)0xFF)
+ 
+ #define TIM_CCR1H_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_CCR1L_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_CCR2H_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_CCR2L_RESET_VALUE  ((uint8_t)0x00)
+ 
+ #define TIM_BKR_RESET_VALUE  ((uint8_t)0x00)
+ #define TIM_OISR_RESET_VALUE  ((uint8_t)0x00)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup TIM2_TIM3_Registers_Bits_Definition
+   * @{
+   */
+ /* CR1*/
+ #define TIM_CR1_ARPE    ((uint8_t)0x80) /*!< Auto-Reload Preload Enable Mask. */
+ #define TIM_CR1_CMS     ((uint8_t)0x60) /*!< Center-aligned Mode Selection Mask. */
+ #define TIM_CR1_DIR     ((uint8_t)0x10) /*!< Direction Mask. */
+ #define TIM_CR1_OPM     ((uint8_t)0x08) /*!< One Pulse Mode Mask. */
+ #define TIM_CR1_URS     ((uint8_t)0x04) /*!< Update Request Source Mask. */
+ #define TIM_CR1_UDIS    ((uint8_t)0x02) /*!< Update Disable Mask. */
+ #define TIM_CR1_CEN     ((uint8_t)0x01) /*!< Counter Enable Mask. */
+ 
+ /* CR2*/
+ #define TIM_CR2_TI1S    ((uint8_t)0x80) /*!< TI1S Selection Mask. */
+ #define TIM_CR2_MMS     ((uint8_t)0x70) /*!< MMS Selection Mask. */
+ 
+ /* SMCR*/
+ #define TIM_SMCR_MSM    ((uint8_t)0x80) /*!< Master/Slave Mode Mask. */
+ #define TIM_SMCR_TS     ((uint8_t)0x70) /*!< Trigger Selection Mask. */
+ #define TIM_SMCR_SMS    ((uint8_t)0x07) /*!< Slave Mode Selection Mask. */
+ 
+ 
+ /* ETR*/
+ #define TIM_ETR_ECE     ((uint8_t)0x40)/*!< External Clock Mask. */
+ #define TIM_ETR_ETP     ((uint8_t)0x80) /*!< External Trigger Polarity Mask. */
+ #define TIM_ETR_ETPS    ((uint8_t)0x30) /*!< External Trigger Prescaler Mask. */
+ #define TIM_ETR_ETF     ((uint8_t)0x0F) /*!< External Trigger Filter Mask. */
+ 
+ 
+ /* IER*/
+ #define TIM_IER_BIE     ((uint8_t)0x80) /*!< Break Interrupt Enable Mask. */
+ #define TIM_IER_TIE     ((uint8_t)0x40) /*!< Trigger Interrupt Enable Mask. */
+ #define TIM_IER_CC2IE   ((uint8_t)0x04) /*!< Capture/Compare 2 Interrupt Enable Mask. */
+ #define TIM_IER_CC1IE   ((uint8_t)0x02) /*!< Capture/Compare 1 Interrupt Enable Mask. */
+ #define TIM_IER_UIE     ((uint8_t)0x01) /*!< Update Interrupt Enable Mask. */
+ 
+ /* SR1*/
+ #define TIM_SR1_BIF     ((uint8_t)0x80) /*!< Break Interrupt Flag Mask. */
+ #define TIM_SR1_TIF     ((uint8_t)0x40) /*!< Trigger Interrupt Flag Mask. */
+ #define TIM_SR1_CC2IF   ((uint8_t)0x04) /*!< Capture/Compare 2 Interrupt Flag Mask. */
+ #define TIM_SR1_CC1IF   ((uint8_t)0x02) /*!< Capture/Compare 1 Interrupt Flag Mask. */
+ #define TIM_SR1_UIF     ((uint8_t)0x01) /*!< Update Interrupt Flag Mask. */
+ 
+ /* SR2*/
+ #define TIM_SR2_CC2OF   ((uint8_t)0x04) /*!< Capture/Compare 2 Overcapture Flag Mask. */
+ #define TIM_SR2_CC1OF   ((uint8_t)0x02) /*!< Capture/Compare 1 Overcapture Flag Mask. */
+ 
+ /*EGR*/
+ #define TIM_EGR_BG      ((uint8_t)0x80) /*!< Break Generation Mask. */
+ #define TIM_EGR_TG      ((uint8_t)0x40) /*!< Trigger Generation Mask. */
+ #define TIM_EGR_CC2G    ((uint8_t)0x04) /*!< Capture/Compare 2 Generation Mask. */
+ #define TIM_EGR_CC1G    ((uint8_t)0x02) /*!< Capture/Compare 1 Generation Mask. */
+ #define TIM_EGR_UG      ((uint8_t)0x01) /*!< Update Generation Mask. */
+ 
+ /*CCMR*/
+ #define TIM_CCMR_ICxPSC          ((uint8_t)0x0C) /*!< Input Capture x Prescaler Mask. */
+ #define TIM_CCMR_ICxF            ((uint8_t)0xF0) /*!< Input Capture x Filter Mask. */
+ #define TIM_CCMR_OCM             ((uint8_t)0x70) /*!< Output Compare x Mode Mask. */
+ #define TIM_CCMR_OCxPE         ((uint8_t)0x08) /*!< Output Compare x Preload Enable Mask. */
+ #define TIM_CCMR_OCxFE          ((uint8_t)0x04) /*!< Output Compare x Fast Enable Mask. */
+ #define TIM_CCMR_CCxS            ((uint8_t)0x03) /*!< Capture/Compare x Selection Mask. */
+ #define TIM_CCMR_TIxDirect_Set   ((uint8_t)0x01)
+ 
+ /*CCER1*/
+ #define TIM_CCER1_CC2P  ((uint8_t)0x20) /*!< Capture/Compare 2 output Polarity Mask. */
+ #define TIM_CCER1_CC2E  ((uint8_t)0x10) /*!< Capture/Compare 2 output enable Mask. */
+ #define TIM_CCER1_CC1P  ((uint8_t)0x02) /*!< Capture/Compare 1 output Polarity Mask. */
+ #define TIM_CCER1_CC1E  ((uint8_t)0x01) /*!< Capture/Compare 1 output enable Mask. */
+ 
+ /*CNTR*/
+ #define TIM_CNTRH_CNT   ((uint8_t)0xFF) /*!< Counter Value (MSB) Mask. */
+ #define TIM_CNTRL_CNT   ((uint8_t)0xFF) /*!< Counter Value (LSB) Mask. */
+ 
+ /*PSCR*/
+ #define TIM_PSC_PSC     ((uint8_t)0x03) /*!< Prescaler Value  Mask. */
+ 
+ /*ARR*/
+ #define TIM_ARRH_ARR    ((uint8_t)0xFF) /*!< Autoreload Value (MSB) Mask. */
+ #define TIM_ARRL_ARR    ((uint8_t)0xFF) /*!< Autoreload Value (LSB) Mask. */
+ 
+ 
+ /*CCR1*/
+ #define TIM_CCR1H_CCR1  ((uint8_t)0xFF) /*!< Capture/Compare 1 Value (MSB) Mask. */
+ #define TIM_CCR1L_CCR1  ((uint8_t)0xFF) /*!< Capture/Compare 1 Value (LSB) Mask. */
+ 
+ /*CCR2*/
+ #define TIM_CCR2H_CCR2  ((uint8_t)0xFF) /*!< Capture/Compare 2 Value (MSB) Mask. */
+ #define TIM_CCR2L_CCR2  ((uint8_t)0xFF) /*!< Capture/Compare 2 Value (LSB) Mask. */
+ 
+ 
+ /*BKR*/
+ #define TIM_BKR_MOE     ((uint8_t)0x80) /*!< Main Output Enable Mask. */
+ #define TIM_BKR_AOE     ((uint8_t)0x40) /*!< Automatic Output Enable Mask. */
+ #define TIM_BKR_BKP     ((uint8_t)0x20) /*!< Break Polarity Mask. */
+ #define TIM_BKR_BKE     ((uint8_t)0x10) /*!< Break Enable Mask. */
+ #define TIM_BKR_OSSI    ((uint8_t)0x04) /*!< Off-State Selection for Idle mode Mask. */
+ #define TIM_BKR_LOCK    ((uint8_t)0x03) /*!<Lock Configuration Mask. */
+ 
+ /*OISR*/
+ #define TIM_OISR_OIS2   ((uint8_t)0x04) /*!< Output Idle state 2 (OC2 output) Mask. */
+ #define TIM_OISR_OIS1   ((uint8_t)0x01) /*!< Output Idle state 1 (OC1 output) Mask. */
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief 8-bit system or Low End Small Timer (TIM4)
+   */
+ typedef struct TIM4_struct
+ {
+   __IO uint8_t CR1;  /*!< control register 1 */
+   __IO uint8_t CR2;  /*!< control register 2 */
+   __IO uint8_t SMCR;  /*!< Synchro mode control register */
+   __IO uint8_t IER;  /*!< interrupt enable register  */
+   __IO uint8_t SR1;  /*!< status register 1    */
+   __IO uint8_t EGR;  /*!< event generation register */
+   __IO uint8_t CNTR;  /*!< counter register  */
+   __IO uint8_t PSCR;  /*!< prescaler register */
+   __IO uint8_t ARR;  /*!< auto-reload register */
+ }
+ TIM4_TypeDef;
+ /** @addtogroup TIM4_Registers_Reset_Value
+   * @{
+   */
+ #define TIM4_CR1_RESET_VALUE    ((uint8_t)0x00)
+ #define TIM4_CR2_RESET_VALUE    ((uint8_t)0x00)
+ #define TIM4_SMCR_RESET_VALUE   ((uint8_t)0x00)
+ #define TIM4_IER_RESET_VALUE    ((uint8_t)0x00)
+ #define TIM4_SR1_RESET_VALUE    ((uint8_t)0x00)
+ #define TIM4_EGR_RESET_VALUE    ((uint8_t)0x00)
+ #define TIM4_CNTR_RESET_VALUE   ((uint8_t)0x00)
+ #define TIM4_PSCR_RESET_VALUE   ((uint8_t)0x00)
+ #define TIM4_ARR_RESET_VALUE    ((uint8_t)0xFF)
+ 
+ /**
+ * @}
+ */
+ 
+ /** @addtogroup TIM4_Registers_Bits_Definition
+   * @{
+   */
+ /* CR1*/
+ #define TIM4_CR1_ARPE     ((uint8_t)0x80) /*!< Auto-Reload Preload Enable Mask. */
+ #define TIM4_CR1_OPM      ((uint8_t)0x08) /*!< One Pulse Mode Mask. */
+ #define TIM4_CR1_URS      ((uint8_t)0x04) /*!< Update Request Source Mask. */
+ #define TIM4_CR1_UDIS     ((uint8_t)0x02) /*!< Update Disable Mask. */
+ #define TIM4_CR1_CEN      ((uint8_t)0x01) /*!< Counter Enable Mask. */
+ 
+ /* CR2*/
+ #define TIM4_CR2_MMS   ((uint8_t)0x70) /*!< MMS Selection Mask. */
+ 
+ /* SMCR*/
+ #define TIM4_SMCR_TS       ((uint8_t)0x70) /*!< Trigger Selection Mask. */
+ #define TIM4_SMCR_SMS      ((uint8_t)0x07) /*!< Slave Mode Selection Mask. */
+ #define TIM4_SMCR_MSM      ((uint8_t)0x80) /*!< Master/Slave Mode Mask. */
+ 
+ /* IER*/
+ #define TIM4_IER_TIE       ((uint8_t)0x40) /*!< Trigger Interrupt Enable Mask. */
+ #define TIM4_IER_UIE       ((uint8_t)0x01) /*!< Update Interrupt Enable Mask. */
+ 
+ /* SR1*/
+ #define TIM4_SR1_TIF       ((uint8_t)0x40) /*!< Trigger Interrupt Flag Mask. */
+ #define TIM4_SR1_UIF       ((uint8_t)0x01) /*!< Update Interrupt Flag Mask. */
+ 
+ /* EGR*/
+ #define TIM4_EGR_TG        ((uint8_t)0x40) /*!< Trigger Generation Mask. */
+ #define TIM4_EGR_UG        ((uint8_t)0x01) /*!< Update Generation Mask. */
+ 
+ /* CNTR*/
+ #define TIM4_CNTR_CNT      ((uint8_t)0xFF) /*!<Counter Value (LSB) Mask. */
+ 
+ /* PSCR*/
+ #define TIM4_PSCR_PSC      ((uint8_t)0x0F) /*!<Prescaler Value  Mask. */
+ 
+ /* ARR*/
+ #define TIM4_ARR_ARR     ((uint8_t)0xFF) /*!<Autoreload Value Mask. */
+ /**
+   * @}
+   */
+ 
+ /*----------------------------------------------------------------------------*/
+ 
+ /**
+   * @brief USART
+   */
+ typedef struct USART_struct
+ {
+   __IO uint8_t SR;  /*!<  USART status register  */
+   __IO uint8_t DR;  /*!<  USART data register     */
+   __IO uint8_t BRR1;  /*!<  USART baud rate register   */
+   __IO uint8_t BRR2;  /*!<  USART DIV mantissa[11:8] SCIDIV fraction */
+   __IO uint8_t CR1;  /*!<  USART control register 1     */
+   __IO uint8_t CR2;  /*!<  USART control register 2     */
+   __IO uint8_t CR3;  /*!<  USART control register 3      */
+   __IO uint8_t CR4;  /*!< USART control register 4      */
+   __IO uint8_t CR5;  /*!<  USART control register 5       */
+   __IO uint8_t GTR;  /*!<  USART guard time register     */
+   __IO uint8_t PSCR;  /*!<  USART prescaler register     */
+ }
+ USART_TypeDef;
+ 
+ 
+ /** @addtogroup USART_Registers_Reset_Value
+   * @{
+   */
+ #define USART_SR_RESET_VALUE ((uint8_t)0xC0)
+ #define USART_BRR1_RESET_VALUE ((uint8_t)0x00)
+ #define USART_BRR2_RESET_VALUE ((uint8_t)0x00)
+ #define USART_CR1_RESET_VALUE ((uint8_t)0x00)
+ #define USART_CR2_RESET_VALUE ((uint8_t)0x00)
+ #define USART_CR3_RESET_VALUE ((uint8_t)0x00)
+ #define USART_CR4_RESET_VALUE ((uint8_t)0x00)
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup USART_Registers_Bits_Definition
+   * @{
+   */
+ #define USART_SR_TXE      ((uint8_t)0x80) /*!< Transmit Data Register Empty Mask         */
+ #define USART_SR_TC       ((uint8_t)0x40) /*!< Transmission Complete Mask                */
+ #define USART_SR_RXNE     ((uint8_t)0x20) /*!< Read Data Register Not Empty Mask         */
+ #define USART_SR_IDLE     ((uint8_t)0x10) /*!< IDLE line detected Mask                   */
+ #define USART_SR_OR       ((uint8_t)0x08) /*!< OverRun error Mask                        */
+ #define USART_SR_NF       ((uint8_t)0x04) /*!< Noise Flag Mask                           */
+ #define USART_SR_FE       ((uint8_t)0x02) /*!< Framing Error Mask                        */
+ #define USART_SR_PE       ((uint8_t)0x01) /*!< Parity Error Mask                         */
+ #define USART_BRR1_DIVM   ((uint8_t)0xFF) /*!< LSB mantissa of USARTDIV [7:0] Mask       */
+ #define USART_BRR2_DIVM   ((uint8_t)0xF0) /*!< MSB mantissa of USARTDIV [11:8] Mask      */
+ #define USART_BRR2_DIVF   ((uint8_t)0x0F) /*!< Fraction bits of USARTDIV [3:0] Mask      */
+ #define USART_CR1_R8      ((uint8_t)0x80) /*!< Receive Data bit 8                        */
+ #define USART_CR1_T8      ((uint8_t)0x40) /*!< Transmit data bit 8                       */
+ #define USART_CR1_USARTD ((uint8_t)0x20)  /*!< USART Disable (for low power consumption) */
+ #define USART_CR1_M       ((uint8_t)0x10) /*!< Word length Mask                          */
+ #define USART_CR1_WAKE    ((uint8_t)0x08) /*!< Wake-up method Mask                       */
+ #define USART_CR1_PCEN    ((uint8_t)0x04) /*!< Parity Control Enable Mask                */
+ #define USART_CR1_PS      ((uint8_t)0x02) /*!< USART Parity Selection                 */
+ #define USART_CR1_PIEN    ((uint8_t)0x01) /*!< USART Parity Interrupt Enable Mask        */
+ #define USART_CR2_TIEN    ((uint8_t)0x80) /*!< Transmitter Interrupt Enable Mask         */
+ #define USART_CR2_TCIEN   ((uint8_t)0x40) /*!< TransmissionComplete Interrupt Enable Mask*/
+ #define USART_CR2_RIEN    ((uint8_t)0x20) /*!< Receiver Interrupt Enable Mask            */
+ #define USART_CR2_ILIEN   ((uint8_t)0x10) /*!< IDLE Line Interrupt Enable Mask           */
+ #define USART_CR2_TEN     ((uint8_t)0x08) /*!< Transmitter Enable Mask                   */
+ #define USART_CR2_REN     ((uint8_t)0x04) /*!< Receiver Enable Mask                      */
+ #define USART_CR2_RWU     ((uint8_t)0x02) /*!< Receiver Wake-Up Mask                     */
+ #define USART_CR2_SBK     ((uint8_t)0x01) /*!< Send Break Mask                     */
+ #define USART_CR3_Reserved ((uint8_t)0x80) /*!< RESERVED bit Mask                        */
+ #define USART_CR3_STOP    ((uint8_t)0x30) /*!< STOP bits [1:0] Mask                      */
+ #define USART_CR3_CLKEN   ((uint8_t)0x08) /*!< Clock Enable Mask                         */
+ #define USART_CR3_CPOL    ((uint8_t)0x04) /*!< Clock Polarity Mask                       */
+ #define USART_CR3_CPHA    ((uint8_t)0x02) /*!< Clock Phase Mask                          */
+ #define USART_CR3_LBCL    ((uint8_t)0x01) /*!< Last Bit Clock pulse Mask                 */
+ #define USART_CR4_Reserved ((uint8_t)0x80) /*!< RESERVED bit Mask                        */
+ #define USART_CR4_ADD     ((uint8_t)0x0F) /*!< Address of the USART node Mask            */
+ /**
+   * @}
+   */
+ /*----------------------------------------------------------------------------*/
+ 
+ /******************************************************************************/
+ /*                          Peripherals Base Address                          */
+ /******************************************************************************/
+ 
+ 
+ #define GPIOA_BaseAddress       0x5000
+ #define GPIOB_BaseAddress       0x5005
+ #define GPIOC_BaseAddress       0x500A
+ #define GPIOD_BaseAddress       0x500F
+ 
+ #define FLASH_BaseAddress       0x5050
+ 
+ #define USART_BaseAddress       0x5230
+ 
+ #define TIM2_BaseAddress        0x5250
+ #define TIM3_BaseAddress        0x5280
+ #define TIM4_BaseAddress        0x52E0
+ 
+ #define IRTIM_BaseAddress       0x52FF
+ 
+ #define COMP_BaseAddress        0x5300
+ 
+ #define EXTI_BaseAddress        0x50A0
+ 
+ #define WFE_BaseAddress         0x50A6
+ 
+ #define RST_BaseAddress         0x50B0
+ 
+ #define CLK_BaseAddress         0x50C0
+ 
+ #define IWDG_BaseAddress        0x50E0
+ 
+ #define AWU_BaseAddress         0x50F0
+ 
+ #define BEEP_BaseAddress        0x50F3
+ 
+ #define SPI_BaseAddress         0x5200
+ 
+ #define I2C_BaseAddress         0x5210
+ 
+ #define OPT_BaseAddress         0x4800
+ 
+ #define ITC_BaseAddress         0x7F70
+ 
+ #define DM_BaseAddress          0x7F90
+ 
+ /******************************************************************************/
+ /*                          Peripherals declarations                          */
+ /******************************************************************************/
+ 
+ 
+ #define GPIOA ((GPIO_TypeDef *) GPIOA_BaseAddress)
+ #define GPIOB ((GPIO_TypeDef *) GPIOB_BaseAddress)
+ #define GPIOC ((GPIO_TypeDef *) GPIOC_BaseAddress)
+ #define GPIOD ((GPIO_TypeDef *) GPIOD_BaseAddress)
+ #define FLASH ((FLASH_TypeDef *) FLASH_BaseAddress)
+ #define EXTI ((EXTI_TypeDef *) EXTI_BaseAddress)
+ #define RST ((RST_TypeDef *) RST_BaseAddress)
+ #define CLK ((CLK_TypeDef *) CLK_BaseAddress)
+ #define IWDG ((IWDG_TypeDef *) IWDG_BaseAddress)
+ #define WFE ((WFE_TypeDef *) WFE_BaseAddress)
+ #define AWU ((AWU_TypeDef *) AWU_BaseAddress)
+ #define BEEP ((BEEP_TypeDef *) BEEP_BaseAddress)
+ #define SPI ((SPI_TypeDef *) SPI_BaseAddress)
+ #define I2C ((I2C_TypeDef *) I2C_BaseAddress)
+ #define USART ((USART_TypeDef *) USART_BaseAddress)
+ #define TIM2 ((TIM_TypeDef *) TIM2_BaseAddress)
+ #define TIM3 ((TIM_TypeDef *) TIM3_BaseAddress)
+ #define TIM4 ((TIM4_TypeDef *) TIM4_BaseAddress)
+ #define IRTIM ((IRTIM_TypeDef *) IRTIM_BaseAddress)
+ #define ITC ((ITC_TypeDef *) ITC_BaseAddress)
+ #define CFG ((CFG_TypeDef *) CFG_BaseAddress)
+ #define DM ((DM_TypeDef *) DM_BaseAddress)
+ #define COMP ((COMP_TypeDef *) COMP_BaseAddress)
+ #define OPT ((OPT_TypeDef *) OPT_BaseAddress)
+ 
+ 
+ 
+ #ifdef USE_STDPERIPH_DRIVER
+  #include "stm8l10x_conf.h"
+ #endif
+ 
+ /* Exported macro --------------------------------------------------------------*/
+ 
+ /*============================== Interrupts ====================================*/
+ #ifdef _RAISONANCE_
+  #include <intrins.h>
+  #define enableInterrupts()  _rim_()  /*!< Enable interrupts */
+  #define disableInterrupts() _sim_()  /*!< Disable interrupts */
+  #define rim()               _rim_()  /*!< Enable interrupts */
+  #define sim()               _sim_()  /*!< Disable interrupts */
+  #define nop()               _nop_()  /*!< No Operation */
+  #define trap()              _trap_() /*!< Trap (soft IT) */
+  #define wfi()               _wfi_()  /*!< Wait For Interrupt */
+  #define wfe()               _wfe_()  /*!< Wait For Interrupt */
+  #define halt()              _halt_() /*!< Halt */
+ #elif defined(_COSMIC_)
+  #define enableInterrupts()  {_asm("rim\n");}  /*!< Enable interrupts */
+  #define disableInterrupts() {_asm("sim\n");}  /*!< Disable interrupts */
+  #define rim()               {_asm("rim\n");}  /*!< Enable interrupts */
+  #define sim()               {_asm("sim\n");}  /*!< Disable interrupts */
+  #define nop()               {_asm("nop\n");}  /*!< No Operation */
+  #define trap()              {_asm("trap\n");} /*!< Trap (soft IT) */
+  #define wfi()               {_asm("wfi\n");}  /*!< Wait For Interrupt */
+  #define wfe()               {_asm("wfe\n");}  /*!< Wait for event */
+  #define halt()              {_asm("halt\n");} /*!< Halt */
+ #elif defined(_SDCC_)                    /* SDCC patch: standard inline asm macros */
+  #define enableInterrupts()    __asm__("rim")    /* enable interrupts */
+  #define disableInterrupts()   __asm__("sim")    /* disable interrupts */
+  #define rim()                 __asm__("rim")    /* enable interrupts */
+  #define sim()                 __asm__("sim")    /* disable interrupts */
+  #define nop()                 __asm__("nop")    /* no operation */
+  #define trap()                __asm__("trap")   /* trap (soft IT) */
+  #define wfi()                 __asm__("wfi")    /* wait for interrupt */
+  #define wfe()                 __asm__("wfe")    /* wait for event */
+  #define halt()                __asm__("halt")   /* halt CPU */
+ #else /* _IAR */
+  #include <intrinsics.h>
+  #define enableInterrupts()  __enable_interrupt()   /*!< Enable interrupts */
+  #define disableInterrupts() __disable_interrupt()  /*!< Disable interrupts */
+  #define rim()               __enable_interrupt()   /*!< Enable interrupts */
+  #define sim()               __disable_interrupt()  /*!< Disable interrupts */
+  #define nop()               __no_operation()       /*!< No Operation */
+  #define trap()              __trap()               /*!< Trap (soft IT) */
+  #define wfi()               __wait_for_interrupt() /*!< Wait For Interrupt */
+  #define wfe()               __wait_for_event();    /*!< Wait for event */
+  #define halt()              __halt()               /*!< Halt */
+ #endif /* _RAISONANCE_ */
+ 
+ /*============================== Interrupt vector Handling ========================*/
+ 
+ #ifdef _COSMIC_
+ #define INTERRUPT_HANDLER(a,b) @far @interrupt void a(void)
+ #define INTERRUPT_HANDLER_TRAP(a) void @far @interrupt a(void)
+ #endif
+ 
+ #ifdef _RAISONANCE_
+ #define INTERRUPT_HANDLER(a,b) void a(void) interrupt b
+ #define INTERRUPT_HANDLER_TRAP(a) void a(void) trap
+ #endif
+ 
+ #ifdef _IAR_
+ #define STRINGVECTOR(x) #x
+ #define VECTOR_ID(x) STRINGVECTOR( vector = (x) )
+ #define INTERRUPT_HANDLER( a, b )  \
+   _Pragma( VECTOR_ID( (b)+2 ) )        \
+   __interrupt void (a)( void )
+ #define INTERRUPT_HANDLER_TRAP(a) \
+   _Pragma( VECTOR_ID( 1 ) ) \
+   __interrupt void (a) (void)
+ #endif
+ 
+ /* SDCC patch: declare ISR handlers */
+ #ifdef _SDCC_
+  #define INTERRUPT_HANDLER(a,b) void a() __interrupt(b)
+ 
+  /* traps require >=v3.4.3 */
+  #if SDCC_VERSION >= 30403
+    #define INTERRUPT_HANDLER_TRAP(a) void a() __trap 
+  #else
+    #error traps require SDCC >=3.4.3. Please update!
+  #endif 
+ 
+ #endif /* _SDCC_ */
+ 
+ /*============================== Interrupt Handler declaration ========================*/
+ 
+ #ifdef _COSMIC_
+ #define INTERRUPT @far @interrupt
+ #endif
+ 
+ #ifdef _IAR_
+ #define INTERRUPT __interrupt
+ #endif
+ 
+ #if defined(_SDCC_)                      /* SDCC patch: doesn't work like that in SDCC -> skip */
+   #define INTERRUPT __interrupt
+   //#include "stm8l10x_it.h"               /* must be included in main.c! */
+ #endif
+ 
+ /*============================== Handling bits ====================================*/
+ /*-----------------------------------------------------------------------------
+ Method : I
+ Description : Handle the bit from the character variables.
+ Comments :    The different parameters of commands are
+               - VAR : Name of the character variable where the bit is located.
+               - Place : Bit position in the variable (7 6 5 4 3 2 1 0)
+               - Value : Can be 0 (reset bit) or not 0 (set bit)
+               The "MskBit" command allows to select some bits in a source
+               variables and copy it in a destination var (return the value).
+               The "ValBit" command returns the value of a bit in a char
+               variable: the bit is reseted if it returns 0 else the bit is set.
+               This method generates not an optimised code yet.
+ -----------------------------------------------------------------------------*/
+ #define SetBit(VAR,Place)         ( (VAR) |= (uint8_t)((uint8_t)1<<(uint8_t)(Place)) )
+ #define ClrBit(VAR,Place)         ( (VAR) &= (uint8_t)((uint8_t)((uint8_t)1<<(uint8_t)(Place))^(uint8_t)0xFF) )
+ 
+ #define ChgBit(VAR,Place)         ( (VAR) ^= (uint8_t)((uint8_t)1<<(uint8_t)(Place)) )
+ #define AffBit(VAR,Place,Value)   ((Value) ? \
+                                    ((VAR) |= ((uint8_t)1<<(Place))) : \
+                                    ((VAR) &= (((uint8_t)1<<(Place))^(uint8_t)0xFF)))
+ #define MskBit(Dest,Msk,Src)      ( (Dest) = ((Msk) & (Src)) | ((~(Msk)) & (Dest)) )
+ 
+ #define ValBit(VAR,Place)         ((uint8_t)(VAR) & (uint8_t)((uint8_t)1<<(uint8_t)(Place)))
+ 
+ #define BYTE_0(n)                 ((uint8_t)((n) & (uint8_t)0xFF))        /*!< Returns the low byte of the 32-bit value */
+ #define BYTE_1(n)                 ((uint8_t)(BYTE_0((n) >> (uint8_t)8)))  /*!< Returns the second byte of the 32-bit value */
+ #define BYTE_2(n)                 ((uint8_t)(BYTE_0((n) >> (uint8_t)16))) /*!< Returns the third byte of the 32-bit value */
+ #define BYTE_3(n)                 ((uint8_t)(BYTE_0((n) >> (uint8_t)24))) /*!< Returns the high byte of the 32-bit value */
+ 
+ /*============================== Assert Macros ====================================*/
+ #define IS_STATE_VALUE(STATE) \
+   (((STATE) == SET) || \
+    ((STATE) == RESET))
+ 
+ /*-----------------------------------------------------------------------------
+ Method : II
+ Description : Handle directly the bit.
+ Comments :    The idea is to handle directly with the bit name. For that, it is
+               necessary to have RAM area descriptions (example: HW register...)
+               and the following command line for each area.
+               This method generates the most optimized code.
+ -----------------------------------------------------------------------------*/
+ 
+ #define AREA 0x00     /* The area of bits begins at address 0x10. */
+ 
+ #define BitClr(BIT)  ( *((unsigned char *) (AREA+(BIT)/8)) &= (~(1<<(7-(BIT)%8))) )
+ #define BitSet(BIT)  ( *((unsigned char *) (AREA+(BIT)/8)) |= (1<<(7-(BIT)%8)) )
+ #define BitVal(BIT)  ( *((unsigned char *) (AREA+(BIT)/8)) & (1<<(7-(BIT)%8)) )
+ 
+ 
+ #endif /* __STM8L10x_H */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_i2c.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_i2c.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_i2c.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_i2c.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,628 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_i2c.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions prototypes for the I2C firmware 
+   *          library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_I2C_H
+ #define __STM8L10x_I2C_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /** @defgroup I2C_Exported_Types
+  * @{
+  */
+ 
+ /** @defgroup I2C_duty_cycle_in_fast_mode
+   * @{
+   */
+ typedef enum
+ {
+   I2C_DutyCycle_2    = (uint8_t)0x00,  /*!< Fast mode Tlow/THigh = 2 */
+   I2C_DutyCycle_16_9 = (uint8_t)0x40   /*!< Fast mode Tlow/Thigh = 16/9 */
+ } I2C_DutyCycle_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /** @defgroup I2C_acknowledgement
+   * @{
+   */
+ typedef enum
+ {
+   I2C_Ack_Disable = (uint8_t)0x00,  /*!< No acknowledge */
+   I2C_Ack_Enable  = (uint8_t)0x04   /*!< Acknowledge Enabled */
+ } I2C_Ack_TypeDef;
+ /**
+   * @}
+   */
+ 
+ /** @defgroup  I2C_Position_Acknowledgement
+   * @{
+   */
+ typedef enum
+ {
+   I2C_AckPosition_Current = (uint8_t)0x00,   /*!< Acknowledge on the current byte */
+   I2C_AckPosition_Next    = (uint8_t)0x08    /*!< Acknowledge on the next byte */
+ } I2C_AckPosition_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /** @defgroup I2C_acknowledged_address
+   * @{
+   */
+ typedef enum
+ {
+   I2C_AcknowledgedAddress_7bit  = (uint8_t)0x00,  /*!< 7-bit slave address (10-bit address not acknowledged) */
+   I2C_AcknowledgedAddress_10bit = (uint8_t)0x80   /*!< 10-bit slave address (7-bit address not acknowledged) */
+ } I2C_AcknowledgedAddress_TypeDef;
+ /**
+   * @}
+   */
+ 
+ /** @defgroup I2C_transfer_direction
+   * @{
+   */
+ 
+ /**
+   * Warning: the values correspond to the ADD0 bit position in the OARL register
+   */
+ typedef enum
+ {
+   I2C_Direction_Transmitter = (uint8_t)0x00,  /*!< Transmission direction */
+   I2C_Direction_Receiver    = (uint8_t)0x01   /*!< Reception direction */
+ } I2C_Direction_TypeDef;
+ /**
+   * @}
+   */
+ 
+ /** @defgroup I2C_flags_definition
+   * @{
+   */
+ /**
+   * @brief Elements values convention: 0xXXYY
+   *  X = SRx registers index
+   *      X = 1 : SR1
+   *      X = 2 : SR2
+   *      X = 3 : SR3
+   *  Y = Flag mask in the register
+   */
+ typedef enum
+ {
+   /* SR1 register flags */
+   I2C_FLAG_TXE      = (uint16_t)0x0180,  /*!< Transmit Data Register Empty flag */
+   I2C_FLAG_RXNE     = (uint16_t)0x0140,  /*!< Read Data Register Not Empty flag */
+   I2C_FLAG_STOPF    = (uint16_t)0x0110,  /*!< Stop detected flag */
+   I2C_FLAG_ADD10    = (uint16_t)0x0108,  /*!< 10-bit Header sent flag */
+   I2C_FLAG_BTF      = (uint16_t)0x0104,  /*!< Data Byte Transfer Finished flag */
+   I2C_FLAG_ADDR     = (uint16_t)0x0102,  /*!< Address Sent/Matched (master/slave) flag */
+   I2C_FLAG_SB       = (uint16_t)0x0101,  /*!< Start bit sent flag */
+ 
+   /* SR2 register flags */
+   I2C_FLAG_WUFH     = (uint16_t)0x0220,  /*!< Wake Up From Halt Flag */
+   I2C_FLAG_OVR      = (uint16_t)0x0208,  /*!< Overrun/Underrun flag */
+   I2C_FLAG_AF       = (uint16_t)0x0204,  /*!< Acknowledge Failure Flag */
+   I2C_FLAG_ARLO     = (uint16_t)0x0202,  /*!< Arbitration Loss Flag */
+   I2C_FLAG_BERR     = (uint16_t)0x0201,  /*!< Misplaced Start or Stop condition */
+ 
+   /* SR3 register flags */
+   I2C_FLAG_GENCALL  = (uint16_t)0x0310,  /*!< General Call header received Flag */
+   I2C_FLAG_TRA      = (uint16_t)0x0304,  /*!< Transmitter Receiver Flag */
+   I2C_FLAG_BUSY     = (uint16_t)0x0302,  /*!< Bus Busy Flag */
+   I2C_FLAG_MSL      = (uint16_t)0x0301   /*!< Master Slave Flag */
+ } I2C_FLAG_TypeDef;
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ /** @defgroup I2C_interrupts_definition
+   * @{
+   */
+ 
+ /**
+   * @brief I2C Pending bits
+   * Elements values convention: 0xXYZZ
+   *  X = SRx registers index
+   *      X = 0 : ITR
+   *      X = 1 : SR1
+   *      X = 2 : SR2
+   *  Y = Position of the corresponding Interrupt
+   *  ZZ = flag mask in the dedicated register(X register)
+   */
+ 
+ typedef enum
+ {
+   I2C_IT_ERR             = (uint16_t)0x0001,  /*!< Error Interruption */
+   I2C_IT_EVT             = (uint16_t)0x0002,  /*!< Event Interruption */
+   I2C_IT_BUF             = (uint16_t)0x0004,  /*!< Buffer Interruption */
+   /* SR1 register */
+   I2C_IT_TXE             = (uint16_t)0x1680,  /*!< Transmit Data Register Empty  */
+   I2C_IT_RXNE            = (uint16_t)0x1640,  /*!< Read Data Register Not Empty  */
+   I2C_IT_STOPF           = (uint16_t)0x1210,  /*!< Stop detected  */
+   I2C_IT_ADD10           = (uint16_t)0x1208,  /*!< 10-bit Header sent */
+   I2C_IT_BTF             = (uint16_t)0x1204,  /*!< Data Byte Transfer Finished  */
+   I2C_IT_ADDR            = (uint16_t)0x1202,  /*!< Address Sent/Matched (master/slave)  */
+   I2C_IT_SB              = (uint16_t)0x1201,  /*!< Start bit sent  */
+   /* SR2 register */
+   I2C_IT_WUFH            = (uint16_t)0x2220,  /*!< Wake Up From Halt  */
+   I2C_IT_OVR             = (uint16_t)0x2108,  /*!< Overrun/Underrun  */
+   I2C_IT_AF              = (uint16_t)0x2104,  /*!< Acknowledge Failure  */
+   I2C_IT_ARLO            = (uint16_t)0x2102,  /*!< Arbitration Loss  */
+   I2C_IT_BERR            = (uint16_t)0x2101   /*!< Misplaced Start or Stop condition */
+ } I2C_IT_TypeDef;
+ /**
+   * @}
+   */
+   
+ /** @defgroup I2C_Events
+   * @{
+   */
+ 
+ /**
+   * @brief I2C possible events
+   * Values convention: 0xXXYY
+   * XX = Event SR3 corresponding value
+   * YY = Event SR1 corresponding value
+   * @note if Event = EV3_2 the rule above does not apply
+   * YY = Event SR2 corresponding value
+   */
+ typedef enum
+ {
+   /**
+  ===============================================================================
+                I2C Master Events (Events grouped in order of communication)                   
+  ===============================================================================  
+  */
+ /**
+   * @brief  Communication start
+   *
+   * After sending the START condition (I2C_GenerateSTART() function) the master
+   * has to wait for this event. It means that the Start condition has been correctly
+   * released on the I2C bus (the bus is free, no other devices is communicating).
+   *
+   */
+   /* --EV5 */
+   I2C_EVENT_MASTER_MODE_SELECT               = (uint16_t)0x0301,  /*!< BUSY, MSL and SB flag */
+ 
+ /**
+   * @brief  Address Acknowledge
+   *
+   * After checking on EV5 (start condition correctly released on the bus), the
+   * master sends the address of the slave(s) with which it will communicate
+   * (I2C_Send7bitAddress() function, it also determines the direction of the communication:
+   * Master transmitter or Receiver).
+   * Then the master has to wait that a slave acknowledges his address.
+   * If an acknowledge is sent on the bus, one of the following events will
+   * be set:
+   *
+   *  1) In case of Master Receiver (7-bit addressing):
+   *  the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED event is set.
+   *
+   *  2) In case of Master Transmitter (7-bit addressing):
+   *  the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED is set
+   *
+   *  3) In case of 10-Bit addressing mode, the master (just after generating the START
+   *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData()
+   *  function).
+   *  Then master should wait on EV9. It means that the 10-bit addressing
+   *  header has been correctly sent on the bus.
+   *  Then master should send the second part of the 10-bit address (LSB) using
+   *  the function I2C_Send7bitAddress(). Then master should wait for event EV6.
+   *
+   */
+   /* --EV6 */
+   I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED = (uint16_t)0x0782,  /*!< BUSY, MSL, ADDR, TXE and TRA flags */
+   I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED    = (uint16_t)0x0302,  /*!< BUSY, MSL and ADDR flags */
+   /* --EV9 */
+   I2C_EVENT_MASTER_MODE_ADDRESS10            = (uint16_t)0x0308,  /*!< BUSY, MSL and ADD10 flags */
+ 
+ /**
+   * @brief Communication events
+   *
+   * If a communication is established (START condition generated and slave address
+   * acknowledged) then the master has to check on one of the following events for
+   * communication procedures:
+   *
+   * 1) Master Receiver mode: The master has to wait on the event EV7 then to read
+   *    the data received from the slave (I2C_ReceiveData() function).
+   *
+   * 2) Master Transmitter mode: The master has to send data (I2C_SendData()
+   *    function) then to wait on event EV8 or EV8_2.
+   *    These two events are similar:
+   *     - EV8 means that the data has been written in the data register and is
+   *       being shifted out.
+   *     - EV8_2 means that the data has been physically shifted out and output
+   *       on the bus.
+   *     In most cases, using EV8 is sufficient for the application.
+   *     Using EV8_2 leads to a slower communication but ensure more reliable test.
+   *     EV8_2 is also more suitable than EV8 for testing on the last data transmission
+   *     (before Stop condition generation).
+   *
+   *  @note In case the user software does not guarantee that this event EV7 is
+   *  managed before the current byte end of transfer, then user may check on EV7
+   *  and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
+   *  In this case the communication may be slower.
+   *
+   */
+   /* Master RECEIVER mode -----------------------------*/
+   /* --EV7 */
+   I2C_EVENT_MASTER_BYTE_RECEIVED             = (uint16_t)0x0340,  /*!< BUSY, MSL and RXNE flags */
+ 
+   /* Master TRANSMITTER mode --------------------------*/
+   /* --EV8 */
+   I2C_EVENT_MASTER_BYTE_TRANSMITTING         = (uint16_t)0x0780,  /*!< TRA, BUSY, MSL, TXE flags */
+   /* --EV8_2 */
+   I2C_EVENT_MASTER_BYTE_TRANSMITTED          = (uint16_t)0x0784,  /*!< TRA, BUSY, MSL, TXE and BTF flags */
+ 
+ /**
+  ===============================================================================
+                I2C Slave Events (Events grouped in order of communication)                  
+  ===============================================================================  
+  */
+  
+ /**
+   * @brief  Communication start events
+   *
+   * Wait on one of these events at the start of the communication. It means that
+   * the I2C peripheral detected a Start condition on the bus (generated by master
+   * device) followed by the peripheral address.
+   * The peripheral generates an ACK condition on the bus (if the acknowledge
+   * feature is enabled through function I2C_AcknowledgeConfig()) and the events
+   * listed above are set :
+   *
+   * 1) In normal case (only one address managed by the slave), when the address
+   *   sent by the master matches the own address of the peripheral (configured by
+   *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set
+   *   (where XXX could be TRANSMITTER or RECEIVER).
+   *
+   * 2) In case the address sent by the master is General Call (address 0x00) and 
+   *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd()) 
+   *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.  
+   * 
+   */
+ 
+   /* --EV1  (all the events below are variants of EV1) */
+   /* 1) Case of One Single Address managed by the slave */
+   I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED    = (uint16_t)0x0202,  /*!< BUSY and ADDR flags */
+   I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED = (uint16_t)0x0682,  /*!< TRA, BUSY, TXE and ADDR flags */
+ 
+   /* 2) Case of General Call enabled for the slave */
+   I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED  = (uint16_t)0x1200,  /*!< EV2: GENCALL and BUSY flags */
+ 
+   /**
+     * @brief  Communication events
+     *
+     * Wait on one of these events when EV1 has already been checked :
+     *
+     * - Slave RECEIVER mode:
+     *     - EV2: When the application is expecting a data byte to be received.
+     *     - EV4: When the application is expecting the end of the communication:
+     *       master sends a stop condition and data transmission is stopped.
+     *
+     * - Slave Transmitter mode:
+     *    - EV3: When a byte has been transmitted by the slave and the application
+     *      is expecting the end of the byte transmission.
+     *      The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and I2C_EVENT_SLAVE_BYTE_TRANSMITTING
+     *      are similar. The second one can optionally be used when the user software
+     *      doesn't guarantee the EV3 is managed before the current byte end of transfer.
+     *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission
+     *      shall end (before sending the STOP condition).
+     *      In this case slave has to stop sending data bytes and expect a Stop
+     *      condition on the bus.
+     *
+     *  @note In case the  user software does not guarantee that the event EV2 is
+     *  managed before the current byte end of transfer, then user may check on EV2
+     *  and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
+     *  In this case the communication may be slower.
+     *
+     */
+   /* Slave RECEIVER mode --------------------------*/
+   /* --EV2 */
+   I2C_EVENT_SLAVE_BYTE_RECEIVED              = (uint16_t)0x0240,  /*!< BUSY and RXNE flags */
+   /* --EV4  */
+   I2C_EVENT_SLAVE_STOP_DETECTED              = (uint16_t)0x0010,  /*!< STOPF flag */
+ 
+   /* Slave TRANSMITTER mode -----------------------*/
+   /* --EV3 */
+   I2C_EVENT_SLAVE_BYTE_TRANSMITTED           = (uint16_t)0x0684,  /*!< TRA, BUSY, TXE and BTF flags */
+   I2C_EVENT_SLAVE_BYTE_TRANSMITTING          = (uint16_t)0x0680,  /*!< TRA, BUSY and TXE flags */
+   /* --EV3_2 */
+   I2C_EVENT_SLAVE_ACK_FAILURE                = (uint16_t)0x0004  /*!< AF flag */
+ } I2C_Event_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ /* Exported constants --------------------------------------------------------*/
+ /** @defgroup I2C_Exported_Constants
+   * @{
+   */
+ #define I2C_MAX_STANDARD_FREQ ((uint32_t)100000)
+ #define I2C_MAX_FAST_FREQ     ((uint32_t)400000)
+ #define I2C_MAX_INPUT_FREQ    ((uint8_t)16)
+ 
+ /**
+   *@}
+   */
+ 
+ /* Exported macro -----------------------------------------------------------*/
+ /** @defgroup I2C_Exported_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C duty cycles.
+   */
+ #define IS_I2C_DUTY_CYCLE(CYCLE)(((CYCLE) == I2C_DutyCycle_2) || \
+                                  ((CYCLE) == I2C_DutyCycle_16_9))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different acknowledgement configuration
+   */
+ #define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Disable) || \
+                                  ((STATE) == I2C_Ack_Enable))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different acknowledgement position
+   */
+ #define IS_I2C_ACK_POSITION(POSITION) (((POSITION) == I2C_AckPosition_Next) || \
+                                        ((POSITION) == I2C_AckPosition_Current))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C addressing modes.
+   */
+ #define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDMODE) (((ADDMODE) == I2C_AcknowledgedAddress_7bit) || \
+     ((ADDMODE) == I2C_AcknowledgedAddress_10bit))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C communication direction.
+   */
+ #define IS_I2C_DIRECTION(DIR)(((DIR) == I2C_Direction_Transmitter) || \
+                               ((DIR) == I2C_Direction_Receiver ))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C flags.
+   */
+ #define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_TXE)    || ((FLAG) == I2C_FLAG_RXNE) || \
+                                ((FLAG) == I2C_FLAG_STOPF)  || ((FLAG) == I2C_FLAG_ADD10)|| \
+                                ((FLAG) == I2C_FLAG_BTF)    || ((FLAG) == I2C_FLAG_ADDR) || \
+                                ((FLAG) == I2C_FLAG_SB)     || ((FLAG) == I2C_FLAG_WUFH) || \
+                                ((FLAG) == I2C_FLAG_OVR)    || ((FLAG) == I2C_FLAG_AF)   || \
+                                ((FLAG) == I2C_FLAG_ARLO)   || ((FLAG) == I2C_FLAG_BERR) || \
+                                ((FLAG) == I2C_FLAG_GENCALL)|| ((FLAG) == I2C_FLAG_TRA)  || \
+                                ((FLAG) == I2C_FLAG_BUSY)   || ((FLAG) == I2C_FLAG_MSL))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the I2C flags to clear.
+   */
+ #define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xDDE0) == (uint16_t)0x00) && ((FLAG) != (uint16_t)0x00))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values for the Interrupts
+   */
+ #define IS_I2C_CONFIG_IT(IT) ((((uint16_t)(IT) & (uint16_t)0xFFF8) == 0x00) && ((uint16_t)(IT) != 0x00))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C possible pending bits to clear by writing 0.
+   */
+ #define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0xDCD0) == 0x00) && ((IT) != (uint16_t)0x00))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C possible pending bits.
+   */
+ #define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_OVR)   || ((IT) == I2C_IT_AF)    || \
+                            ((IT) == I2C_IT_ARLO)  || ((IT) == I2C_IT_BERR)  || \
+                            ((IT) == I2C_IT_TXE)   || ((IT) == I2C_IT_RXNE)  || \
+                            ((IT) == I2C_IT_STOPF) || ((IT) == I2C_IT_ADD10) || \
+                            ((IT) == I2C_IT_BTF)   || ((IT) == I2C_IT_ADDR)  || \
+                            ((IT) == I2C_IT_SB)    || ((IT) == I2C_IT_WUFH ))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C possible events.
+   */
+ #define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
+                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
+                              ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
+                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
+                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | (uint16_t)I2C_FLAG_GENCALL)) || \
+                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
+                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | (uint16_t)I2C_FLAG_GENCALL)) || \
+                              ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE) || \
+                              ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
+                              ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
+                              ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
+                              ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
+                              ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
+                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
+                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
+                              ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10))
+ 
+ /**
+   * @brief  Macro used by the assert function to check the different I2C possible own address.
+   */
+ #define IS_I2C_OWN_ADDRESS(ADDRESS) ((ADDRESS) <= (uint16_t)0x03FF)
+ 
+ /* The address must be even */
+ #define IS_I2C_ADDRESS(ADD) (((ADD) & (uint8_t)0x01) == (uint8_t)0x00)
+ 
+ /**
+   * @brief  Macro used by the assert function to check that I2C Output clock frequency must be between 1Hz and 400kHz.
+   */
+ #define IS_I2C_OUTPUT_CLOCK_FREQ(FREQ) (((FREQ) >= (uint8_t)1) && ((FREQ) <= I2C_MAX_FAST_FREQ))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ 
+ /*  Function used to set the I2C configuration to the default reset state *****/
+ void I2C_DeInit(void);
+ 
+ /* Initialization and Configuration functions *********************************/
+ void I2C_Init(uint32_t OutputClockFrequency, uint16_t OwnAddress,
+               I2C_DutyCycle_TypeDef I2C_DutyCycle, I2C_Ack_TypeDef I2C_Ack,
+               I2C_AcknowledgedAddress_TypeDef I2C_AcknowledgedAddress);
+ void I2C_Cmd(FunctionalState NewState);
+ void I2C_GeneralCallCmd(FunctionalState NewState);
+ void I2C_SoftwareResetCmd(FunctionalState NewState);
+ void I2C_StretchClockCmd(FunctionalState NewState);
+ void I2C_GenerateSTART(FunctionalState NewState);
+ void I2C_GenerateSTOP(FunctionalState NewState);
+ void I2C_AcknowledgeConfig(FunctionalState NewState);
+ void I2C_AckPositionConfig(I2C_AckPosition_TypeDef I2C_AckPosition);
+ void I2C_FastModeDutyCycleConfig(I2C_DutyCycle_TypeDef I2C_DutyCycle);
+ void I2C_Send7bitAddress(uint8_t Address, I2C_Direction_TypeDef I2C_Direction);
+ 
+ /* Data transfers functions ***************************************************/ 
+ void I2C_SendData(uint8_t Data);
+ uint8_t I2C_ReceiveData(void);
+ 
+ /* Interrupts, events and flags management functions **************************/
+ void I2C_ITConfig(I2C_IT_TypeDef I2C_IT, FunctionalState NewState);
+ 
+ /**
+  * @brief
+  *  
+ @verbatim 
+ ================================================================================
+                        I2C State Monitoring Functions
+ ================================================================================
+  This I2C driver provides three different ways for I2C state monitoring
+   depending on the application requirements and constraints:
+ 
+ 
+  1) Basic state monitoring:
+     Using I2C_CheckEvent() function:
+     It compares the status registers (SR1, SR2 and SR3) content to a given event
+     (can be the combination of one or more flags).
+     It returns SUCCESS if the current status includes the given flags
+     and returns ERROR if one or more flags are missing in the current status.
+     - When to use:
+       - This function is suitable for most applications as well as for startup
+       activity since the events are fully described in the product reference manual
+       (RM0013).
+       - It is also suitable for users who need to define their own events.
+     - Limitations:
+       - If an error occurs (ie. error flags are set besides to the monitored flags),
+         the I2C_CheckEvent() function may return SUCCESS despite the communication
+         hold or corrupted real state.
+         In this case, it is advised to use error interrupts to monitor the error
+         events and handle them in the interrupt IRQ handler.
+ 
+         @note
+         For error management, it is advised to use the following functions:
+           - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
+           - I2C_IRQHandler() which is called when the I2C interrupts occur.
+           - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into the
+            I2C_IRQHandler() function in order to determine which error occurred.
+           - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
+             and/or I2C_GenerateStop() in order to clear the error flag and
+             source and return to correct communication status.
+ 
+ 
+   2) Advanced state monitoring:
+      Using the function I2C_GetLastEvent() which returns the image of both SR1
+      & SR3 status registers in a single word (uint16_t) (Status Register 3 value
+      is shifted left by 8 bits and concatenated to Status Register 1).
+      - When to use:
+        - This function is suitable for the same applications above but it allows to
+          overcome the limitations of I2C_GetFlagStatus() function (see below).
+          The returned value could be compared to events already defined in the
+          library (stm8l10x_i2c.h) or to custom values defined by user.
+        - This function is suitable when multiple flags are monitored at the same time.
+        - At the opposite of I2C_CheckEvent() function, this function allows user to
+          choose when an event is accepted (when all events flags are set and no
+          other flags are set or just when the needed flags are set like
+          I2C_CheckEvent() function).
+      - Limitations:
+        - User may need to define his own events.
+        - Same remark concerning the error management is applicable for this
+          function if user decides to check only regular communication flags (and
+          ignores error flags).
+ 
+ 
+  3) Flag-based state monitoring:
+      Using the function I2C_GetFlagStatus() which simply returns the status of
+      one single flag (ie. I2C_FLAG_RXNE ...).
+      - When to use:
+         - This function could be used for specific applications or in debug phase.
+         - It is suitable when only one flag checking is needed (most I2C events
+           are monitored through multiple flags).
+      - Limitations:
+         - When calling this function, the Status register is accessed. Some flags are
+           cleared when the status register is accessed. So checking the status
+           of one Flag, may clear other ones.
+         - Function may need to be called twice or more in order to monitor one
+           single event.
+           
+           
+ @endverbatim
+  *            
+  */
+ 
+ /**
+  ===============================================================================
+                           1. Basic state monitoring                    
+  ===============================================================================
+ */  
+ ErrorStatus I2C_CheckEvent(I2C_Event_TypeDef I2C_Event);
+ /**
+  ===============================================================================
+                           2. Advanced state monitoring                   
+  ===============================================================================  
+  */
+ I2C_Event_TypeDef I2C_GetLastEvent(void);
+ /**
+  ===============================================================================
+                           3. Flag-based state monitoring                   
+  ===============================================================================  
+  */
+ FlagStatus I2C_GetFlagStatus(I2C_FLAG_TypeDef I2C_FLAG);
+ void I2C_ClearFlag(I2C_FLAG_TypeDef I2C_FLAG);
+ ITStatus I2C_GetITStatus(I2C_IT_TypeDef I2C_IT);
+ void I2C_ClearITPendingBit(I2C_IT_TypeDef I2C_IT);
+ 
+ 
+ 
+ #endif /* __STM8L10x_I2C_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_irtim.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_irtim.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_irtim.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_irtim.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,58 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_irtim.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototype and macros for the IRTIM
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IRTIM_H
+ #define __STM8L10x_IRTIM_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ /* Exported functions --------------------------------------------------------*/
+ /** @addtogroup IRTIM_Exported_Functions
+   * @{
+   */
+ 
+ void IRTIM_DeInit(void);
+ void IRTIM_Cmd(FunctionalState NewState);
+ FunctionalState IRTIM_GetStatus(void);
+ void IRTIM_HighSinkODCmd(FunctionalState Newstate);
+ FunctionalState IRTIM_GetHighSinkODStatus(void);
+ 
+ 
+ /**
+   * @}
+   */
+ #endif /* __STM8L10x_IRTIM_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_itc.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_itc.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_itc.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_itc.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,166 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_itc.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the ITC 
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_ITC_H
+ #define __STM8L10X_ITC_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup ITC_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief ITC Interrupt Lines selection
+   */
+ typedef enum {
+   FLASH_IRQn                    = (uint8_t)1,   /*!< Flash interrupt */
+   AWU_IRQn                      = (uint8_t)4,   /*!< Auto Wake-Up interrupt   */
+   EXTIB_IRQn                    = (uint8_t)6,   /*!< GPIOB interrupt */
+   EXTID_IRQn                    = (uint8_t)7,   /*!< GPIOD interrupt */
+   EXTI0_IRQn                    = (uint8_t)8,   /*!< PIN0 interrupt  */
+   EXTI1_IRQn                    = (uint8_t)9,   /*!< PIN1 interrupt  */
+   EXTI2_IRQn                    = (uint8_t)10,  /*!< PIN2 interrupt  */
+   EXTI3_IRQn                    = (uint8_t)11,  /*!< PIN3 interrupt  */
+   EXTI4_IRQn                    = (uint8_t)12,  /*!< PIN4 interrupt  */
+   EXTI5_IRQn                    = (uint8_t)13,  /*!< PIN5 interrupt  */
+   EXTI6_IRQn                    = (uint8_t)14,  /*!< PIN6 interrupt  */
+   EXTI7_IRQn                    = (uint8_t)15,  /*!< PIN7 interrupt  */
+   COMP_IRQn                     = (uint8_t)18,  /*!< Comparator interrupt */
+   TIM2_UPD_OVF_TRG_BRK_IRQn     = (uint8_t)19,  /*!< TIM2 UPD/OVF/TRG/BRK interrupt */
+   TIM2_CAP_IRQn                 = (uint8_t)20,  /*!< TIM2 CAP interrupt  */
+   TIM3_UPD_OVF_TRG_BRK_IRQn     = (uint8_t)21,  /*!< TIM3 overflow interrupt */
+   TIM3_CAP_IRQn                 = (uint8_t)22,  /*!< TIM3 input captute/output compare interrupt  */
+   TIM4_UPD_OVF_IRQn             = (uint8_t)25,  /*!< TIM4 overflow interrupt */
+   SPI_IRQn                      = (uint8_t)26,  /*!< SPI interrupt */
+   USART_TX_IRQn                 = (uint8_t)27,  /*!< USART TX interrupt */
+   USART_RX_IRQn                 = (uint8_t)28,  /*!< USART RX interrupt */
+   I2C_IRQn                      = (uint8_t)29   /*!< I2C RX interrupt */
+ }IRQn_TypeDef;
+ 
+ /**
+   * @brief ITC Priority Levels selection
+   */
+ typedef enum {
+   ITC_PriorityLevel_0 = (uint8_t)0x02, /*!< Software priority level 0 (cannot be written) */
+   ITC_PriorityLevel_1 = (uint8_t)0x01, /*!< Software priority level 1 */
+   ITC_PriorityLevel_2 = (uint8_t)0x00, /*!< Software priority level 2 */
+   ITC_PriorityLevel_3 = (uint8_t)0x03  /*!< Software priority level 3 */
+ } ITC_PriorityLevel_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /** @addtogroup ITC_Exported_Constants
+   * @{
+   */
+ 
+ #define CPU_SOFT_INT_DISABLED ((uint8_t)0x28) /*!< Mask for I1 and I0 bits in CPU_CC register */
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup ITC_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different IRQ values
+   */
+ #define IS_ITC_IRQ(IRQ) (((IRQ) == FLASH_IRQn) || \
+                          ((IRQ) == AWU_IRQn) || \
+                          ((IRQ) == EXTIB_IRQn) || \
+                          ((IRQ) == EXTID_IRQn) || \
+                          ((IRQ) == EXTI0_IRQn) || \
+                          ((IRQ) == EXTI1_IRQn) || \
+                          ((IRQ) == EXTI2_IRQn) || \
+                          ((IRQ) == EXTI3_IRQn) || \
+                          ((IRQ) == EXTI4_IRQn) || \
+                          ((IRQ) == EXTI5_IRQn) || \
+                          ((IRQ) == EXTI6_IRQn) || \
+                          ((IRQ) == EXTI7_IRQn) || \
+                          ((IRQ) == COMP_IRQn) || \
+                          ((IRQ) == TIM2_UPD_OVF_TRG_BRK_IRQn) || \
+                          ((IRQ) == TIM2_CAP_IRQn) || \
+                          ((IRQ) == TIM3_UPD_OVF_TRG_BRK_IRQn) || \
+                          ((IRQ) == TIM3_CAP_IRQn) || \
+                          ((IRQ) == TIM4_UPD_OVF_IRQn) || \
+                          ((IRQ) == SPI_IRQn) || \
+                          ((IRQ) == USART_TX_IRQn) || \
+                          ((IRQ) == USART_RX_IRQn) || \
+                          ((IRQ) == I2C_IRQn))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different priority values
+   */
+ #define IS_ITC_PRIORITY(PriorityLevel) \
+   (((PriorityLevel) == ITC_PriorityLevel_0) || \
+    ((PriorityLevel) == ITC_PriorityLevel_1) || \
+    ((PriorityLevel) == ITC_PriorityLevel_2) || \
+    ((PriorityLevel) == ITC_PriorityLevel_3))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check if the interrupts are disabled
+   */
+ #define IS_ITC_INTERRUPTS_DISABLED (ITC_GetSoftIntStatus() == CPU_SOFT_INT_DISABLED)
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ 
+ /** @addtogroup ITC_Exported_Functions
+   * @{
+   */
+ 
+ uint8_t ITC_GetCPUCC(void);
+ void ITC_DeInit(void);
+ uint8_t ITC_GetSoftIntStatus(void);
+ ITC_PriorityLevel_TypeDef ITC_GetSoftwarePriority(IRQn_TypeDef IRQn);
+ void ITC_SetSoftwarePriority(IRQn_TypeDef IRQn, ITC_PriorityLevel_TypeDef ITC_PriorityLevel);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_ITC_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_iwdg.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_iwdg.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_iwdg.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_iwdg.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,143 ----
+ /**
+   ********************************************************************************
+   * @file    stm8l10x_iwdg.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the IWDG
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_IWDG_H
+ #define __STM8L10X_IWDG_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /** @addtogroup IWDG_Exported_Constants
+   * @{
+   */
+ 
+ /**
+   * @brief Define used to prevent watchdog reset
+   */
+ #define IWDG_KEY_REFRESH    ((uint8_t)0xAA)  /*!<  This value written in the Key register prevent the watchdog reset */
+ 
+ /**
+   * @brief Define used to start the watchdog counter down
+   */
+ #define IWDG_KEY_ENABLE     ((uint8_t)0xCC)  /*!<  This value written in the Key register start the watchdog counting down*/
+ 
+ /**
+  * @}
+  */
+ 
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup IWDG_Exported_Types
+   * @{
+   */
+ 
+ /**
+   *@brief IWDG write  acces enumeration
+   */
+ typedef enum
+ {
+   IWDG_WriteAccess_Enable  = (uint8_t)0x55, /*!< Code 0x55 in Key register, allow write access to Prescaler and Reload registers */
+   IWDG_WriteAccess_Disable = (uint8_t)0x00  /*!< Code 0x00 in Key register, not allow write access to Prescaler and Reload registers */
+ } IWDG_WriteAccess_TypeDef;
+ 
+ 
+ /**
+   *@brief IWDG prescaler enumeration
+   */
+ typedef enum
+ {
+   IWDG_Prescaler_4   = (uint8_t)0x00, /*!< Used to set prescaler register to 4 */
+   IWDG_Prescaler_8   = (uint8_t)0x01, /*!< Used to set prescaler register to 8 */
+   IWDG_Prescaler_16  = (uint8_t)0x02, /*!< Used to set prescaler register to 16 */
+   IWDG_Prescaler_32  = (uint8_t)0x03, /*!< Used to set prescaler register to 32 */
+   IWDG_Prescaler_64  = (uint8_t)0x04, /*!< Used to set prescaler register to 64 */
+   IWDG_Prescaler_128 = (uint8_t)0x05, /*!< Used to set prescaler register to 128 */
+   IWDG_Prescaler_256 = (uint8_t)0x06  /*!< Used to set prescaler register to 256 */
+ } IWDG_Prescaler_TypeDef;
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup IWDG_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different
+   * values of the prescaler.
+   */
+ #define IS_IWDG_PRESCALER_VALUE(VALUE) \
+   (((VALUE) == IWDG_Prescaler_4)   || \
+    ((VALUE) == IWDG_Prescaler_8)   || \
+    ((VALUE) == IWDG_Prescaler_16)  || \
+    ((VALUE) == IWDG_Prescaler_32)  || \
+    ((VALUE) == IWDG_Prescaler_64)  || \
+    ((VALUE) == IWDG_Prescaler_128) || \
+    ((VALUE) == IWDG_Prescaler_256))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different
+   * values of the counter register.
+   */
+ #define IS_IWDG_WRITEACCESS_MODE(MODE) \
+   (((MODE) == IWDG_WriteAccess_Enable) || \
+    ((MODE) == IWDG_WriteAccess_Disable))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup IWDG_Exported_Functions
+   * @{
+   */
+ 
+ void IWDG_WriteAccessCmd(IWDG_WriteAccess_TypeDef IWDG_WriteAccess);
+ void IWDG_SetPrescaler(IWDG_Prescaler_TypeDef IWDG_Prescaler);
+ void IWDG_SetReload(uint8_t IWDG_Reload);
+ void IWDG_ReloadCounter(void);
+ void IWDG_Enable(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_IWDG_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_rst.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_rst.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_rst.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_rst.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,94 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_rst.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the RST 
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_RST_H
+ #define __STM8L10X_RST_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup RST_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief RST Flag possible values
+   */
+ typedef enum {
+   RST_FLAG_POR_PDR     = (uint8_t)0x01, /*!< POR/PDR reset flag */
+   RST_FLAG_SWIMF       = (uint8_t)0x08, /*!< SWIM reset flag */
+   RST_FLAG_ILLOPF      = (uint8_t)0x04, /*!< Illigal opcode reset flag */
+   RST_FLAG_IWDGF       = (uint8_t)0x02  /*!< Independent watchdog reset flag */
+ } RST_Flag_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup RST_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different RST flags.
+   */
+ #define IS_RST_FLAG(FLAG) \
+   (((FLAG) == RST_FLAG_POR_PDR) || \
+    ((FLAG) == RST_FLAG_IWDGF)   || \
+    ((FLAG) == RST_FLAG_ILLOPF)  || \
+    ((FLAG) == RST_FLAG_SWIMF))
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup RST_Exported_Functions
+   * @{
+   */
+ 
+ FlagStatus RST_GetFlagStatus(RST_Flag_TypeDef RST_Flag);
+ void RST_ClearFlag(RST_Flag_TypeDef RST_Flag);
+ void RST_GPOutputEnable(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_RST_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_spi.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_spi.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_spi.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_spi.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,278 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_spi.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the SPI 
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_SPI_H
+ #define __STM8L10X_SPI_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup SPI_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief SPI data direction mode
+   * Warning: element values correspond to BDM, BDOE, RXONLY bits position
+   */
+ typedef enum {
+   SPI_Direction_2Lines_FullDuplex = (uint8_t)0x00, /*!< 2-line uni-directional data mode enable */
+   SPI_Direction_2Lines_RxOnly     = (uint8_t)0x04, /*!< Receiver only in 2 line uni-directional data mode */
+   SPI_Direction_1Line_Rx          = (uint8_t)0x80, /*!< Receiver only in 1 line bi-directional data mode */
+   SPI_Direction_1Line_Tx          = (uint8_t)0xC0  /*!< Transmit only in 1 line bi-directional data mode */
+ } SPI_DirectionMode_TypeDef;
+ 
+ /**
+   * @brief SPI direction transmit/receive
+   */
+ 
+ typedef enum {
+   SPI_Direction_Rx = (uint8_t)0x00, /*!< Selects Rx receive direction in bi-directional mode */
+   SPI_Direction_Tx = (uint8_t)0x01  /*!< Selects Tx transmission direction in bi-directional mode */
+ } SPI_Direction_TypeDef;
+ 
+ /**
+   * @brief SPI master/slave mode
+   * Warning: element values correspond to MSTR bit position
+   */
+ typedef enum {
+   SPI_Mode_Master = (uint8_t)0x04, /*!< SPI Master configuration */
+   SPI_Mode_Slave  = (uint8_t)0x00  /*!< SPI Slave configuration */
+ } SPI_Mode_TypeDef;
+ 
+ /**
+   * @brief SPI Slave Select management
+   * Warning: element values correspond to LSBFIRST bit position
+   */
+ typedef enum
+ {
+   SPI_NSS_Soft  = (uint8_t)0x02, /*!< Software slave management disabled */
+   SPI_NSS_Hard  = (uint8_t)0x00  /*!< Software slave management enabled */
+ } SPI_NSS_TypeDef;
+ 
+ /**
+   * @brief SPI BaudRate Prescaler
+   * Warning: element values correspond to BR bits position
+   */
+ typedef enum {
+   SPI_BaudRatePrescaler_2   = (uint8_t)0x00, /*!< SPI frequency = frequency(CPU)/2 */
+   SPI_BaudRatePrescaler_4   = (uint8_t)0x08, /*!< SPI frequency = frequency(CPU)/4 */
+   SPI_BaudRatePrescaler_8   = (uint8_t)0x10, /*!< SPI frequency = frequency(CPU)/8 */
+   SPI_BaudRatePrescaler_16  = (uint8_t)0x18, /*!< SPI frequency = frequency(CPU)/16 */
+   SPI_BaudRatePrescaler_32  = (uint8_t)0x20, /*!< SPI frequency = frequency(CPU)/32 */
+   SPI_BaudRatePrescaler_64  = (uint8_t)0x28, /*!< SPI frequency = frequency(CPU)/64 */
+   SPI_BaudRatePrescaler_128 = (uint8_t)0x30, /*!< SPI frequency = frequency(CPU)/128 */
+   SPI_BaudRatePrescaler_256 = (uint8_t)0x38  /*!< SPI frequency = frequency(CPU)/256 */
+ } SPI_BaudRatePrescaler_TypeDef;
+ 
+ /**
+   * @brief SPI Clock Polarity
+   * Warning: element values correspond to CPOL bit position
+   */
+ typedef enum {
+   SPI_CPOL_Low  = (uint8_t)0x00, /*!< Clock to 0 when idle */
+   SPI_CPOL_High = (uint8_t)0x02  /*!< Clock to 1 when idle */
+ } SPI_CPOL_TypeDef;
+ 
+ /**
+   * @brief SPI Clock Phase
+   * Warning: element values correspond to CPHA bit position
+   */
+ typedef enum {
+   SPI_CPHA_1Edge = (uint8_t)0x00, /*!< The first clock transition is the first data capture edge */
+   SPI_CPHA_2Edge = (uint8_t)0x01  /*!< The second clock transition is the first data capture edge */
+ } SPI_CPHA_TypeDef;
+ 
+ /**
+   * @brief SPI Frame Format: MSB or LSB transmitted first
+   * Warning: element values correspond to LSBFIRST bit position
+   */
+ typedef enum {
+   SPI_FirstBit_MSB = (uint8_t)0x00, /*!< MSB bit will be transmitted first */
+   SPI_FirstBit_LSB = (uint8_t)0x80  /*!< LSB bit will be transmitted first */
+ } SPI_FirstBit_TypeDef;
+ 
+ /**
+   * @brief SPI flags definition - Warning : FLAG value = mapping position register
+   */
+ typedef enum {
+   SPI_FLAG_BSY    = (uint8_t)0x80, /*!< Busy flag */
+   SPI_FLAG_OVR    = (uint8_t)0x40, /*!< Overrun flag */
+   SPI_FLAG_MODF   = (uint8_t)0x20, /*!< Mode fault */
+   SPI_FLAG_WKUP   = (uint8_t)0x08, /*!< Wake-up flag */
+   SPI_FLAG_TXE    = (uint8_t)0x02, /*!< Transmit buffer empty */
+   SPI_FLAG_RXNE   = (uint8_t)0x01  /*!< Receive buffer empty */
+ } SPI_FLAG_TypeDef;
+ 
+ /**
+   * @brief SPI_IT possible values
+   * Elements values convention: 0xYX
+   *   X: Position of the corresponding Interrupt
+   *   Y: ITPENDINGBIT position
+   */
+ typedef enum
+ {
+   SPI_IT_WKUP   = (uint8_t)0x34,  /*!< Wake-up interrupt*/
+   SPI_IT_OVR    = (uint8_t)0x65,  /*!< Overrun interrupt*/
+   SPI_IT_MODF   = (uint8_t)0x55,  /*!< Mode fault interrupt*/
+   SPI_IT_TXE    = (uint8_t)0x17,  /*!< Transmit buffer empty interrupt*/
+   SPI_IT_RXNE   = (uint8_t)0x06,  /*!< Receive buffer not empty interrupt*/
+   SPI_IT_ERR    = (uint8_t)0x05   /*!< Error interrupt*/
+ } SPI_IT_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup SPI_Private_Macros
+   * @brief Macros used by the assert_param function to check the different functions parameters.
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the data direction mode values
+   */
+ #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
+                                      ((MODE) == SPI_Direction_2Lines_RxOnly) || \
+                                      ((MODE) == SPI_Direction_1Line_Rx) || \
+                                      ((MODE) == SPI_Direction_1Line_Tx))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the mode half duplex data direction values
+   */
+ #define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
+                                      ((DIRECTION) == SPI_Direction_Tx))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the SPI Mode values
+   */
+ #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
+                            ((MODE) == SPI_Mode_Slave))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the NSS management values
+   */
+ #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
+                          ((NSS) == SPI_NSS_Hard))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the baudrate values
+   */
+ #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
+     ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
+     ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
+     ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
+     ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
+     ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
+     ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
+     ((PRESCALER) == SPI_BaudRatePrescaler_256))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the polarity values
+   */
+ #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
+                            ((CPOL) == SPI_CPOL_High))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the phase values
+   */
+ #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
+                            ((CPHA) == SPI_CPHA_2Edge))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the first bit to be transmitted values
+   */
+ #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
+                                ((BIT) == SPI_FirstBit_LSB))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different flags values
+   */
+ #define IS_SPI_FLAG(FLAG) (((FLAG) == SPI_FLAG_OVR) || \
+                            ((FLAG) == SPI_FLAG_MODF) || \
+                            ((FLAG) == SPI_FLAG_WKUP) || \
+                            ((FLAG) == SPI_FLAG_TXE) || \
+                            ((FLAG) == SPI_FLAG_RXNE) || \
+                            ((FLAG) == SPI_FLAG_BSY))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values for the Interrupts
+   */
+ #define IS_SPI_CONFIG_IT(IT) (((IT) == SPI_IT_TXE)  || \
+                               ((IT) == SPI_IT_RXNE)  || \
+                               ((IT) == SPI_IT_ERR) || \
+                               ((IT) == SPI_IT_WKUP))
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values for the pending bit
+   */
+ #define IS_SPI_GET_IT(IT) (((IT) == SPI_IT_OVR)  || \
+                            ((IT) == SPI_IT_MODF) || \
+                            ((IT) == SPI_IT_WKUP) || \
+                            ((IT) == SPI_IT_TXE)  || \
+                            ((IT) == SPI_IT_RXNE))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup SPI_Exported_Functions
+   * @{
+   */
+ 
+ void SPI_DeInit(void);
+ void SPI_Init(SPI_FirstBit_TypeDef SPI_FirstBit, SPI_BaudRatePrescaler_TypeDef
+               SPI_BaudRatePrescaler, SPI_Mode_TypeDef SPI_Mode, SPI_CPOL_TypeDef
+               SPI_CPOL, SPI_CPHA_TypeDef SPI_CPHA, SPI_DirectionMode_TypeDef
+               SPI_DirectionMode, SPI_NSS_TypeDef SPI_NSS);
+ void SPI_Cmd(FunctionalState NewState);
+ void SPI_ITConfig(SPI_IT_TypeDef SPI_IT, FunctionalState NewState);
+ void SPI_NSSInternalSoftwareCmd(FunctionalState NewState);
+ void SPI_BiDirectionalLineConfig(SPI_Direction_TypeDef SPI_Direction);
+ void SPI_SendData(uint8_t Data);
+ uint8_t SPI_ReceiveData(void);
+ FlagStatus SPI_GetFlagStatus(SPI_FLAG_TypeDef SPI_FLAG);
+ ITStatus SPI_GetITStatus(SPI_IT_TypeDef SPI_IT);
+ void SPI_ClearFlag(void);
+ void SPI_ClearITPendingBit(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10x_SPI_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim2.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim2.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim2.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim2.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,746 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_tim2.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the TIM2
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_TIM2_H
+ #define __STM8L10X_TIM2_H
+ 
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup TIM2_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief TIM2 Forced Action
+   */
+ typedef enum
+ {
+   TIM2_ForcedAction_Active  = ((uint8_t)0x50),  /*!< Output Reference is forced low */
+   TIM2_ForcedAction_Inactive  = ((uint8_t)0x40)   /*!< Output Reference is forced high */
+ }
+ TIM2_ForcedAction_TypeDef;
+ 
+ /**
+   * @brief TIM2 Prescaler
+   */
+ typedef enum
+ {
+   TIM2_Prescaler_1  = ((uint8_t)0x00),  /*!< Time base Prescaler = 1 (No effect)*/
+   TIM2_Prescaler_2    = ((uint8_t)0x01),  /*!< Time base Prescaler = 2 */
+   TIM2_Prescaler_4    = ((uint8_t)0x02),  /*!< Time base Prescaler = 4 */
+   TIM2_Prescaler_8  = ((uint8_t)0x03),  /*!< Time base Prescaler = 8 */
+   TIM2_Prescaler_16   = ((uint8_t)0x04),  /*!< Time base Prescaler = 16 */
+   TIM2_Prescaler_32   = ((uint8_t)0x05),  /*!< Time base Prescaler = 32 */
+   TIM2_Prescaler_64   = ((uint8_t)0x06),  /*!< Time base Prescaler = 64 */
+   TIM2_Prescaler_128  = ((uint8_t)0x07)   /*!< Time base Prescaler = 128 */
+ }TIM2_Prescaler_TypeDef;
+ 
+ /**
+   * @brief TIM2 Output Compare and PWM modes
+   */
+ typedef enum
+ {
+   TIM2_OCMode_Timing  = ((uint8_t)0x00),  /*!< Timing (Frozen) Mode*/
+   TIM2_OCMode_Active    = ((uint8_t)0x10),  /*!< Active Mode*/
+   TIM2_OCMode_Inactive  = ((uint8_t)0x20),  /*!< Inactive Mode*/
+   TIM2_OCMode_Toggle    = ((uint8_t)0x30),  /*!< Toggle Mode*/
+   TIM2_OCMode_PWM1      = ((uint8_t)0x60),  /*!< PWM Mode 1*/
+   TIM2_OCMode_PWM2      = ((uint8_t)0x70)   /*!< PWM Mode 2*/
+ }TIM2_OCMode_TypeDef;
+ 
+ /**
+   * @brief TIM2 One Pulse Mode
+   */
+ typedef enum
+ {
+   TIM2_OPMode_Single   = ((uint8_t)0x01), /*!< Single one Pulse mode (OPM Active) */
+   TIM2_OPMode_Repetitive = ((uint8_t)0x00)  /*!< Repetitive Pulse mode (OPM inactive) */
+ }TIM2_OPMode_TypeDef;
+ 
+ /**
+   * @brief TIM2 Channel
+   */
+ typedef enum
+ {
+   TIM2_Channel_1 = ((uint8_t)0x00),  /*!< Channel 1*/
+   TIM2_Channel_2  = ((uint8_t)0x01)   /*!< Channel 2*/
+ }TIM2_Channel_TypeDef;
+ 
+ /**
+   * @brief TIM2 Counter Mode
+   */
+ typedef enum
+ {
+   TIM2_CounterMode_Up               = ((uint8_t)0x00),  /*!< Counter Up Mode */
+   TIM2_CounterMode_Down             = ((uint8_t)0x10),  /*!< Counter Down Mode */
+   TIM2_CounterMode_CenterAligned1   = ((uint8_t)0x20),  /*!< Counter Central aligned Mode 1 */
+   TIM2_CounterMode_CenterAligned2   = ((uint8_t)0x40),  /*!< Counter Central aligned Mode 2 */
+   TIM2_CounterMode_CenterAligned3   = ((uint8_t)0x60)   /*!< Counter Central aligned Mode 3 */
+ }TIM2_CounterMode_TypeDef;
+ 
+ /**
+   * @brief TIM2 Output Compare Polarity
+   */
+ typedef enum
+ {
+   TIM2_OCPolarity_High = ((uint8_t)0x00),  /*!< Output compare polarity  = High */
+   TIM2_OCPolarity_Low  = ((uint8_t)0x01)   /*!< Output compare polarity  = Low */
+ }TIM2_OCPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM2 Output Compare states
+   */
+ typedef enum
+ {
+   TIM2_OutputState_Disable = ((uint8_t)0x00),  /*!< Output compare State disabled (channel output disabled) */
+   TIM2_OutputState_Enable  = ((uint8_t)0x01)   /*!< Output compare State enabled (channel output enabled) */
+ }TIM2_OutputState_TypeDef;
+ 
+ /**
+   * @brief Break Input enable/disable
+   */
+ typedef enum
+ {
+   TIM2_BreakState_Disable = ((uint8_t)0x00),  /*!< Break State disabled (break option disabled) */
+   TIM2_BreakState_Enable = ((uint8_t)0x10)   /*!< Break State enabled (break option enabled) */
+ 
+ }TIM2_BreakState_TypeDef;
+ 
+ /**
+   * @brief Break Polarity
+   */
+ typedef enum
+ {
+   TIM2_BreakPolarity_High = ((uint8_t)0x20),  /*!< if Break, channel polarity = High */
+   TIM2_BreakPolarity_Low = ((uint8_t)0x00)   /*!< if Break, channel polarity = Low */
+ 
+ }TIM2_BreakPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM2 AOE Bit Set/Reset
+   */
+ typedef enum
+ {
+   TIM2_AutomaticOutput_Enable  = ((uint8_t)0x40),  /*!< Automatic Output option enabled */
+   TIM2_AutomaticOutput_Disable  = ((uint8_t)0x00)   /*!< Automatic Output option disabled */
+ }TIM2_AutomaticOutput_TypeDef;
+ 
+ /**
+   * @brief Lock levels
+   */
+ typedef enum
+ {
+   TIM2_LockLevel_Off = ((uint8_t)0x00),  /*!< Lock option disabled */
+   TIM2_LockLevel_1  = ((uint8_t)0x01),  /*!< Select Lock Level 1  */
+   TIM2_LockLevel_2  = ((uint8_t)0x02),  /*!< Select Lock Level 2  */
+   TIM2_LockLevel_3  = ((uint8_t)0x03)   /*!< Select Lock Level 3  */
+ }TIM2_LockLevel_TypeDef;
+ 
+ /**
+   * @brief OSSI: Off-State Selection for Idle mode states
+   */
+ typedef enum
+ {
+   TIM2_OSSIState_Enable  = ((uint8_t)0x04),  /*!< Off-State Selection for Idle mode enabled  */
+   TIM2_OSSIState_Disable = ((uint8_t)0x00)   /*!< Off-State Selection for Idle mode disabled  */
+ }TIM2_OSSIState_TypeDef;
+ 
+ /**
+   * @brief TIM2 Output Compare Idle State
+   */
+ typedef enum
+ {
+   TIM2_OCIdleState_Reset = ((uint8_t)0x00),  /*!< Output Compare Idle state  = Reset */
+   TIM2_OCIdleState_Set  = ((uint8_t)0x01)   /*!< Output Compare Idle state  = Set */
+ }TIM2_OCIdleState_TypeDef;
+ 
+ /**
+   * @brief TIM2 Input Capture Polarity
+   */
+ typedef enum
+ {
+   TIM2_ICPolarity_Rising = ((uint8_t)0x00),  /*!< Input Capture on Rising Edge*/
+   TIM2_ICPolarity_Falling = ((uint8_t)0x01)   /*!< Input Capture on Falling Edge*/
+ }TIM2_ICPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM2 Input Capture Selection
+   */
+ typedef enum
+ {
+   TIM2_ICSelection_DirectTI  = ((uint8_t)0x01),  /*!< Input Capture mapped on the direct input*/
+   TIM2_ICSelection_IndirectTI = ((uint8_t)0x02),  /*!< Input Capture mapped on the indirect input*/
+   TIM2_ICSelection_TRGI    = ((uint8_t)0x03)   /*!< Input Capture mapped on the Trigger Input*/
+ }TIM2_ICSelection_TypeDef;
+ 
+ /**
+   * @brief TIM2 Input Capture Prescaler
+   */
+ typedef enum
+ {
+   TIM2_ICPSC_Div1 = ((uint8_t)0x00),  /*!< Input Capture Prescaler = 1 (one capture every 1 event) */
+   TIM2_ICPSC_Div2 = ((uint8_t)0x04),  /*!< Input Capture Prescaler = 2 (one capture every 2 events) */
+   TIM2_ICPSC_Div4 = ((uint8_t)0x08),  /*!< Input Capture Prescaler = 4 (one capture every 4 events) */
+   TIM2_ICPSC_Div8 = ((uint8_t)0x0C)   /*!< Input Capture Prescaler = 8 (one capture every 8 events) */
+ }TIM2_ICPSC_TypeDef;
+ 
+ /**
+   * @brief TIM2 interrupt sources
+   */
+ typedef enum
+ {
+   TIM2_IT_Update = ((uint8_t)0x01),  /*!< Update Interrupt*/
+   TIM2_IT_CC1   = ((uint8_t)0x02),  /*!< Capture Compare Channel1 Interrupt*/
+   TIM2_IT_CC2   = ((uint8_t)0x04),  /*!< Capture Compare Channel2 Interrupt*/
+   TIM2_IT_Trigger = ((uint8_t)0x40),  /*!< Trigger  Interrupt*/
+   TIM2_IT_Break  = ((uint8_t)0x80)   /*!< Break Interrupt*/
+ }TIM2_IT_TypeDef;
+ 
+ /**
+   * @brief TIM2 External Trigger Prescaler
+   */
+ typedef enum
+ {
+   TIM2_ExtTRGPSC_OFF = ((uint8_t)0x00),  /*!< No External Trigger prescaler  */
+   TIM2_ExtTRGPSC_DIV2 = ((uint8_t)0x10),  /*!< External Trigger prescaler = 2 (ETRP frequency divided by 2) */
+   TIM2_ExtTRGPSC_DIV4 = ((uint8_t)0x20),  /*!< External Trigger prescaler = 4 (ETRP frequency divided by 4) */
+   TIM2_ExtTRGPSC_DIV8 = ((uint8_t)0x30)   /*!< External Trigger prescaler = 8 (ETRP frequency divided by 8) */
+ }TIM2_ExtTRGPSC_TypeDef;
+ 
+ /**
+   * @brief TIM2 Internal Trigger Selection
+   */
+ typedef enum
+ {
+   TIM2_TRGSelection_TIM3      = ((uint8_t)0x20),  /*!< TRIG Input source = TIM3  */
+   TIM2_TRGSelection_TIM4      = ((uint8_t)0x00),  /*!< TRIG Input source = TIM4  */
+   TIM2_TRGSelection_TI1F_ED   = ((uint8_t)0x40),  /*!< TRIG Input source = TI1F_ED (TI1 Edge Detector)  */
+   TIM2_TRGSelection_TI1FP1   = ((uint8_t)0x50),  /*!< TRIG Input source = TI1FP1  (Filtred Timer Input 1) */
+   TIM2_TRGSelection_TI2FP2   = ((uint8_t)0x60),  /*!< TRIG Input source = TI2FP2 (Filtred Timer Input 2)  */
+   TIM2_TRGSelection_ETRF    = ((uint8_t)0x70)   /*!< TRIG Input source =  ETRF (External Trigger Input ) */
+ }TIM2_TRGSelection_TypeDef;
+ 
+ /**
+   * @brief TIM2 TIx External Clock Source
+   */
+ typedef enum
+ {
+   TIM2_TIxExternalCLK1Source_TI1ED = ((uint8_t)0x40),  /*!< External Clock mode 1 source = TI1ED */
+   TIM2_TIxExternalCLK1Source_TI1  = ((uint8_t)0x50),   /*!< External Clock mode 1 source = TI1 */
+   TIM2_TIxExternalCLK1Source_TI2  = ((uint8_t)0x60)    /*!< External Clock mode 1 source = TI2 */
+ }TIM2_TIxExternalCLK1Source_TypeDef;
+ 
+ /**
+   * @brief TIM2 External Trigger Polarity
+   */
+ typedef enum
+ {
+   TIM2_ExtTRGPolarity_Inverted  = ((uint8_t)0x80),  /*!< External Trigger Polarity = inverted */
+   TIM2_ExtTRGPolarity_NonInverted = ((uint8_t)0x00)   /*!< External Trigger Polarity = non inverted */
+ }TIM2_ExtTRGPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM2 Prescaler Reload Mode
+   */
+ typedef enum
+ {
+   TIM2_PSCReloadMode_Update   = ((uint8_t)0x00),  /*!< Prescaler value is reloaded at every update*/
+   TIM2_PSCReloadMode_Immediate = ((uint8_t)0x01)   /*!< Prescaler value is reloaded immediately*/
+ }TIM2_PSCReloadMode_TypeDef;
+ 
+ /**
+   * @brief TIM2 Encoder Mode
+   */
+ typedef enum
+ {
+   TIM2_EncoderMode_TI1  = ((uint8_t)0x01),  /*!< Encoder mode 1*/
+   TIM2_EncoderMode_TI2  = ((uint8_t)0x02),  /*!< Encoder mode 2*/
+   TIM2_EncoderMode_TI12  = ((uint8_t)0x03)   /*!< Encoder mode 3*/
+ }TIM2_EncoderMode_TypeDef;
+ 
+ /**
+   * @brief TIM2 Event Source
+   */
+ typedef enum
+ {
+   TIM2_EventSource_Update  = ((uint8_t)0x01),  /*!< Update Event*/
+   TIM2_EventSource_CC1   = ((uint8_t)0x02),  /*!< Capture Compare Channel1  Event*/
+   TIM2_EventSource_CC2   = ((uint8_t)0x04),  /*!< Capture Compare Channel2 Event*/
+   TIM2_EventSource_Trigger = ((uint8_t)0x40),  /*!< Trigger Event*/
+   TIM2_EventSource_Break  = ((uint8_t)0x80)   /*!< Break Event*/
+ }TIM2_EventSource_TypeDef;
+ 
+ /**
+   * @brief TIM2 Update Source
+   */
+ typedef enum
+ {
+   TIM2_UpdateSource_Global = ((uint8_t)0x00),  /*!< Global Update request source */
+   TIM2_UpdateSource_Regular = ((uint8_t)0x01)   /*!< Regular Update request source */
+ }TIM2_UpdateSource_TypeDef;
+ 
+ /**
+   * @brief TIM2 Trigger Output Source
+   */
+ typedef enum
+ {
+   TIM2_TRGOSource_Reset  = ((uint8_t)0x00),  /*!< Trigger Output source = Reset*/
+   TIM2_TRGOSource_Enable  = ((uint8_t)0x10),  /*!< Trigger Output source = TIM2 is enabled*/
+   TIM2_TRGOSource_Update  = ((uint8_t)0x20),  /*!< Trigger Output source = Update event*/
+   TIM2_TRGOSource_OC1     = ((uint8_t)0x30),  /*!< Trigger Output source = output compare channel1  */
+   TIM2_TRGOSource_OC1Ref  = ((uint8_t)0x40),  /*!< Trigger Output source = output compare channel 1 reference */
+   TIM2_TRGOSource_OC2Ref  = ((uint8_t)0x50)   /*!< Trigger Output source = output compare channel 2 reference */
+ }TIM2_TRGOSource_TypeDef;
+ 
+ /**
+   * @brief TIM2 Slave Mode
+   */
+ typedef enum
+ {
+   TIM2_SlaveMode_Reset   = ((uint8_t)0x04),  /*!< Slave Mode Selection  = Reset*/
+   TIM2_SlaveMode_Gated      = ((uint8_t)0x05),  /*!< Slave Mode Selection  = Gated*/
+   TIM2_SlaveMode_Trigger    = ((uint8_t)0x06),  /*!< Slave Mode Selection  = Trigger*/
+   TIM2_SlaveMode_External1  = ((uint8_t)0x07)  /*!< Slave Mode Selection  = External 1*/
+ }TIM2_SlaveMode_TypeDef;
+ 
+ /**
+   * @brief TIM2 Flags
+   */
+ typedef enum
+ {
+   TIM2_FLAG_Update = ((uint16_t)0x0001),  /*!< Update Flag */
+   TIM2_FLAG_CC1    = ((uint16_t)0x0002),  /*!< Capture compare 1 Flag */
+   TIM2_FLAG_CC2   = ((uint16_t)0x0004),  /*!< Capture compare 2 Flag */
+   TIM2_FLAG_Trigger = ((uint16_t)0x0040),  /*!< Trigger Flag */
+   TIM2_FLAG_Break  = ((uint16_t)0x0080),  /*!< Break Flag */
+   TIM2_FLAG_CC1OF  = ((uint16_t)0x0200),  /*!< Capture compare 1 over capture Flag */
+   TIM2_FLAG_CC2OF  = ((uint16_t)0x0400)   /*!< Capture compare 2 over capture Flag */
+ }TIM2_FLAG_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup TIM2_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro TIM2 Forced Action
+   */
+ #define IS_TIM2_FORCED_ACTION(ACTION) \
+   ((ACTION == TIM2_ForcedAction_Active) || \
+    (ACTION == TIM2_ForcedAction_Inactive))
+ 
+ /**
+   * @brief Macro TIM2 Prescaler
+   */
+ #define IS_TIM2_PRESCALER(PRESCALER) \
+   (((PRESCALER) == TIM2_Prescaler_1)  || \
+    ((PRESCALER) == TIM2_Prescaler_2)  || \
+    ((PRESCALER) == TIM2_Prescaler_4)  || \
+    ((PRESCALER) == TIM2_Prescaler_8)  || \
+    ((PRESCALER) == TIM2_Prescaler_16) || \
+    ((PRESCALER) == TIM2_Prescaler_32) || \
+    ((PRESCALER) == TIM2_Prescaler_64) || \
+    ((PRESCALER) == TIM2_Prescaler_128))
+ 
+ /**
+   * @brief Macro TIM2 Output Compare and PWM modes
+   */
+ #define IS_TIM2_OC_MODE(MODE) \
+   (((MODE) ==  TIM2_OCMode_Timing)  || \
+    ((MODE) == TIM2_OCMode_Active)   || \
+    ((MODE) == TIM2_OCMode_Inactive) || \
+    ((MODE) == TIM2_OCMode_Toggle)   || \
+    ((MODE) == TIM2_OCMode_PWM1)     || \
+    ((MODE) == TIM2_OCMode_PWM2))
+ 
+ #define IS_TIM2_OCM(MODE) \
+   (((MODE) ==  TIM2_OCMode_Timing)  || \
+    ((MODE) == TIM2_OCMode_Active)   || \
+    ((MODE) == TIM2_OCMode_Inactive) || \
+    ((MODE) == TIM2_OCMode_Toggle)   || \
+    ((MODE) == TIM2_OCMode_PWM1)     || \
+    ((MODE) == TIM2_OCMode_PWM2)     || \
+    ((MODE) == (uint8_t)TIM2_ForcedAction_Active) || \
+    ((MODE) == (uint8_t)TIM2_ForcedAction_Inactive))
+ /**
+   * @brief Macro TIM2 One Pulse Mode
+   */
+ #define IS_TIM2_OPM_MODE(MODE) \
+   (((MODE) == TIM2_OPMode_Single) || \
+    ((MODE) == TIM2_OPMode_Repetitive))
+ 
+ /**
+   * @brief Macro TIM2 Channel
+   */
+ #define IS_TIM2_CHANNEL(CHANNEL) \
+   (((CHANNEL) == TIM2_Channel_1) || \
+    ((CHANNEL) == TIM2_Channel_2) )
+ 
+ /**
+   * @brief Macro TIM2 Counter Mode
+   */
+ #define IS_TIM2_COUNTER_MODE(MODE) \
+   (((MODE) == TIM2_CounterMode_Up)   || \
+    ((MODE) == TIM2_CounterMode_Down) || \
+    ((MODE) == TIM2_CounterMode_CenterAligned1) || \
+    ((MODE) == TIM2_CounterMode_CenterAligned2) || \
+    ((MODE) == TIM2_CounterMode_CenterAligned3))
+ 
+ /**
+   * @brief Macro TIM2 Output Compare Polarity
+   */
+ #define IS_TIM2_OC_POLARITY(POLARITY) \
+   (((POLARITY) == TIM2_OCPolarity_High) || \
+    ((POLARITY) == TIM2_OCPolarity_Low))
+ 
+ /**
+   * @brief Macro TIM2 Output Compare states
+   */
+ #define IS_TIM2_OUTPUT_STATE(STATE) \
+   (((STATE) == TIM2_OutputState_Disable) || \
+    ((STATE) == TIM2_OutputState_Enable))
+ 
+ /**
+  * @brief Macro Break Input enable/disable
+  */
+ #define IS_TIM2_BREAK_STATE(STATE) \
+   (((STATE) == TIM2_BreakState_Enable) || \
+    ((STATE) == TIM2_BreakState_Disable))
+ 
+ /**
+   * @brief Macro Break Polarity
+   */
+ #define IS_TIM2_BREAK_POLARITY(POLARITY) \
+   (((POLARITY) == TIM2_BreakPolarity_Low) || \
+    ((POLARITY) == TIM2_BreakPolarity_High))
+ 
+ /**
+   * @brief Macro TIM2 AOE Bit Set/Reset
+   */
+ #define IS_TIM2_AUTOMATIC_OUTPUT_STATE(STATE) \
+   (((STATE) == TIM2_AutomaticOutput_Enable) || \
+    ((STATE) == TIM2_AutomaticOutput_Disable ))
+ 
+ /**
+   * @brief Macro Lock levels
+   */
+ #define IS_TIM2_LOCK_LEVEL(LEVEL) \
+   (((LEVEL) == TIM2_LockLevel_Off) || \
+    ((LEVEL) == TIM2_LockLevel_1)   || \
+    ((LEVEL) == TIM2_LockLevel_2)   || \
+    ((LEVEL) == TIM2_LockLevel_3))
+ 
+ /**
+   * @brief Macro OSSI: Off-State Selection for Idle mode states
+   */
+ #define IS_TIM2_OSSI_STATE(STATE) \
+   (((STATE) == TIM2_OSSIState_Enable) || \
+    ((STATE) == TIM2_OSSIState_Disable))
+ 
+ /**
+   * @brief Macro TIM2 OC IDLE STATE
+   */
+ #define IS_TIM2_OCIDLE_STATE(STATE) \
+   (((STATE) == TIM2_OCIdleState_Set) || \
+    ((STATE) == TIM2_OCIdleState_Reset))
+ 
+ /**
+   * @brief Macro TIM2 IC POLARITY
+   */
+ 
+ #define IS_TIM2_IC_POLARITY(POLARITY) \
+   (((POLARITY) == TIM2_ICPolarity_Rising) || \
+    ((POLARITY) == TIM2_ICPolarity_Falling))
+ 
+ /**
+   * @brief Macro TIM2 IC SELECTION
+   */
+ #define IS_TIM2_IC_SELECTION(SELECTION) \
+   (((SELECTION) == TIM2_ICSelection_DirectTI)   || \
+    ((SELECTION) == TIM2_ICSelection_IndirectTI) || \
+    ((SELECTION) == TIM2_ICSelection_TRGI))
+ 
+ /**
+   * @brief Macro TIM2 IC PRESCALER
+   */
+ #define IS_TIM2_IC_PRESCALER(PRESCALER) \
+   (((PRESCALER) == TIM2_ICPSC_Div1) || \
+    ((PRESCALER) == TIM2_ICPSC_Div2) || \
+    ((PRESCALER) == TIM2_ICPSC_Div4) || \
+    ((PRESCALER) == TIM2_ICPSC_Div8))
+ 
+ /**
+   * @brief Macro TIM2 Input Capture Filter Value
+   */
+ #define IS_TIM2_IC_FILTER(ICFILTER) \
+   ((ICFILTER) <= 0x0F)
+ 
+ /**
+   * @brief Macro TIM2 Interrupts
+   */
+ #define IS_TIM2_IT(IT) \
+   ((IT) != 0x00)
+ 
+ #define IS_TIM2_GET_IT(IT) \
+   (((IT) == TIM2_IT_Update)  || \
+    ((IT) == TIM2_IT_CC1)     || \
+    ((IT) == TIM2_IT_CC2)     || \
+    ((IT) == TIM2_IT_Trigger) || \
+    ((IT) == TIM2_IT_Break))
+ 
+ /**
+   * @brief Macro TIM2 external trigger prescaler
+   */
+ #define IS_TIM2_EXT_PRESCALER(PRESCALER) \
+   (((PRESCALER) == TIM2_ExtTRGPSC_OFF)  || \
+    ((PRESCALER) == TIM2_ExtTRGPSC_DIV2) || \
+    ((PRESCALER) == TIM2_ExtTRGPSC_DIV4) || \
+    ((PRESCALER) == TIM2_ExtTRGPSC_DIV8))
+ /**
+   * @brief Macro TIM2  Trigger Selection
+   */
+ #define IS_TIM2_TRIGGER_SELECTION(SELECTION) \
+   (((SELECTION) == TIM2_TRGSelection_TIM3) || \
+    ((SELECTION) == TIM2_TRGSelection_TIM4)  || \
+    ((SELECTION) == TIM2_TRGSelection_TI1F_ED)  || \
+    ((SELECTION) == TIM2_TRGSelection_TI1FP1)  || \
+    ((SELECTION) == TIM2_TRGSelection_TI2FP2)  || \
+    ((SELECTION) == TIM2_TRGSelection_ETRF))
+ 
+ 
+ #define IS_TIM2_TIX_TRIGGER_SELECTION(SELECTION) \
+   (((SELECTION) == TIM2_TRGSelection_TI1F_ED) || \
+    ((SELECTION) == TIM2_TRGSelection_TI1FP1)  || \
+    ((SELECTION) == TIM2_TRGSelection_TI2FP2))
+ 
+ /**
+   * @brief Macro TIM2  TIx external Clock Selection
+   */
+ #define IS_TIM2_TIXCLK_SOURCE(SOURCE)  \
+   (((SOURCE) == TIM2_TIxExternalCLK1Source_TI1ED) || \
+    ((SOURCE) == TIM2_TIxExternalCLK1Source_TI2)   || \
+    ((SOURCE) == TIM2_TIxExternalCLK1Source_TI1))
+ 
+ /**
+   * @brief Macro TIM2  Trigger Polarity
+   */
+ #define IS_TIM2_EXT_POLARITY(POLARITY) \
+   (((POLARITY) == TIM2_ExtTRGPolarity_Inverted) || \
+    ((POLARITY) == TIM2_ExtTRGPolarity_NonInverted))
+ 
+ /**
+   * @brief Macro TIM2 External Trigger Filter
+   */
+ #define IS_TIM2_EXT_FILTER(EXTFILTER) \
+   ((EXTFILTER) <= 0x0F)
+ 
+ /**
+  * @brief Macro TIM2 Prescaler Reload
+   */
+ #define IS_TIM2_PRESCALER_RELOAD(RELOAD) \
+   (((RELOAD) == TIM2_PSCReloadMode_Update) || \
+    ((RELOAD) == TIM2_PSCReloadMode_Immediate))
+ 
+ /**
+   * @brief Macro TIM2 encoder mode
+   */
+ #define IS_TIM2_ENCODER_MODE(MODE) \
+   (((MODE) == TIM2_EncoderMode_TI1) || \
+    ((MODE) == TIM2_EncoderMode_TI2) || \
+    ((MODE) == TIM2_EncoderMode_TI12))
+ 
+ /**
+   * @brief Macro TIM2 event source
+   */
+ #define IS_TIM2_EVENT_SOURCE(SOURCE) \
+   (((SOURCE & (uint8_t)0x18) == 0x00) && \
+    (SOURCE != 0x00))
+ 
+ /**
+   * @brief Macro TIM2 update source
+   */
+ #define IS_TIM2_UPDATE_SOURCE(SOURCE) \
+   (((SOURCE) == TIM2_UpdateSource_Global) || \
+    ((SOURCE) == TIM2_UpdateSource_Regular))
+ 
+ /**
+   * @brief Macro TIM2 TRGO source
+   */
+ #define IS_TIM2_TRGO_SOURCE(SOURCE) \
+   (((SOURCE) == TIM2_TRGOSource_Reset)  || \
+    ((SOURCE) == TIM2_TRGOSource_Enable) || \
+    ((SOURCE) == TIM2_TRGOSource_Update) || \
+    ((SOURCE) == TIM2_TRGOSource_OC1)    || \
+    ((SOURCE) == TIM2_TRGOSource_OC1Ref) || \
+    ((SOURCE) == TIM2_TRGOSource_OC2Ref))
+ /**
+   * @brief Macro TIM2 Slave mode
+   */
+ #define IS_TIM2_SLAVE_MODE(MODE) \
+   (((MODE) == TIM2_SlaveMode_Reset)   || \
+    ((MODE) == TIM2_SlaveMode_Gated)   || \
+    ((MODE) == TIM2_SlaveMode_Trigger) || \
+    ((MODE) == TIM2_SlaveMode_External1))
+ /**
+   * @brief Macro TIM2 Flags
+   */
+ #define IS_TIM2_GET_FLAG(FLAG) \
+   (((FLAG) == TIM2_FLAG_Update)  || \
+    ((FLAG) == TIM2_FLAG_CC1)     || \
+    ((FLAG) == TIM2_FLAG_CC2)     || \
+    ((FLAG) == TIM2_FLAG_Trigger) || \
+    ((FLAG) == TIM2_FLAG_Break)   || \
+    ((FLAG) == TIM2_FLAG_CC1OF)   || \
+    ((FLAG) == TIM2_FLAG_CC2OF))
+ 
+ #define IS_TIM2_CLEAR_FLAG(FLAG) \
+   (((FLAG & (uint16_t)0xF938) == 0x0000) && (FLAG != 0x0000))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup TIM2_Exported_Functions
+   * @{
+   */
+ 
+ void TIM2_DeInit(void);
+ void TIM2_TimeBaseInit(TIM2_Prescaler_TypeDef TIM2_Prescaler,
+                        TIM2_CounterMode_TypeDef TIM2_CounterMode,
+                        uint16_t TIM2_Period);
+ void TIM2_OC1Init(TIM2_OCMode_TypeDef TIM2_OCMode,
+                   TIM2_OutputState_TypeDef TIM2_OutputState,
+                   uint16_t TIM2_Pulse,
+                   TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
+                   TIM2_OCIdleState_TypeDef TIM2_OCIdleState);
+ void TIM2_OC2Init(TIM2_OCMode_TypeDef TIM2_OCMode,
+                   TIM2_OutputState_TypeDef TIM2_OutputState,
+                   uint16_t TIM2_Pulse,
+                   TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
+                   TIM2_OCIdleState_TypeDef TIM2_OCIdleState);
+ void TIM2_BKRConfig(TIM2_OSSIState_TypeDef TIM2_OSSIState,
+                     TIM2_LockLevel_TypeDef TIM2_LockLevel,
+                     TIM2_BreakState_TypeDef TIM2_BreakState,
+                     TIM2_BreakPolarity_TypeDef TIM2_BreakPolarity,
+                     TIM2_AutomaticOutput_TypeDef TIM2_AutomaticOutput);
+ void TIM2_ICInit(TIM2_Channel_TypeDef TIM2_Channel,
+                  TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                  TIM2_ICSelection_TypeDef TIM2_ICSelection,
+                  TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
+                  uint8_t TIM2_ICFilter);
+ void TIM2_PWMIConfig(TIM2_Channel_TypeDef TIM2_Channel,
+                      TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                      TIM2_ICSelection_TypeDef TIM2_ICSelection,
+                      TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
+                      uint8_t TIM2_ICFilter);
+ void TIM2_Cmd(FunctionalState NewState);
+ void TIM2_CtrlPWMOutputs(FunctionalState NewState);
+ void TIM2_ITConfig(TIM2_IT_TypeDef TIM2_IT, FunctionalState NewState);
+ void TIM2_InternalClockConfig(void);
+ void TIM2_ETRClockMode1Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
+                               TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
+                               uint8_t TIM2_ExtTRGFilter);
+ void TIM2_ETRClockMode2Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
+                               TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
+                               uint8_t TIM2_ExtTRGFilter);
+ void TIM2_ETRConfig(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
+                     TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
+                     uint8_t TIM2_ExtTRGFilter);
+ void TIM2_TIxExternalClockConfig(TIM2_TIxExternalCLK1Source_TypeDef TIM2_TIxExternalCLKSource,
+                                  TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                                  uint8_t TIM2_ICFilter);
+ void TIM2_SelectInputTrigger(TIM2_TRGSelection_TypeDef TIM2_InputTriggerSource);
+ void TIM2_UpdateDisableConfig(FunctionalState Newstate);
+ void TIM2_UpdateRequestConfig(TIM2_UpdateSource_TypeDef TIM2_UpdateSource);
+ void TIM2_SelectHallSensor(FunctionalState Newstate);
+ void TIM2_SelectOnePulseMode(TIM2_OPMode_TypeDef TIM2_OPMode);
+ void TIM2_SelectOutputTrigger(TIM2_TRGOSource_TypeDef TIM2_TRGOSource);
+ void TIM2_SelectSlaveMode(TIM2_SlaveMode_TypeDef TIM2_SlaveMode);
+ void TIM2_SelectMasterSlaveMode(FunctionalState NewState);
+ void TIM2_EncoderInterfaceConfig(TIM2_EncoderMode_TypeDef TIM2_EncoderMode,
+                                  TIM2_ICPolarity_TypeDef TIM2_IC1Polarity,
+                                  TIM2_ICPolarity_TypeDef TIM2_IC2Polarity);
+ void TIM2_PrescalerConfig(TIM2_Prescaler_TypeDef Prescaler,
+                           TIM2_PSCReloadMode_TypeDef TIM2_PSCReloadMode);
+ void TIM2_CounterModeConfig(TIM2_CounterMode_TypeDef TIM2_CounterMode);
+ void TIM2_ForcedOC1Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction);
+ void TIM2_ForcedOC2Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction);
+ void TIM2_ARRPreloadConfig(FunctionalState Newstate);
+ void TIM2_OC1PreloadConfig(FunctionalState Newstate);
+ void TIM2_OC2PreloadConfig(FunctionalState Newstate);
+ void TIM2_OC1FastCmd(FunctionalState Newstate);
+ void TIM2_OC2FastCmd(FunctionalState Newstate);
+ void TIM2_GenerateEvent(TIM2_EventSource_TypeDef TIM2_EventSource);
+ void TIM2_OC1PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity);
+ void TIM2_OC2PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity);
+ void TIM2_CCxCmd(TIM2_Channel_TypeDef TIM2_Channel,
+                  FunctionalState Newstate);
+ void TIM2_SelectOCxM(TIM2_Channel_TypeDef TIM2_Channel,
+                      TIM2_OCMode_TypeDef TIM2_OCMode);
+ void TIM2_SetCounter(uint16_t TIM2_Counter);
+ void TIM2_SetAutoreload(uint16_t TIM2_Autoreload);
+ void TIM2_SetCompare1(uint16_t TIM2_Compare);
+ void TIM2_SetCompare2(uint16_t TIM2_Compare);
+ void TIM2_SetIC1Prescaler(TIM2_ICPSC_TypeDef TIM2_IC1Prescaler);
+ void TIM2_SetIC2Prescaler(TIM2_ICPSC_TypeDef TIM2_IC2Prescaler);
+ uint16_t TIM2_GetCapture1(void);
+ uint16_t TIM2_GetCapture2(void);
+ uint16_t TIM2_GetCounter(void);
+ TIM2_Prescaler_TypeDef TIM2_GetPrescaler(void);
+ FlagStatus TIM2_GetFlagStatus(TIM2_FLAG_TypeDef TIM2_FLAG);
+ void TIM2_ClearFlag(TIM2_FLAG_TypeDef TIM2_FLAG);
+ ITStatus TIM2_GetITStatus(TIM2_IT_TypeDef TIM2_IT);
+ void TIM2_ClearITPendingBit(TIM2_IT_TypeDef TIM2_IT);
+ uint32_t TIM2_ComputeLsiClockFreq(uint32_t TimerClockFreq);
+ FunctionalState TIM2_GetStatus(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10x_TIM2_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim3.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim3.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim3.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim3.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,747 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_tim3.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the TIM3
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_TIM3_H
+ #define __STM8L10X_TIM3_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup TIM3_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief TIM3 Forced Action
+   */
+ typedef enum
+ {
+   TIM3_ForcedAction_Active       = ((uint8_t)0x50), /*!< Output Reference is forced low */
+   TIM3_ForcedAction_Inactive     = ((uint8_t)0x40)  /*!< Output Reference is forced high */
+ }
+ TIM3_ForcedAction_TypeDef;
+ 
+ /**
+   * @brief TIM3 Prescaler
+   */
+ typedef enum
+ {
+   TIM3_Prescaler_1     = ((uint8_t)0x00), /*!< Time base Prescaler = 1 (No effect)*/
+   TIM3_Prescaler_2     = ((uint8_t)0x01), /*!< Time base Prescaler = 2 */
+   TIM3_Prescaler_4     = ((uint8_t)0x02), /*!< Time base Prescaler = 4 */
+   TIM3_Prescaler_8     = ((uint8_t)0x03), /*!< Time base Prescaler = 8 */
+   TIM3_Prescaler_16    = ((uint8_t)0x04), /*!< Time base Prescaler = 16 */
+   TIM3_Prescaler_32    = ((uint8_t)0x05), /*!< Time base Prescaler = 32 */
+   TIM3_Prescaler_64    = ((uint8_t)0x06), /*!< Time base Prescaler = 64 */
+   TIM3_Prescaler_128   = ((uint8_t)0x07)  /*!< Time base Prescaler = 128 */
+ }TIM3_Prescaler_TypeDef;
+ 
+ /**
+   * @brief TIM3 Output Compare and PWM modes
+   */
+ typedef enum
+ {
+   TIM3_OCMode_Timing   = ((uint8_t)0x00), /*!< Timing (Frozen) Mode*/
+   TIM3_OCMode_Active    = ((uint8_t)0x10), /*!< Active Mode*/
+   TIM3_OCMode_Inactive  = ((uint8_t)0x20), /*!< Inactive Mode*/
+   TIM3_OCMode_Toggle    = ((uint8_t)0x30), /*!< Toggle Mode*/
+   TIM3_OCMode_PWM1      = ((uint8_t)0x60), /*!< PWM Mode 1*/
+   TIM3_OCMode_PWM2      = ((uint8_t)0x70)  /*!< PWM Mode 2*/
+ }TIM3_OCMode_TypeDef;
+ 
+ /**
+   * @brief TIM3 One Pulse Mode
+   */
+ typedef enum
+ {
+   TIM3_OPMode_Single        = ((uint8_t)0x01), /*!< Single one Pulse mode (OPM Active) */
+   TIM3_OPMode_Repetitive    = ((uint8_t)0x00)  /*!< Repetitive Pulse mode (OPM inactive) */
+ }TIM3_OPMode_TypeDef;
+ 
+ /**
+   * @brief TIM3 Channel
+   */
+ typedef enum
+ {
+   TIM3_Channel_1     = ((uint8_t)0x00),  /*!< Channel 1*/
+   TIM3_Channel_2     = ((uint8_t)0x01)   /*!< Channel 2*/
+ }TIM3_Channel_TypeDef;
+ 
+ /**
+   * @brief TIM3 Counter Mode
+   */
+ typedef enum
+ {
+   TIM3_CounterMode_Up                 = ((uint8_t)0x00), /*!< Counter Up Mode */
+   TIM3_CounterMode_Down               = ((uint8_t)0x10), /*!< Counter Down Mode */
+   TIM3_CounterMode_CenterAligned1     = ((uint8_t)0x20), /*!< Counter Central aligned Mode 1 */
+   TIM3_CounterMode_CenterAligned2     = ((uint8_t)0x40), /*!< Counter Central aligned Mode 2 */
+   TIM3_CounterMode_CenterAligned3     = ((uint8_t)0x60)  /*!< Counter Central aligned Mode 3 */
+ }TIM3_CounterMode_TypeDef;
+ 
+ /**
+   * @brief TIM3 Output Compare Polarity
+   */
+ typedef enum
+ {
+   TIM3_OCPolarity_High       = ((uint8_t)0x00), /*!< Output compare polarity  = High */
+   TIM3_OCPolarity_Low        = ((uint8_t)0x01)  /*!< Output compare polarity  = Low */
+ }TIM3_OCPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM3 Output Compare states
+   */
+ typedef enum
+ {
+   TIM3_OutputState_Disable   = ((uint8_t)0x00), /*!< Output compare State disabled (channel output disabled) */
+   TIM3_OutputState_Enable    = ((uint8_t)0x01)  /*!< Output compare State enabled (channel output enabled) */
+ }TIM3_OutputState_TypeDef;
+ 
+ /**
+   * @brief Break Input enable/disable
+   */
+ typedef enum
+ {
+   TIM3_BreakState_Disable = ((uint8_t)0x00), /*!< Break State disabled (break option disabled) */
+   TIM3_BreakState_Enable = ((uint8_t)0x10)  /*!< Break State enabled (break option enabled) */
+ 
+ }TIM3_BreakState_TypeDef;
+ 
+ /**
+   * @brief Break Polarity
+   */
+ typedef enum
+ {
+   TIM3_BreakPolarity_High = ((uint8_t)0x20),  /*!<  Break channel polarity = High */
+   TIM3_BreakPolarity_Low = ((uint8_t)0x00)   /*!<  Break channel polarity = Low */
+ 
+ }TIM3_BreakPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM3 AOE Bit Set/Reset
+   */
+ typedef enum
+ {
+   TIM3_AutomaticOutput_Enable   = ((uint8_t)0x40), /*!< Automatic Output option enabled */
+   TIM3_AutomaticOutput_Disable   = ((uint8_t)0x00)  /*!< Automatic Output option disabled */
+ }TIM3_AutomaticOutput_TypeDef;
+ 
+ /**
+   * @brief Lock levels
+   */
+ typedef enum
+ {
+   TIM3_LockLevel_Off        = ((uint8_t)0x00), /*!< Lock option disabled */
+   TIM3_LockLevel_1          = ((uint8_t)0x01), /*!< Select Lock Level 1  */
+   TIM3_LockLevel_2          = ((uint8_t)0x02), /*!< Select Lock Level 2  */
+   TIM3_LockLevel_3          = ((uint8_t)0x03)  /*!< Select Lock Level 3  */
+ }TIM3_LockLevel_TypeDef;
+ 
+ /**
+   * @brief OSSI: Off-State Selection for Idle mode states
+   */
+ typedef enum
+ {
+   TIM3_OSSIState_Enable  = ((uint8_t)0x04), /*!< Off-State Selection for Idle mode enabled  */
+   TIM3_OSSIState_Disable = ((uint8_t)0x00)  /*!< Off-State Selection for Idle mode disabled  */
+ }TIM3_OSSIState_TypeDef;
+ 
+ /**
+   * @brief TIM3 Output Compare Idle State
+   */
+ typedef enum
+ {
+   TIM3_OCIdleState_Reset     = ((uint8_t)0x00), /*!< Output Compare Idle state  = Reset */
+   TIM3_OCIdleState_Set       = ((uint8_t)0x01)  /*!< Output Compare Idle state  = Set */
+ }TIM3_OCIdleState_TypeDef;
+ 
+ /**
+   * @brief TIM3 Input Capture Polarity
+   */
+ typedef enum
+ {
+   TIM3_ICPolarity_Rising = ((uint8_t)0x00), /*!< Input Capture on Rising Edge*/
+   TIM3_ICPolarity_Falling = ((uint8_t)0x01)  /*!< Input Capture on Falling Edge*/
+ }TIM3_ICPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM3 Input Capture Selection
+   */
+ typedef enum
+ {
+   TIM3_ICSelection_DirectTI          = ((uint8_t)0x01), /*!< Input Capture mapped on the direct input*/
+   TIM3_ICSelection_IndirectTI        = ((uint8_t)0x02), /*!< Input Capture mapped on the indirect input*/
+   TIM3_ICSelection_TRGI              = ((uint8_t)0x03)  /*!< Input Capture mapped on the Trigger Input*/
+ }TIM3_ICSelection_TypeDef;
+ 
+ /**
+   * @brief TIM3 Input Capture Prescaler
+   */
+ typedef enum
+ {
+   TIM3_ICPSC_Div1 = ((uint8_t)0x00),  /*!< Input Capture Prescaler = 1 (one capture every 1 event) */
+   TIM3_ICPSC_Div2 = ((uint8_t)0x04),  /*!< Input Capture Prescaler = 2 (one capture every 2 events) */
+   TIM3_ICPSC_Div4 = ((uint8_t)0x08),  /*!< Input Capture Prescaler = 4 (one capture every 4 events) */
+   TIM3_ICPSC_Div8 = ((uint8_t)0x0C)   /*!< Input Capture Prescaler = 8 (one capture every 8 events) */
+ }TIM3_ICPSC_TypeDef;
+ 
+ /**
+   * @brief TIM3 interrupt sources
+   */
+ typedef enum
+ {
+   TIM3_IT_Update        = ((uint8_t)0x01), /*!< Update Interrupt*/
+   TIM3_IT_CC1           = ((uint8_t)0x02), /*!< Capture Compare Channel1 Interrupt*/
+   TIM3_IT_CC2           = ((uint8_t)0x04), /*!< Capture Compare Channel2 Interrupt*/
+   TIM3_IT_Trigger       = ((uint8_t)0x40), /*!< Trigger  Interrupt*/
+   TIM3_IT_Break         = ((uint8_t)0x80)  /*!< Break Interrupt*/
+ }TIM3_IT_TypeDef;
+ 
+ /**
+   * @brief TIM3 External Trigger Prescaler
+   */
+ typedef enum
+ {
+   TIM3_ExtTRGPSC_OFF   = ((uint8_t)0x00), /*!< No External Trigger prescaler  */
+   TIM3_ExtTRGPSC_DIV2  = ((uint8_t)0x10), /*!< External Trigger prescaler = 2 (ETRP frequency divided by 2) */
+   TIM3_ExtTRGPSC_DIV4  = ((uint8_t)0x20), /*!< External Trigger prescaler = 4 (ETRP frequency divided by 4) */
+   TIM3_ExtTRGPSC_DIV8  = ((uint8_t)0x30)  /*!< External Trigger prescaler = 8 (ETRP frequency divided by 8) */
+ }TIM3_ExtTRGPSC_TypeDef;
+ 
+ /**
+   * @brief TIM3 Internal Trigger Selection
+   */
+ typedef enum
+ {
+   TIM3_TRGSelection_TIM2      = ((uint8_t)0x30),  /*!< TRIG Input source = TIM2  */
+   TIM3_TRGSelection_TIM4      = ((uint8_t)0x00),  /*!< TRIG Input source = TIM4  */
+   TIM3_TRGSelection_TI1F_ED   = ((uint8_t)0x40), /*!< TRIG Input source = TI1F_ED (TI1 Edge Detector)  */
+   TIM3_TRGSelection_TI1FP1    = ((uint8_t)0x50), /*!< TRIG Input source = TI1FP1  (Filtred Timer Input 1) */
+   TIM3_TRGSelection_TI2FP2    = ((uint8_t)0x60), /*!< TRIG Input source = TI2FP2 (Filtred Timer Input 2)  */
+   TIM3_TRGSelection_ETRF      = ((uint8_t)0x70)  /*!< TRIG Input source =  ETRF (External Trigger Input ) */
+ }TIM3_TRGSelection_TypeDef;
+ 
+ /**
+   * @brief TIM3 TIx External Clock Source
+   */
+ typedef enum
+ {
+   TIM3_TIxExternalCLK1Source_TI1ED     = ((uint8_t)0x40),  /*!< External Clock mode 1 source = TI1ED */
+   TIM3_TIxExternalCLK1Source_TI1       = ((uint8_t)0x50),  /*!< External Clock mode 1 source = TI1 */
+   TIM3_TIxExternalCLK1Source_TI2       = ((uint8_t)0x60)   /*!< External Clock mode 1 source = TI2 */
+ }TIM3_TIxExternalCLK1Source_TypeDef;
+ 
+ /**
+   * @brief TIM3 External Trigger Polarity
+   */
+ typedef enum
+ {
+   TIM3_ExtTRGPolarity_Inverted         = ((uint8_t)0x80), /*!< External Trigger Polarity = inverted */
+   TIM3_ExtTRGPolarity_NonInverted      = ((uint8_t)0x00)  /*!< External Trigger Polarity = non inverted */
+ }TIM3_ExtTRGPolarity_TypeDef;
+ 
+ /**
+   * @brief TIM3 Prescaler Reload Mode
+   */
+ typedef enum
+ {
+   TIM3_PSCReloadMode_Update        = ((uint8_t)0x00), /*!< Prescaler value is reloaded at every update*/
+   TIM3_PSCReloadMode_Immediate     = ((uint8_t)0x01)  /*!< Prescaler value is reloaded immediatly*/
+ }TIM3_PSCReloadMode_TypeDef;
+ 
+ /**
+   * @brief TIM3 Encoder Mode
+   */
+ typedef enum
+ {
+   TIM3_EncoderMode_TI1    = ((uint8_t)0x01), /*!< Encoder mode 1*/
+   TIM3_EncoderMode_TI2    = ((uint8_t)0x02), /*!< Encoder mode 2*/
+   TIM3_EncoderMode_TI12   = ((uint8_t)0x03)  /*!< Encoder mode 3*/
+ }TIM3_EncoderMode_TypeDef;
+ 
+ /**
+   * @brief TIM3 Event Source
+   */
+ typedef enum
+ {
+   TIM3_EventSource_Update   = ((uint8_t)0x01), /*!< Update Event*/
+   TIM3_EventSource_CC1      = ((uint8_t)0x02), /*!< Capture Compare Channel1  Event*/
+   TIM3_EventSource_CC2      = ((uint8_t)0x04), /*!< Capture Compare Channel2 Event*/
+   TIM3_EventSource_Trigger  = ((uint8_t)0x40), /*!< Trigger Event*/
+   TIM3_EventSource_Break    = ((uint8_t)0x80)  /*!< Break Event*/
+ }TIM3_EventSource_TypeDef;
+ 
+ /**
+   * @brief TIM3 Update Source
+   */
+ typedef enum
+ {
+   TIM3_UpdateSource_Global  = ((uint8_t)0x00), /*!< Global Update request source */
+   TIM3_UpdateSource_Regular = ((uint8_t)0x01)  /*!< Regular Update request source */
+ }TIM3_UpdateSource_TypeDef;
+ 
+ /**
+   * @brief TIM3 Trigger Output Source
+   */
+ typedef enum
+ {
+   TIM3_TRGOSource_Reset      = ((uint8_t)0x00), /*!< Trigger Output source = Reset*/
+   TIM3_TRGOSource_Enable     = ((uint8_t)0x10), /*!< Trigger Output source = TIM3 is enabled*/
+   TIM3_TRGOSource_Update     = ((uint8_t)0x20), /*!< Trigger Output source = Update event*/
+   TIM3_TRGOSource_OC1        = ((uint8_t)0x30), /*!< Trigger Output source = output compare channel1  */
+   TIM3_TRGOSource_OC1Ref     = ((uint8_t)0x40), /*!< Trigger Output source = output compare channel 1 reference */
+   TIM3_TRGOSource_OC2Ref     = ((uint8_t)0x50)  /*!< Trigger Output source = output compare channel 2 reference */
+ }TIM3_TRGOSource_TypeDef;
+ 
+ /**
+   * @brief TIM3 Slave Mode
+   */
+ typedef enum
+ {
+   TIM3_SlaveMode_Reset       = ((uint8_t)0x04), /*!< Slave Mode Selection  = Reset*/
+   TIM3_SlaveMode_Gated       = ((uint8_t)0x05), /*!< Slave Mode Selection  = Gated*/
+   TIM3_SlaveMode_Trigger     = ((uint8_t)0x06), /*!< Slave Mode Selection  = Trigger*/
+   TIM3_SlaveMode_External1   = ((uint8_t)0x07)  /*!< Slave Mode Selection  = External 1*/
+ }TIM3_SlaveMode_TypeDef;
+ 
+ /**
+   * @brief TIM3 Flags
+   */
+ typedef enum
+ {
+   TIM3_FLAG_Update    = ((uint16_t)0x0001), /*!< Update Flag */
+   TIM3_FLAG_CC1       = ((uint16_t)0x0002), /*!< Capture compare 1 Flag */
+   TIM3_FLAG_CC2       = ((uint16_t)0x0004), /*!< Capture compare 2 Flag */
+   TIM3_FLAG_Trigger   = ((uint16_t)0x0040), /*!< Trigger Flag */
+   TIM3_FLAG_Break     = ((uint16_t)0x0080), /*!< Break Flag */
+   TIM3_FLAG_CC1OF     = ((uint16_t)0x0200), /*!< Capture compare 1 over capture Flag */
+   TIM3_FLAG_CC2OF     = ((uint16_t)0x0400)  /*!< Capture compare 2 over capture Flag */
+ }TIM3_FLAG_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup TIM3_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro TIM3 Forced Action
+   */
+ #define IS_TIM3_FORCED_ACTION(ACTION) \
+   (((ACTION) == TIM3_ForcedAction_Active) || \
+    ((ACTION) == TIM3_ForcedAction_Inactive))
+ 
+ /**
+   * @brief Macro TIM3 Prescaler
+   */
+ #define IS_TIM3_PRESCALER(PRESCALER) \
+   (((PRESCALER) == TIM3_Prescaler_1)  || \
+    ((PRESCALER) == TIM3_Prescaler_2)  || \
+    ((PRESCALER) == TIM3_Prescaler_4)  || \
+    ((PRESCALER) == TIM3_Prescaler_8)  || \
+    ((PRESCALER) == TIM3_Prescaler_16) || \
+    ((PRESCALER) == TIM3_Prescaler_32) || \
+    ((PRESCALER) == TIM3_Prescaler_64) || \
+    ((PRESCALER) == TIM3_Prescaler_128))
+ 
+ /**
+   * @brief Macro TIM3 Output Compare and PWM modes
+   */
+ #define IS_TIM3_OC_MODE(MODE) \
+   (((MODE) ==  TIM3_OCMode_Timing)  || \
+    ((MODE) == TIM3_OCMode_Active)   || \
+    ((MODE) == TIM3_OCMode_Inactive) || \
+    ((MODE) == TIM3_OCMode_Toggle)   || \
+    ((MODE) == TIM3_OCMode_PWM1)     || \
+    ((MODE) == TIM3_OCMode_PWM2))
+ 
+ #define IS_TIM3_OCM(MODE)   \
+   (((MODE) ==  TIM3_OCMode_Timing)  || \
+    ((MODE) == TIM3_OCMode_Active)   || \
+    ((MODE) == TIM3_OCMode_Inactive) || \
+    ((MODE) == TIM3_OCMode_Toggle)   || \
+    ((MODE) == TIM3_OCMode_PWM1)     || \
+    ((MODE) == TIM3_OCMode_PWM2)     || \
+    ((MODE) == (uint8_t)TIM3_ForcedAction_Active) || \
+    ((MODE) == (uint8_t)TIM3_ForcedAction_Inactive))
+ /**
+   * @brief Macro TIM3 One Pulse Mode
+   */
+ #define IS_TIM3_OPM_MODE(MODE) \
+   (((MODE) == TIM3_OPMode_Single) || \
+    ((MODE) == TIM3_OPMode_Repetitive))
+ 
+ /**
+   * @brief Macro TIM3 Channel
+   */
+ #define IS_TIM3_CHANNEL(CHANNEL) \
+   (((CHANNEL) == TIM3_Channel_1) || \
+    ((CHANNEL) == TIM3_Channel_2) )
+ 
+ /**
+   * @brief Macro TIM3 Counter Mode
+   */
+ #define IS_TIM3_COUNTER_MODE(MODE) \
+   (((MODE) == TIM3_CounterMode_Up)   || \
+    ((MODE) == TIM3_CounterMode_Down) || \
+    ((MODE) == TIM3_CounterMode_CenterAligned1) || \
+    ((MODE) == TIM3_CounterMode_CenterAligned2) || \
+    ((MODE) == TIM3_CounterMode_CenterAligned3))
+ 
+ /**
+   * @brief Macro TIM3 Output Compare Polarity
+   */
+ #define IS_TIM3_OC_POLARITY(POLARITY) \
+   (((POLARITY) == TIM3_OCPolarity_High) || \
+    ((POLARITY) == TIM3_OCPolarity_Low))
+ 
+ /**
+   * @brief Macro TIM3 Output Compare states
+   */
+ #define IS_TIM3_OUTPUT_STATE(STATE) \
+   (((STATE) == TIM3_OutputState_Disable) || \
+    ((STATE) == TIM3_OutputState_Enable))
+ 
+ 
+ /**
+   * @brief Macro Break Input enable/disable
+   */
+ #define IS_TIM3_BREAK_STATE(STATE) \
+   (((STATE) == TIM3_BreakState_Enable) || \
+    ((STATE) == TIM3_BreakState_Disable))
+ 
+ /**
+   * @brief Macro Break Polarity
+   */
+ #define IS_TIM3_BREAK_POLARITY(POLARITY) \
+   (((POLARITY) == TIM3_BreakPolarity_Low) || \
+    ((POLARITY) == TIM3_BreakPolarity_High))
+ 
+ /**
+   * @brief Macro TIM3 AOE Bit Set/Reset
+   */
+ #define IS_TIM3_AUTOMATIC_OUTPUT_STATE(STATE) \
+   (((STATE) == TIM3_AutomaticOutput_Enable) || \
+    ((STATE) == TIM3_AutomaticOutput_Disable ))
+ 
+ /**
+   * @brief Macro Lock levels
+   */
+ #define IS_TIM3_LOCK_LEVEL(LEVEL) \
+   (((LEVEL) == TIM3_LockLevel_Off) || \
+    ((LEVEL) == TIM3_LockLevel_1)   || \
+    ((LEVEL) == TIM3_LockLevel_2)   || \
+    ((LEVEL) == TIM3_LockLevel_3))
+ 
+ /**
+   * @brief Macro OSSI: Off-State Selection for Idle mode states
+   */
+ #define IS_TIM3_OSSI_STATE(STATE) \
+   (((STATE) == TIM3_OSSIState_Enable) || \
+    ((STATE) == TIM3_OSSIState_Disable))
+ 
+ /**
+   * @brief Macro TIM3 OC IDLE STATE
+   */
+ #define IS_TIM3_OCIDLE_STATE(STATE) \
+   (((STATE) == TIM3_OCIdleState_Set) || \
+    ((STATE) == TIM3_OCIdleState_Reset))
+ 
+ /**
+   * @brief Macro TIM3 IC POLARITY
+   */
+ 
+ #define IS_TIM3_IC_POLARITY(POLARITY) \
+   (((POLARITY) == TIM3_ICPolarity_Rising) || \
+    ((POLARITY) == TIM3_ICPolarity_Falling))
+ 
+ /**
+   * @brief Macro TIM3 IC SELECTION
+   */
+ #define IS_TIM3_IC_SELECTION(SELECTION) \
+   (((SELECTION) == TIM3_ICSelection_DirectTI)   || \
+    ((SELECTION) == TIM3_ICSelection_IndirectTI) || \
+    ((SELECTION) == TIM3_ICSelection_TRGI))
+ 
+ /**
+   * @brief Macro TIM3 IC PRESCALER
+   */
+ #define IS_TIM3_IC_PRESCALER(PRESCALER) \
+   (((PRESCALER) == TIM3_ICPSC_Div1) || \
+    ((PRESCALER) == TIM3_ICPSC_Div2) || \
+    ((PRESCALER) == TIM3_ICPSC_Div4) || \
+    ((PRESCALER) == TIM3_ICPSC_Div8))
+ 
+ /**
+   * @brief Macro TIM3 Input Capture Filter Value
+   */
+ #define IS_TIM3_IC_FILTER(ICFILTER) \
+   ((ICFILTER) <= 0x0F)
+ 
+ /**
+   * @brief Macro TIM3 Interrupts
+   */
+ #define IS_TIM3_IT(IT) \
+   ((IT) != 0x00)
+ 
+ #define IS_TIM3_GET_IT(IT) \
+   (((IT) == TIM3_IT_Update)  || \
+    ((IT) == TIM3_IT_CC1)     || \
+    ((IT) == TIM3_IT_CC2)     || \
+    ((IT) == TIM3_IT_Trigger) || \
+    ((IT) == TIM3_IT_Break))
+ 
+ /**
+   * @brief Macro TIM3 external trigger prescaler
+   */
+ #define IS_TIM3_EXT_PRESCALER(PRESCALER) \
+   (((PRESCALER) == TIM3_ExtTRGPSC_OFF)  || \
+    ((PRESCALER) == TIM3_ExtTRGPSC_DIV2) || \
+    ((PRESCALER) == TIM3_ExtTRGPSC_DIV4) || \
+    ((PRESCALER) == TIM3_ExtTRGPSC_DIV8))
+ 
+ /**
+   * @brief Macro TIM3  Trigger Selection
+   */
+ #define IS_TIM3_TRIGGER_SELECTION(SELECTION) \
+   (((SELECTION) == TIM3_TRGSelection_TIM2) || \
+    ((SELECTION) == TIM3_TRGSelection_TIM4) || \
+    ((SELECTION) == TIM3_TRGSelection_TI1F_ED) || \
+    ((SELECTION) == TIM3_TRGSelection_TI1FP1)  || \
+    ((SELECTION) == TIM3_TRGSelection_TI2FP2)  || \
+    ((SELECTION) == TIM3_TRGSelection_ETRF))
+ 
+ 
+ #define IS_TIM3_TIX_TRIGGER_SELECTION(SELECTION) \
+   (((SELECTION) == TIM3_TRGSelection_TI1F_ED) || \
+    ((SELECTION) == TIM3_TRGSelection_TI1FP1)  || \
+    ((SELECTION) == TIM3_TRGSelection_TI2FP2))
+ 
+ /**
+   * @brief Macro TIM3  TIx external Clock Selection
+   */
+ #define IS_TIM3_TIXCLK_SOURCE(SOURCE)  \
+   (((SOURCE) == TIM3_TIxExternalCLK1Source_TI1ED) || \
+    ((SOURCE) == TIM3_TIxExternalCLK1Source_TI2)   || \
+    ((SOURCE) == TIM3_TIxExternalCLK1Source_TI1))
+ 
+ /**
+   * @brief Macro TIM3  Trigger Polarity
+   */
+ #define IS_TIM3_EXT_POLARITY(POLARITY) \
+   (((POLARITY) == TIM3_ExtTRGPolarity_Inverted) || \
+    ((POLARITY) == TIM3_ExtTRGPolarity_NonInverted))
+ 
+ /**
+   * @brief Macro TIM3 External Trigger Filter
+   */
+ #define IS_TIM3_EXT_FILTER(EXTFILTER) \
+   ((EXTFILTER) <= 0x0F)
+ 
+ /**
+   * @brief Macro TIM3 Prescaler Reload
+   */
+ #define IS_TIM3_PRESCALER_RELOAD(RELOAD) \
+   (((RELOAD) == TIM3_PSCReloadMode_Update) || \
+    ((RELOAD) == TIM3_PSCReloadMode_Immediate))
+ 
+ /**
+   * @brief Macro TIM3 encoder mode
+   */
+ #define IS_TIM3_ENCODER_MODE(MODE) \
+   (((MODE) == TIM3_EncoderMode_TI1) || \
+    ((MODE) == TIM3_EncoderMode_TI2) || \
+    ((MODE) == TIM3_EncoderMode_TI12))
+ 
+ /**
+   * @brief Macro TIM3 event source
+   */
+ #define IS_TIM3_EVENT_SOURCE(SOURCE) \
+   (((SOURCE & (uint8_t)0x18) == 0x00) && (SOURCE != 0x00))
+ 
+ /**
+   * @brief Macro TIM3 update source
+   */
+ #define IS_TIM3_UPDATE_SOURCE(SOURCE) \
+   (((SOURCE) == TIM3_UpdateSource_Global) || \
+    ((SOURCE) == TIM3_UpdateSource_Regular))
+ 
+ /**
+   * @brief Macro TIM3 TRGO source
+   */
+ #define IS_TIM3_TRGO_SOURCE(SOURCE) \
+   (((SOURCE) == TIM3_TRGOSource_Reset)  || \
+    ((SOURCE) == TIM3_TRGOSource_Enable) || \
+    ((SOURCE) == TIM3_TRGOSource_Update) || \
+    ((SOURCE) == TIM3_TRGOSource_OC1)    || \
+    ((SOURCE) == TIM3_TRGOSource_OC1Ref) || \
+    ((SOURCE) == TIM3_TRGOSource_OC2Ref))
+ /**
+   * @brief Macro TIM3 Slave mode
+   */
+ #define IS_TIM3_SLAVE_MODE(MODE) \
+   (((MODE) == TIM3_SlaveMode_Reset)   || \
+    ((MODE) == TIM3_SlaveMode_Gated)   || \
+    ((MODE) == TIM3_SlaveMode_Trigger) || \
+    ((MODE) == TIM3_SlaveMode_External1))
+ /**
+   * @brief Macro TIM3 Flags
+   */
+ #define IS_TIM3_GET_FLAG(FLAG) \
+   (((FLAG) == TIM3_FLAG_Update)  || \
+    ((FLAG) == TIM3_FLAG_CC1)     || \
+    ((FLAG) == TIM3_FLAG_CC2)     || \
+    ((FLAG) == TIM3_FLAG_Trigger) || \
+    ((FLAG) == TIM3_FLAG_Break)   || \
+    ((FLAG) == TIM3_FLAG_CC1OF)   || \
+    ((FLAG) == TIM3_FLAG_CC2OF))
+ 
+ #define IS_TIM3_CLEAR_FLAG(FLAG) \
+   (((FLAG & (uint16_t)0xF938) == 0x0000) && (FLAG != 0x0000))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup TIM3_Exported_Functions
+   * @{
+   */
+ 
+ void TIM3_DeInit(void);
+ void TIM3_TimeBaseInit(TIM3_Prescaler_TypeDef TIM3_Prescaler,
+                        TIM3_CounterMode_TypeDef TIM3_CounterMode,
+                        uint16_t TIM3_Period);
+ void TIM3_OC1Init(TIM3_OCMode_TypeDef TIM3_OCMode,
+                   TIM3_OutputState_TypeDef TIM3_OutputState,
+                   uint16_t TIM3_Pulse,
+                   TIM3_OCPolarity_TypeDef TIM3_OCPolarity,
+                   TIM3_OCIdleState_TypeDef TIM3_OCIdleState);
+ void TIM3_OC2Init(TIM3_OCMode_TypeDef TIM3_OCMode,
+                   TIM3_OutputState_TypeDef TIM3_OutputState,
+                   uint16_t TIM3_Pulse,
+                   TIM3_OCPolarity_TypeDef TIM3_OCPolarity,
+                   TIM3_OCIdleState_TypeDef TIM3_OCIdleState);
+ void TIM3_BKRConfig(TIM3_OSSIState_TypeDef TIM3_OSSIState,
+                     TIM3_LockLevel_TypeDef TIM3_LockLevel,
+                     TIM3_BreakState_TypeDef TIM3_BreakState,
+                     TIM3_BreakPolarity_TypeDef TIM3_BreakPolarity,
+                     TIM3_AutomaticOutput_TypeDef TIM3_AutomaticOutput);
+ void TIM3_ICInit(TIM3_Channel_TypeDef TIM3_Channel,
+                  TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                  TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                  TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
+                  uint8_t TIM3_ICFilter);
+ void TIM3_PWMIConfig(TIM3_Channel_TypeDef TIM3_Channel,
+                      TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                      TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                      TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
+                      uint8_t TIM3_ICFilter);
+ void TIM3_Cmd(FunctionalState NewState);
+ FunctionalState TIM3_GetStatus(void);
+ void TIM3_CtrlPWMOutputs(FunctionalState NewState);
+ void TIM3_ITConfig(TIM3_IT_TypeDef TIM3_IT,
+                    FunctionalState NewState);
+ void TIM3_InternalClockConfig(void);
+ void TIM3_ETRClockMode1Config(TIM3_ExtTRGPSC_TypeDef
+                               TIM3_ExtTRGPrescaler,
+                               TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
+                               uint8_t TIM3_ExtTRGFilter);
+ void TIM3_ETRClockMode2Config(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
+                               TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
+                               uint8_t TIM3_ExtTRGFilter);
+ void TIM3_ETRConfig(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
+                     TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
+                     uint8_t TIM3_ExtTRGFilter);
+ void TIM3_TIxExternalClockConfig(TIM3_TIxExternalCLK1Source_TypeDef TIM3_TIxExternalCLKSource,
+                                  TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                                  uint8_t TIM3_ICFilter);
+ void TIM3_SelectInputTrigger(TIM3_TRGSelection_TypeDef TIM3_InputTriggerSource);
+ void TIM3_UpdateDisableConfig(FunctionalState Newstate);
+ void TIM3_UpdateRequestConfig(TIM3_UpdateSource_TypeDef TIM3_UpdateSource);
+ void TIM3_SelectHallSensor(FunctionalState Newstate);
+ void TIM3_SelectOnePulseMode(TIM3_OPMode_TypeDef TIM3_OPMode);
+ void TIM3_SelectOutputTrigger(TIM3_TRGOSource_TypeDef TIM3_TRGOSource);
+ void TIM3_SelectSlaveMode(TIM3_SlaveMode_TypeDef TIM3_SlaveMode);
+ void TIM3_SelectMasterSlaveMode(FunctionalState NewState);
+ void TIM3_EncoderInterfaceConfig(TIM3_EncoderMode_TypeDef TIM3_EncoderMode,
+                                  TIM3_ICPolarity_TypeDef TIM3_IC1Polarity,
+                                  TIM3_ICPolarity_TypeDef TIM3_IC2Polarity);
+ void TIM3_PrescalerConfig(TIM3_Prescaler_TypeDef TIM3_Prescaler,
+                           TIM3_PSCReloadMode_TypeDef TIM3_PSCReloadMode);
+ void TIM3_CounterModeConfig(TIM3_CounterMode_TypeDef TIM3_CounterMode);
+ void TIM3_ForcedOC1Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction);
+ void TIM3_ForcedOC2Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction);
+ void TIM3_ARRPreloadConfig(FunctionalState Newstate);
+ void TIM3_OC1PreloadConfig(FunctionalState Newstate);
+ void TIM3_OC2PreloadConfig(FunctionalState Newstate);
+ void TIM3_OC1FastCmd(FunctionalState Newstate);
+ void TIM3_OC2FastCmd(FunctionalState Newstate);
+ void TIM3_GenerateEvent(TIM3_EventSource_TypeDef TIM3_EventSource);
+ void TIM3_OC1PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity);
+ void TIM3_OC2PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity);
+ void TIM3_CCxCmd(TIM3_Channel_TypeDef TIM3_Channel,
+                  FunctionalState Newstate);
+ void TIM3_SelectOCxM(TIM3_Channel_TypeDef TIM3_Channel,
+                      TIM3_OCMode_TypeDef TIM3_OCMode);
+ void TIM3_SetCounter(uint16_t TIM3_Counter);
+ void TIM3_SetAutoreload(uint16_t TIM3_Autoreload);
+ void TIM3_SetCompare1(uint16_t TIM3_Compare);
+ void TIM3_SetCompare2(uint16_t TIM3_Compare);
+ void TIM3_SetIC1Prescaler(TIM3_ICPSC_TypeDef TIM3_IC1Prescaler);
+ void TIM3_SetIC2Prescaler(TIM3_ICPSC_TypeDef TIM3_IC2Prescaler);
+ uint16_t TIM3_GetCapture1(void);
+ uint16_t TIM3_GetCapture2(void);
+ uint16_t TIM3_GetCounter(void);
+ TIM3_Prescaler_TypeDef TIM3_GetPrescaler(void);
+ FlagStatus TIM3_GetFlagStatus(TIM3_FLAG_TypeDef TIM3_FLAG);
+ void TIM3_ClearFlag(TIM3_FLAG_TypeDef TIM3_FLAG);
+ ITStatus TIM3_GetITStatus(TIM3_IT_TypeDef TIM3_IT);
+ void TIM3_ClearITPendingBit(TIM3_IT_TypeDef TIM3_IT);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_TIM3_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim4.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim4.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim4.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_tim4.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,298 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_tim4.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the TIM4
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_TIM4_H
+ #define __STM8L10X_TIM4_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup TIM4_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief TIM4 Prescaler
+   */
+ typedef enum
+ {
+   TIM4_Prescaler_1    = ((uint8_t)0x00), /*!< Time base Prescaler = 1 (No effect)*/
+   TIM4_Prescaler_2     = ((uint8_t)0x01),  /*!< Time base Prescaler = 2 */
+   TIM4_Prescaler_4     = ((uint8_t)0x02),  /*!< Time base Prescaler = 4 */
+   TIM4_Prescaler_8    = ((uint8_t)0x03),  /*!< Time base Prescaler = 8 */
+   TIM4_Prescaler_16    = ((uint8_t)0x04),  /*!< Time base Prescaler = 16 */
+   TIM4_Prescaler_32    = ((uint8_t)0x05),  /*!< Time base Prescaler = 32 */
+   TIM4_Prescaler_64    = ((uint8_t)0x06),  /*!< Time base Prescaler = 64 */
+   TIM4_Prescaler_128   = ((uint8_t)0x07),  /*!< Time base Prescaler = 128 */
+   TIM4_Prescaler_256   = ((uint8_t)0x08),  /*!< Time base Prescaler = 256 */
+   TIM4_Prescaler_512   = ((uint8_t)0x09),  /*!< Time base Prescaler = 512 */
+   TIM4_Prescaler_1024  = ((uint8_t)0x0A),  /*!< Time base Prescaler = 1024 */
+   TIM4_Prescaler_2048  = ((uint8_t)0x0B),  /*!< Time base Prescaler = 2048 */
+   TIM4_Prescaler_4096  = ((uint8_t)0x0C),  /*!< Time base Prescaler = 4096 */
+   TIM4_Prescaler_8192  = ((uint8_t)0x0D),  /*!< Time base Prescaler = 8196 */
+   TIM4_Prescaler_16384 = ((uint8_t)0x0E),  /*!< Time base Prescaler = 16384 */
+   TIM4_Prescaler_32768 = ((uint8_t)0x0F)   /*!< Time base Prescaler = 32768 */
+ }TIM4_Prescaler_TypeDef;
+ 
+ /**
+   * @brief TIM4 One Pulse Mode
+   */
+ typedef enum
+ {
+   TIM4_OPMode_Single    = ((uint8_t)0x01),  /*!< Single one Pulse mode (OPM Active) */
+   TIM4_OPMode_Repetitive  = ((uint8_t)0x00)   /*!< Repetitive Pulse mode (OPM inactive) */
+ }TIM4_OPMode_TypeDef;
+ 
+ /**
+   * @brief TIM4 Prescaler Reload Mode
+   */
+ typedef enum
+ {
+   TIM4_PSCReloadMode_Update     = ((uint8_t)0x00), /*!< Prescaler value is reloaded at every update*/
+   TIM4_PSCReloadMode_Immediate = ((uint8_t)0x01)  /*!< Prescaler value is reloaded immediately*/
+ }TIM4_PSCReloadMode_TypeDef;
+ 
+ /**
+   * @brief TIM4 Update Source
+   */
+ typedef enum
+ {
+   TIM4_UpdateSource_Global = ((uint8_t)0x00), /*!< Global Update request source */
+   TIM4_UpdateSource_Regular = ((uint8_t)0x01)  /*!< Regular Update request source */
+ }TIM4_UpdateSource_TypeDef;
+ 
+ /**
+   * @brief TIM4 Event Source
+   */
+ typedef enum
+ {
+   TIM4_EventSource_Update  = ((uint8_t)0x01),  /*!< Update Event*/
+   TIM4_EventSource_Trigger = ((uint8_t)0x40)  /*!< Trigger Event*/
+ }TIM4_EventSource_TypeDef;
+ 
+ /**
+   * @brief TIM4 Trigger Output Source
+   */
+ typedef enum
+ {
+   TIM4_TRGOSource_Reset  = ((uint8_t)0x00),  /*!< Trigger Output source = Reset*/
+   TIM4_TRGOSource_Enable = ((uint8_t)0x10),  /*!< Trigger Output source = TIM2 is enabled*/
+   TIM4_TRGOSource_Update = ((uint8_t)0x20)  /*!< Trigger Output source = Update event*/
+ }TIM4_TRGOSource_TypeDef;
+ 
+ /**
+   * @brief TIM4 Slave Mode
+   */
+ typedef enum
+ {
+   TIM4_SLAVEMODE_DISABLE  = ((uint8_t)0x00),  /*!< Disable slave mode to clock the prescaler directly with the internal clock */
+   TIM4_SlaveMode_Reset   = ((uint8_t)0x04),  /*!< Slave Mode Selection  = Reset*/
+   TIM4_SlaveMode_Gated   = ((uint8_t)0x05),  /*!< Slave Mode Selection  = Gated*/
+   TIM4_SlaveMode_Trigger  = ((uint8_t)0x06),  /*!< Slave Mode Selection  = Trigger*/
+   TIM4_SlaveMode_External1 = ((uint8_t)0x07)  /*!< Slave Mode Selection  = External 1*/
+ }TIM4_SlaveMode_TypeDef;
+ 
+ /**
+   * @brief TIM4 Flags
+   */
+ typedef enum
+ {
+   TIM4_FLAG_Update = ((uint8_t)0x01),  /*!< Update Flag */
+   TIM4_FLAG_Trigger = ((uint8_t)0x40)  /*!< Trigger Flag */
+ }TIM4_FLAG_TypeDef;
+ 
+ /**
+   * @brief TIM4 interrupt sources
+   */
+ typedef enum
+ {
+   TIM4_IT_Update = ((uint8_t)0x01),  /*!< Update Interrupt*/
+   TIM4_IT_Trigger = ((uint8_t)0x40)  /*!< Trigger  Interrupt*/
+ }TIM4_IT_TypeDef;
+ 
+ /**
+   * @brief TIM4 Internal Trigger Selection
+   */
+ typedef enum
+ {
+   TIM4_TRGSelection_TIM3 = ((uint8_t)0x20),/*!< TRIG Input source =  TIM3 TRIG Output  */
+   TIM4_TRGSelection_TIM2 = ((uint8_t)0x30) /*!< TRIG Input source =  TIM2 TRIG Output  */
+ }TIM4_TRGSelection_TypeDef;
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup TIM4_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro TIM4 Prescaler
+   */
+ #define IS_TIM4_PRESCALER(PRESCALER)  \
+   (((PRESCALER) == TIM4_Prescaler_1)    || \
+    ((PRESCALER) == TIM4_Prescaler_2)    || \
+    ((PRESCALER) == TIM4_Prescaler_4)    || \
+    ((PRESCALER) == TIM4_Prescaler_8)    || \
+    ((PRESCALER) == TIM4_Prescaler_16)   || \
+    ((PRESCALER) == TIM4_Prescaler_32)   || \
+    ((PRESCALER) == TIM4_Prescaler_64)   || \
+    ((PRESCALER) == TIM4_Prescaler_128)  || \
+    ((PRESCALER) == TIM4_Prescaler_256)  || \
+    ((PRESCALER) == TIM4_Prescaler_512)  || \
+    ((PRESCALER) == TIM4_Prescaler_1024) || \
+    ((PRESCALER) == TIM4_Prescaler_2048) || \
+    ((PRESCALER) == TIM4_Prescaler_4096) || \
+    ((PRESCALER) == TIM4_Prescaler_8192) || \
+    ((PRESCALER) == TIM4_Prescaler_16384)|| \
+    ((PRESCALER) == TIM4_Prescaler_32768))
+ /**
+   * @brief Macro TIM4 One Pulse Mode
+   */
+ #define IS_TIM4_OPM_MODE(MODE)  \
+   (((MODE) == TIM4_OPMode_Single) || \
+    ((MODE) == TIM4_OPMode_Repetitive))
+ 
+ /**
+   * @brief Macro TIM4 Prescaler reload
+   */
+ #define IS_TIM4_PRESCALER_RELOAD(RELOAD) \
+   (((RELOAD) == TIM4_PSCReloadMode_Update) || \
+    ((RELOAD) == TIM4_PSCReloadMode_Immediate))
+ /**
+   * @brief Macro TIM4 Update source
+   */
+ #define IS_TIM4_UPDATE_SOURCE(SOURCE) \
+   (((SOURCE) == TIM4_UpdateSource_Global) || \
+    ((SOURCE) == TIM4_UpdateSource_Regular))
+ /**
+   * @brief Macro TIM4 Event source
+   */
+ #define IS_TIM4_EVENT_SOURCE(SOURCE) \
+   (((SOURCE & (uint8_t)0xBE) == 0x00) && \
+    ((SOURCE) != 0x00))
+ 
+ /**
+   * @brief Macro TIM4 TRGO source
+   */
+ #define IS_TIM4_TRGO_SOURCE(SOURCE) \
+   (((SOURCE) == TIM4_TRGOSource_Reset) || \
+    ((SOURCE) == TIM4_TRGOSource_Enable)|| \
+    ((SOURCE) == TIM4_TRGOSource_Update))
+ /**
+   * @brief Macro TIM4 Slave mode
+   */
+ #define IS_TIM4_SLAVE_MODE(MODE) \
+   (((MODE) == TIM4_SLAVEMODE_DISABLE) || \
+    ((MODE) == TIM4_SlaveMode_Reset)   || \
+    ((MODE) == TIM4_SlaveMode_Gated)   || \
+    ((MODE) == TIM4_SlaveMode_Trigger) || \
+    ((MODE) == TIM4_SlaveMode_External1))
+ /**
+   * @brief Macro TIM4 Flags
+   */
+ #define IS_TIM4_GET_FLAG(FLAG) \
+   (((FLAG) == TIM4_FLAG_Update) || \
+    ((FLAG) == TIM4_FLAG_Trigger))
+ 
+ #define IS_TIM4_CLEAR_FLAG(FLAG) \
+   (((FLAG & (uint8_t)0xBE) == 0x00) && (FLAG != 0x00))
+ /**
+   * @brief Macro TIM4 interrupts
+   */
+ #define IS_TIM4_IT(IT) \
+   (((IT) != 0x00) && \
+    (((uint8_t)IT & (uint8_t)(~(uint8_t)(0x41)))== 0x00))
+ 
+ #define IS_TIM4_GET_IT(IT) \
+   (((IT) == TIM4_IT_Update) || \
+    ((IT) == TIM4_IT_Trigger))
+ /**
+   * @brief Macro TIM4 Trigger selection
+   */
+ #define IS_TIM4_TRIGGER_SELECTION(SELECTION) \
+   (((SELECTION) == TIM4_TRGSelection_TIM2) || \
+    ((SELECTION) == TIM4_TRGSelection_TIM3))
+ /**
+  * @}
+  */
+ 
+ /* Exported functions --------------------------------------------------------*/
+ 
+ /** @addtogroup TIM4_Exported_Functions
+   * @{
+   */
+ 
+ void TIM4_DeInit(void);
+ void TIM4_TimeBaseInit(TIM4_Prescaler_TypeDef TIM4_Prescaler,
+                        uint8_t TIM4_Period);
+ void TIM4_Cmd(FunctionalState NewState);
+ void TIM4_ITConfig(TIM4_IT_TypeDef TIM4_IT,
+                    FunctionalState NewState);
+ void TIM4_InternalClockConfig(void);
+ void TIM4_SelectInputTrigger(TIM4_TRGSelection_TypeDef TIM4_InputTriggerSource);
+ void TIM4_UpdateDisableConfig(FunctionalState Newstate);
+ void TIM4_UpdateRequestConfig(TIM4_UpdateSource_TypeDef TIM4_UpdateSource);
+ void TIM4_SelectOnePulseMode(TIM4_OPMode_TypeDef TIM4_OPMode);
+ void TIM4_SelectOutputTrigger(TIM4_TRGOSource_TypeDef TIM4_TRGOSource);
+ void TIM4_SelectSlaveMode(TIM4_SlaveMode_TypeDef TIM4_SlaveMode);
+ void TIM4_SelectMasterSlaveMode(FunctionalState NewState);
+ void TIM4_PrescalerConfig(TIM4_Prescaler_TypeDef Prescaler,
+                           TIM4_PSCReloadMode_TypeDef TIM4_PSCReloadMode);
+ void TIM4_ARRPreloadConfig(FunctionalState Newstate);
+ void TIM4_GenerateEvent(TIM4_EventSource_TypeDef TIM4_EventSource);
+ void TIM4_SetCounter(uint8_t TIM4_Counter);
+ void TIM4_SetAutoreload(uint8_t TIM4_Autoreload);
+ uint8_t TIM4_GetCounter(void);
+ TIM4_Prescaler_TypeDef TIM4_GetPrescaler(void);
+ FunctionalState TIM4_GetStatus(void);
+ FlagStatus TIM4_GetFlagStatus(TIM4_FLAG_TypeDef TIM4_FLAG);
+ void TIM4_ClearFlag(TIM4_FLAG_TypeDef TIM4_FLAG);
+ ITStatus TIM4_GetITStatus(TIM4_IT_TypeDef TIM4_IT);
+ void TIM4_ClearITPendingBit(TIM4_IT_TypeDef TIM4_IT);
+ 
+ /**
+  * @}
+  */
+ 
+ #endif /* __STM8L10X_TIM4_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_usart.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_usart.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_usart.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_usart.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,322 ----
+ /**
+   ********************************************************************************
+   * @file    stm8l10x_usart.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the USART
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_USART_H
+ #define __STM8L10X_USART_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup USART_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief USART Flag possible values
+   */
+ typedef enum { USART_FLAG_TXE   = (uint16_t)0x0080, /*!< Transmit Data Register Empty flag */
+                USART_FLAG_TC    = (uint16_t)0x0040, /*!< Transmission Complete flag */
+                USART_FLAG_RXNE  = (uint16_t)0x0020, /*!< Read Data Register Not Empty flag */
+                USART_FLAG_IDLE  = (uint16_t)0x0010, /*!< Idle line detected flag */
+                USART_FLAG_OR    = (uint16_t)0x0008, /*!< OverRun error flag */
+                USART_FLAG_NF    = (uint16_t)0x0004, /*!< Noise error flag */
+                USART_FLAG_FE    = (uint16_t)0x0002, /*!< Framing Error flag */
+                USART_FLAG_PE    = (uint16_t)0x0001, /*!< Parity Error flag */
+                USART_FLAG_SBK   = (uint16_t)0x0101  /*!< Send Break characters Flag */
+              } USART_FLAG_TypeDef;
+ 
+ /**
+   * @brief USART Interrupt definition
+   * USART_IT possible values
+   * Elements values convention: 0xZYX
+   * X: Position of the corresponding Interrupt
+   * Y: Flag position
+   * Z: Register index
+   */
+ typedef enum { USART_IT_TXE        = (uint16_t)0x0277, /*!< Transmit interrupt */
+                USART_IT_TC         = (uint16_t)0x0266, /*!< Transmission Complete interrupt */
+                USART_IT_RXNE       = (uint16_t)0x0255, /*!< Receive interrupt */
+                USART_IT_IDLE       = (uint16_t)0x0244, /*!< IDLE line interrupt */
+                USART_IT_OR         = (uint16_t)0x0235, /*!< Overrun Error interrupt */
+                USART_IT_PE         = (uint16_t)0x0100 /*!< Parity Error interrupt */
+              } USART_IT_TypeDef;
+ 
+ /**
+   * @brief USART WakeUP Modes
+   */
+ typedef enum
+ {
+   USART_WakeUp_IdleLine      = (uint8_t)0x00, /*!< 0x01 Idle Line wake up */
+   USART_WakeUp_AddressMark    = (uint8_t)0x08  /*!< 0x02 Address Mark wake up */
+ } USART_WakeUp_TypeDef;
+ 
+ /**
+   * @brief USART stop bits possible values
+   */
+ typedef enum
+ {
+   USART_StopBits_1   = (uint8_t)0x00,   /*!< One stop bit is  transmitted at the end of frame */
+   USART_StopBits_2   = (uint8_t)0x20    /*!< Two stop bits are  transmitted at the end of frame */
+ } USART_StopBits_TypeDef;
+ 
+ /**
+   * @brief USART parity possible values
+   */
+ typedef enum
+ {
+   USART_Parity_No   = (uint8_t)0x00,      /*!< No Parity*/
+   USART_Parity_Even = (uint8_t)0x04,      /*!< Even Parity*/
+   USART_Parity_Odd = (uint8_t)0x06       /*!< Odd Parity*/
+ } USART_Parity_TypeDef;
+ 
+ /**
+   * @brief USART Word length possible values
+   */
+ typedef enum
+ {
+   USART_WordLength_8D = (uint8_t)0x00,  /*!< 0x00 8 bits Data */
+   USART_WordLength_9D = (uint8_t)0x10   /*!< 0x10 9 bits Data */
+ } USART_WordLength_TypeDef;
+ 
+ /**
+   * @brief USART Mode possible values
+   */
+ typedef enum
+ {
+   USART_Mode_Rx    = (uint8_t)0x04,  /*!< 0x04 Receive Enable */
+   USART_Mode_Tx    = (uint8_t)0x08   /*!< 0x08 Transmit Enable */
+ } USART_Mode_TypeDef;
+ 
+ /**
+   * @brief USART Clock possible values
+   */
+ typedef enum
+ {
+   USART_Clock_Disable    = (uint8_t)0x00,  /*!< 0x00 SLK pin disabled */
+   USART_Clock_Enable     = (uint8_t)0x08   /*!< 0x08 SLK pin enabled */
+ } USART_Clock_TypeDef;
+ 
+ /**
+   * @brief USART Clock Polarity possible values
+   */
+ typedef enum
+ {
+   USART_CPOL_Low      = (uint8_t)0x00,  /*!< 0x00 SCK to 0 when idle */
+   USART_CPOL_High     = (uint8_t)0x04   /*!< 0x04 SCK to 1 when idle.*/
+ } USART_CPOL_TypeDef;
+ 
+ /**
+   * @brief USART Clock Phase possible values
+   */
+ typedef enum
+ {
+   USART_CPHA_1Edge     = (uint8_t)0x00,  /*!< 0x00 The first clock transition is the first data capture edge*/
+   USART_CPHA_2Edge     = (uint8_t)0x02   /*!< 0x02 The second clock transition is the first data capture edge*/
+ } USART_CPHA_TypeDef;
+ 
+ /**
+   * @brief USART Last Bit possible values
+   */
+ typedef enum
+ {
+   USART_LastBit_Disable  = (uint8_t)0x00,  /*!< 0x00 The clock pulse of the last data bit is not output to the SCLK pin.*/
+   USART_LastBit_Enable   = (uint8_t)0x01   /*!< 0x02 The clock pulse of the last data bit is output to the SCLK pin.*/
+ } USART_LastBit_TypeDef;
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup USART_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function to check the different functions parameters.
+   */
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values
+   *  for the FLAGs
+   */
+ #define IS_USART_FLAG(Flag) (((Flag) == USART_FLAG_TXE) || \
+                              ((Flag) == USART_FLAG_TC)  || \
+                              ((Flag) == USART_FLAG_RXNE) || \
+                              ((Flag) == USART_FLAG_IDLE) || \
+                              ((Flag) == USART_FLAG_OR) || \
+                              ((Flag) == USART_FLAG_NF) || \
+                              ((Flag) == USART_FLAG_FE) || \
+                              ((Flag) == USART_FLAG_PE) || \
+                              ((Flag) == USART_FLAG_SBK))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values
+   * for the Interrupts
+   */
+ 
+ #define IS_USART_CONFIG_IT(Interrupt) (((Interrupt) == USART_IT_PE) || \
+                                        ((Interrupt) == USART_IT_TXE) || \
+                                        ((Interrupt) == USART_IT_TC) || \
+                                        ((Interrupt) == USART_IT_RXNE ) || \
+                                        ((Interrupt) == USART_IT_OR) || \
+                                        ((Interrupt) == USART_IT_IDLE))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values
+  *  for the pending bit
+   */
+ #define IS_USART_GET_IT(ITPendingBit) (((ITPendingBit) == USART_IT_TXE)  || \
+                                        ((ITPendingBit) == USART_IT_TC)   || \
+                                        ((ITPendingBit) == USART_IT_RXNE) || \
+                                        ((ITPendingBit) == USART_IT_IDLE) || \
+                                        ((ITPendingBit) == USART_IT_OR)  || \
+                                        ((ITPendingBit) == USART_IT_PE))
+ 
+ /**
+  * @brief Macro used by the assert function in order to check the different sensitivity values for the MODEs
+  * possible combination should be one of the following
+  */
+ #define IS_USART_MODE(MODE) ((((MODE) & (uint8_t)0xF3) == 0x00) && ((MODE) != (uint16_t)0x00))
+ 
+ /**
+  * @brief Macro used by the assert function in order to check the different sensitivity values for the
+  *  Word Lengths
+  */
+ #define IS_USART_WordLength(WordLength)(((WordLength) == USART_WordLength_8D) || \
+                                         ((WordLength) == USART_WordLength_9D))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values
+   *  for the USART Clock
+   */
+ #define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||((CLOCK) == USART_Clock_Enable))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values
+   *  for the USART Clock Polarity
+   */
+ #define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values
+  *  for the USART Clock Phase
+   */
+ #define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
+ 
+ /**
+   * @brief Macro used by the assert_param function in order to check the different sensitivity values
+   *  for the USART Last Bit
+   */
+ #define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
+                                    ((LASTBIT) == USART_LastBit_Enable))
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values
+  *  for the WakeUps
+   */
+ #define IS_USART_WAKEUP(WakeUpMode)(((WakeUpMode) == USART_WakeUp_IdleLine) || \
+                                     ((WakeUpMode) == USART_WakeUp_AddressMark))
+ 
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different sensitivity values
+   *  for the USART_StopBits
+   */
+ #define IS_USART_STOPBITS(StopBit)(((StopBit) == USART_StopBits_1) || \
+                                    ((StopBit) == USART_StopBits_2))
+ 
+ /**
+  * @brief Macro used by the assert function in order to check the different sensitivity values
+  *  for the Paritys
+  */
+ #define IS_USART_PARITY(Parity)(((Parity) == USART_Parity_No)   || \
+                                 ((Parity) == USART_Parity_Even) || \
+                                 ((Parity) == USART_Parity_Odd ))
+ 
+ /* BaudRate value should be < 625000 bps */
+ #define IS_USART_BAUDRATE(NUM) ((NUM) <= (uint32_t)625000)
+ 
+ /**
+  * @brief Macro used by the assert function in order to check the different sensitivity values
+  *  for the node address
+  */
+ #define USART_ADDRESS_MAX ((uint8_t)16)
+ #define IS_USART_ADDRESS(address) ((address) < USART_ADDRESS_MAX)
+ 
+ /**
+  * @brief Macro used by the assert function in order to check the different sensitivity values
+  *  for the data
+  */
+ 
+ #define USART_DATA_9BITS_MAX ((uint16_t)0x1FF)
+ #define IS_USART_DATA_9BITS(DATA) ((DATA) < USART_DATA_9BITS_MAX)
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ /** @addtogroup USART_Exported_functions
+   * @{
+   */
+ 
+ void USART_DeInit(void);
+ void USART_Init(uint32_t BaudRate, USART_WordLength_TypeDef USART_WordLength, USART_StopBits_TypeDef
+                 USART_StopBits, USART_Parity_TypeDef USART_Parity, USART_Mode_TypeDef USART_Mode);
+ void USART_ClockInit(USART_Clock_TypeDef USART_Clock, USART_CPOL_TypeDef USART_CPOL,
+                      USART_CPHA_TypeDef USART_CPHA, USART_LastBit_TypeDef USART_LastBit);
+ void USART_Cmd(FunctionalState NewState);
+ void USART_ITConfig(USART_IT_TypeDef USART_IT, FunctionalState NewState);
+ uint8_t USART_ReceiveData8(void);
+ uint16_t USART_ReceiveData9(void);
+ void USART_ReceiverWakeUpCmd(FunctionalState NewState);
+ void USART_SendBreak(void);
+ void USART_SendData8(uint8_t Data);
+ void USART_SendData9(uint16_t Data);
+ void USART_SetAddress(uint8_t Address);
+ void USART_WakeUpConfig(USART_WakeUp_TypeDef USART_WakeUp);
+ FlagStatus USART_GetFlagStatus(USART_FLAG_TypeDef USART_FLAG);
+ void USART_ClearFlag(void);
+ ITStatus USART_GetITStatus(USART_IT_TypeDef USART_IT);
+ void USART_ClearITPendingBit(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_USART_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_wfe.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_wfe.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_wfe.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/inc/stm8l10x_wfe.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,112 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_wfe.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all functions prototypes and macros for the WFE 
+   *          peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10X_WFE_H
+ #define __STM8L10X_WFE_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported variables ------------------------------------------------------- */
+ /* Exported types ------------------------------------------------------------*/
+ 
+ /** @addtogroup WFE_Exported_Types
+   * @{
+   */
+ 
+ /**
+   * @brief Signal Sources to generate wake_up events
+   */
+ typedef enum {
+   WFE_Source_TIM2_EV0   = (uint16_t)0x0101, /*!< Tim2 Upadte/Trigger and Break interrupt */
+   WFE_Source_TIM2_EV1   = (uint16_t)0x0102, /*!< Tim2 Capture/Compare interrupt          */
+   WFE_Source_EXTI_EV0   = (uint16_t)0x0110, /*!< I/O port interrupt from Pins 0          */
+   WFE_Source_EXTI_EV1   = (uint16_t)0x0120, /*!< I/O port interrupt from Pins 1          */
+   WFE_Source_EXTI_EV2   = (uint16_t)0x0140, /*!< I/O port interrupt from Pins 2          */
+   WFE_Source_EXTI_EV3   = (uint16_t)0x0180, /*!< I/O port interrupt from Pins 3          */
+   WFE_Source_EXTI_EV4   = (uint16_t)0x0201, /*!< I/O port interrupt from Pins 4          */
+   WFE_Source_EXTI_EV5   = (uint16_t)0x0202, /*!< I/O port interrupt from Pins 5          */
+   WFE_Source_EXTI_EV6   = (uint16_t)0x0204, /*!< I/O port interrupt from Pins 6          */
+   WFE_Source_EXTI_EV7   = (uint16_t)0x0208, /*!< I/O port interrupt from Pins 7          */
+   WFE_Source_EXTI_EVB   = (uint16_t)0x0210, /*!< I/O port interrupt from port B          */
+   WFE_Source_EXTI_EVD   = (uint16_t)0x0220 /*!< I/O port interrupt from Pins D          */
+ } WFE_Source_TypeDef;
+ 
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macros -----------------------------------------------------------*/
+ /* Private macros ------------------------------------------------------------*/
+ 
+ /** @addtogroup WFE_Private_Macros
+   * @{
+   */
+ 
+ /**
+   * @brief Macro used by the assert function in order to check the different IRQ values
+   */
+ 
+ #define IS_WFE_SOURCE_OK(Source) (((Source) == WFE_Source_TIM2_EV0) || \
+                                   ((Source) == WFE_Source_TIM2_EV1) || \
+                                   ((Source) == WFE_Source_EXTI_EV0) || \
+                                   ((Source) == WFE_Source_EXTI_EV1) || \
+                                   ((Source) == WFE_Source_EXTI_EV2) || \
+                                   ((Source) == WFE_Source_EXTI_EV3) || \
+                                   ((Source) == WFE_Source_EXTI_EV4) || \
+                                   ((Source) == WFE_Source_EXTI_EV5) || \
+                                   ((Source) == WFE_Source_EXTI_EV6) || \
+                                   ((Source) == WFE_Source_EXTI_EV7) || \
+                                   ((Source) == WFE_Source_EXTI_EVB) || \
+                                   ((Source) == WFE_Source_EXTI_EVD))
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported functions ------------------------------------------------------- */
+ 
+ /** @addtogroup WFE_Exported_Functions
+   * @{
+   */
+ 
+ void WFE_DeInit(void);
+ void WFE_WakeUpSourceEventCmd(WFE_Source_TypeDef WFE_Source, FunctionalState NewState);
+ FunctionalState WFE_GetWakeUpSourceEventStatus(WFE_Source_TypeDef WFE_Source);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L10X_WFE_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/Release_Notes.html ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/Release_Notes.html
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/Release_Notes.html	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/Release_Notes.html	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,412 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+ <html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+ <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+ <link rel="File-List" href="Release_Notes_files/filelist.xml">
+ <link rel="Edit-Time-Data" href="Release_Notes_files/editdata.mso"><!--[if !mso]>
+ <style>
+ v\:* {behavior:url(#default#VML);}
+ o\:* {behavior:url(#default#VML);}
+ w\:* {behavior:url(#default#VML);}
+ .shape {behavior:url(#default#VML);}
+ </style>
+ <![endif]-->
+ 
+ 
+ 
+ <title>Release Notes for STM8L10x Standard Peripherals Drivers</title><!--[if gte mso 9]><xml>
+  <o:DocumentProperties>
+   <o:Author>STMicroelectronics</o:Author>
+   <o:LastAuthor>jaziric</o:LastAuthor>
+   <o:Revision>41</o:Revision>
+   <o:TotalTime>195</o:TotalTime>
+   <o:Created>2009-02-27T19:26:00Z</o:Created>
+   <o:LastSaved>2009-06-19T16:40:00Z</o:LastSaved>
+   <o:Pages>1</o:Pages>
+   <o:Words>476</o:Words>
+   <o:Characters>2714</o:Characters>
+   <o:Company>STMicroelectronics</o:Company>
+   <o:Lines>22</o:Lines>
+   <o:Paragraphs>6</o:Paragraphs>
+   <o:CharactersWithSpaces>3184</o:CharactersWithSpaces>
+   <o:Version>11.8132</o:Version>
+  </o:DocumentProperties>
+ </xml><![endif]--><!--[if gte mso 9]><xml>
+  <w:WordDocument>
+   <w:Zoom>110</w:Zoom>
+   <w:ValidateAgainstSchemas/>
+   <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
+   <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
+   <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
+   <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
+  </w:WordDocument>
+ </xml><![endif]--><!--[if gte mso 9]><xml>
+  <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
+  </w:LatentStyles>
+ </xml><![endif]--><style>
+ <!--
+  /* Font Definitions */
+  @font-face
+ 	{font-family:Wingdings;
+ 	panose-1:5 0 0 0 0 0 0 0 0 0;
+ 	mso-font-charset:2;
+ 	mso-generic-font-family:auto;
+ 	mso-font-pitch:variable;
+ 	mso-font-signature:0 268435456 0 0 -2147483648 0;}
+ @font-face
+ 	{font-family:Tahoma;
+ 	panose-1:2 11 6 4 3 5 4 4 2 4;
+ 	mso-font-charset:0;
+ 	mso-generic-font-family:swiss;
+ 	mso-font-pitch:variable;
+ 	mso-font-signature:1627421319 -2147483648 8 0 66047 0;}
+ @font-face
+ 	{font-family:Verdana;
+ 	panose-1:2 11 6 4 3 5 4 4 2 4;
+ 	mso-font-charset:0;
+ 	mso-generic-font-family:swiss;
+ 	mso-font-pitch:variable;
+ 	mso-font-signature:536871559 0 0 0 415 0;}
+  /* Style Definitions */
+  p.MsoNormal, li.MsoNormal, div.MsoNormal
+ 	{mso-style-parent:"";
+ 	margin:0cm;
+ 	margin-bottom:.0001pt;
+ 	mso-pagination:widow-orphan;
+ 	font-size:12.0pt;
+ 	font-family:"Times New Roman";
+ 	mso-fareast-font-family:"Times New Roman";}
+ h1
+ 	{mso-margin-top-alt:auto;
+ 	margin-right:0cm;
+ 	mso-margin-bottom-alt:auto;
+ 	margin-left:0cm;
+ 	mso-pagination:widow-orphan;
+ 	mso-outline-level:1;
+ 	font-size:24.0pt;
+ 	font-family:"Times New Roman";
+ 	font-weight:bold;}
+ h2
+ 	{mso-style-next:Normal;
+ 	margin-top:12.0pt;
+ 	margin-right:0cm;
+ 	margin-bottom:3.0pt;
+ 	margin-left:0cm;
+ 	mso-pagination:widow-orphan;
+ 	page-break-after:avoid;
+ 	mso-outline-level:2;
+ 	font-size:14.0pt;
+ 	font-family:Arial;
+ 	font-weight:bold;
+ 	font-style:italic;}
+ h3
+ 	{mso-margin-top-alt:auto;
+ 	margin-right:0cm;
+ 	mso-margin-bottom-alt:auto;
+ 	margin-left:0cm;
+ 	mso-pagination:widow-orphan;
+ 	mso-outline-level:3;
+ 	font-size:13.5pt;
+ 	font-family:"Times New Roman";
+ 	font-weight:bold;}
+ a:link, span.MsoHyperlink
+ 	{color:blue;
+ 	text-decoration:underline;
+ 	text-underline:single;}
+ a:visited, span.MsoHyperlinkFollowed
+ 	{color:blue;
+ 	text-decoration:underline;
+ 	text-underline:single;}
+ p
+ 	{mso-margin-top-alt:auto;
+ 	margin-right:0cm;
+ 	mso-margin-bottom-alt:auto;
+ 	margin-left:0cm;
+ 	mso-pagination:widow-orphan;
+ 	font-size:12.0pt;
+ 	font-family:"Times New Roman";
+ 	mso-fareast-font-family:"Times New Roman";}
+ @page Section1
+ 	{size:612.0pt 792.0pt;
+ 	margin:72.0pt 90.0pt 72.0pt 90.0pt;
+ 	mso-header-margin:36.0pt;
+ 	mso-footer-margin:36.0pt;
+ 	mso-paper-source:0;}
+ div.Section1
+ 	{page:Section1;}
+  /* List Definitions */
+  @list l0
+ 	{mso-list-id:9796538;
+ 	mso-list-template-ids:-578660166;}
+ @list l0:level1
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0A7;
+ 	mso-level-tab-stop:36.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Wingdings;}
+ @list l0:level2
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0A7;
+ 	mso-level-tab-stop:72.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Wingdings;}
+ @list l0:level3
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:-;
+ 	mso-level-tab-stop:90.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Tahoma;
+ 	mso-bidi-font-family:"Times New Roman";}
+ @list l0:level4
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0A7;
+ 	mso-level-tab-stop:144.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Wingdings;}
+ @list l0:level5
+ 	{mso-level-tab-stop:180.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l0:level6
+ 	{mso-level-tab-stop:216.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l0:level7
+ 	{mso-level-tab-stop:252.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l0:level8
+ 	{mso-level-tab-stop:288.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l0:level9
+ 	{mso-level-tab-stop:324.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1
+ 	{mso-list-id:100951386;
+ 	mso-list-template-ids:-409928590;}
+ @list l1:level1
+ 	{mso-level-tab-stop:36.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level2
+ 	{mso-level-tab-stop:72.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level3
+ 	{mso-level-tab-stop:108.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level4
+ 	{mso-level-tab-stop:144.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level5
+ 	{mso-level-tab-stop:180.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level6
+ 	{mso-level-tab-stop:216.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level7
+ 	{mso-level-tab-stop:252.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level8
+ 	{mso-level-tab-stop:288.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l1:level9
+ 	{mso-level-tab-stop:324.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l2
+ 	{mso-list-id:850606961;
+ 	mso-list-template-ids:1018443040;}
+ @list l2:level1
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0A7;
+ 	mso-level-tab-stop:36.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Wingdings;}
+ @list l2:level2
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0A7;
+ 	mso-level-tab-stop:72.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Wingdings;}
+ @list l2:level3
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0A7;
+ 	mso-level-tab-stop:108.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Wingdings;}
+ @list l2:level4
+ 	{mso-level-tab-stop:144.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l2:level5
+ 	{mso-level-tab-stop:180.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l2:level6
+ 	{mso-level-tab-stop:216.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l2:level7
+ 	{mso-level-tab-stop:252.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l2:level8
+ 	{mso-level-tab-stop:288.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ @list l2:level9
+ 	{mso-level-tab-stop:324.0pt;
+ 	mso-level-number-position:left;
+ 	text-indent:-18.0pt;}
+ ol
+ 	{margin-bottom:0cm;}
+ ul
+ 	{margin-bottom:0cm;}
+ -->
+ </style><!--[if gte mso 10]>
+ <style>
+  /* Style Definitions */
+  table.MsoNormalTable
+ 	{mso-style-name:"Table Normal";
+ 	mso-tstyle-rowband-size:0;
+ 	mso-tstyle-colband-size:0;
+ 	mso-style-noshow:yes;
+ 	mso-style-parent:"";
+ 	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
+ 	mso-para-margin:0cm;
+ 	mso-para-margin-bottom:.0001pt;
+ 	mso-pagination:widow-orphan;
+ 	font-size:10.0pt;
+ 	font-family:"Times New Roman";
+ 	mso-ansi-language:#0400;
+ 	mso-fareast-language:#0400;
+ 	mso-bidi-language:#0400;}
+ </style>
+ <![endif]--><!--[if gte mso 9]><xml>
+  <o:shapedefaults v:ext="edit" spidmax="8194"/>
+ </xml><![endif]--><!--[if gte mso 9]><xml>
+  <o:shapelayout v:ext="edit">
+   <o:idmap v:ext="edit" data="1"/>
+  </o:shapelayout></xml><![endif]--></head>
+ <body style="" link="blue" vlink="blue">
+ 
+ <div class="Section1">
+ 
+ <p class="MsoNormal"><span style="font-family: Arial;"><br>
+ </span><a href="../../../DOC/Others/FWLib/CHM_Generator/Library_html/index.html"></a><span style="font-family: Arial;"><o:p></o:p></span></p>
+ 
+ <div align="center">
+ 
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+  <tbody><tr style="">
+   <td style="padding: 0cm;" valign="top">
+   <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+    <tbody><tr style="">
+     <td style="padding: 1.5pt;">
+     <h1 style="margin-bottom: 18pt; text-align: center;" align="center"><span style="font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);">Release Notes
+     for STM8L10x Standard Peripheral Drivers</span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span></h1>
+     <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;">Copyright  2014
+     STMicroelectronics</span><span style="color: black;"><u1:p></u1:p><o:p></o:p></span></p>
+     <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;"><img alt="" id="_x0000_i1025" src="../../_htmresc/st_logo.png" style="border: 0px solid ; width: 86px; height: 65px;"></span><span style="font-size: 10pt;"><o:p></o:p></span></p>
+     </td>
+    </tr>
+   </tbody></table>
+   <p class="MsoNormal"><span style="font-family: Arial; display: none;"><o:p>&nbsp;</o:p></span></p>
+   <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+    <tbody><tr style="">
+     <td style="padding: 0cm;" valign="top">
+     <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;">Contents<o:p></o:p></span></h2>
+     <ol style="margin-top: 0cm;" start="1" type="1">
+      <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#History">Update History</a><o:p></o:p></span></li>
+      <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#License">License</a><o:p></o:p></span></li>
+     </ol>
+     <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="History"></a><span style="font-size: 12pt; color: white;">Update History<o:p></o:p></span></h2>
+     
+     <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt; width: 200px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.2.1 / &nbsp;30-September-2014<o:p></o:p></span></h3>
+     <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Main changes<o:p></o:p></span></u></li></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 86.95pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p>
+     <ul style="list-style-type: disc;"><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x_flash.c/.h</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;">Update timeout variable declaration&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">on 16 bit instead of 32 bit </span><span style="font-size: 10pt; font-family: Verdana;">in </span><span style="font-size: 10pt; font-family: Verdana;">the FLASH_WaitForLastOperation() function</span><span style="font-size: 10pt; font-family: Verdana;"> </span><span style="font-size: 10pt; font-family: Verdana;">to avoid&nbsp;__ramfunc issue with IAR.</span></li></ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x_rst.c/.h</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;"></span>Update the RST_GetFlagStatus() function implementation to return the state SET/RESET.&nbsp;</span></li></ul></ul><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt; width: 200px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.2.0 / &nbsp;01-June-2012<o:p></o:p></span></h3>
+     <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Main changes<o:p></o:p></span></u></li></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 86.95pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p>
+     <ul style="list-style-type: disc;"><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x.h</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;">Remove SWIM structure declaration</span></li></ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x_i2c.c/.h</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;"></span>Update I2C driver with&nbsp;more functional description and add new functions:</span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_Flag_TypeDef definition</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update IS_I2C_CLEAR_FLAG_OK macro definition</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_Event_TypeDef definition and naming</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_ITPendingBit_TypeDef definition</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_GetITStatus() function to check on the interrupt configuration bits</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add defines for REGISTER_Mask, REGISTER_SR1_Index, REGISTER_SR2_Index, FLAG_Mask and ITEN_Mask</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_ClearFlag() function to clear only the flags that are cleared by writing 0</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add IS_I2C_CLEAR_ITPENDINGBIT_OK macro</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_ClearITPendingBit() function to clear only the flags that are cleared by writing 0</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_GetFlagStatus() function</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add new function I2C_GetLastEvent()</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Update I2C_CheckEvent() function<br></span></li></ul></ul></ul><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt; width: 200px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.1.2 / &nbsp;30-May-2011<o:p></o:p></span></h3>
+     <ul style="margin-top: 0cm;" type="square">
+      <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Main changes<o:p></o:p></span></u></li>
+ 
+     </ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 86.95pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p>
+     <ul style="list-style-type: disc;"><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x.h</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;">Add IAR compiler definition and support</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add CONST, EEPROM and MEMCPY definition for the supported toolchains</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add RAM_EXECUTION define to handle&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">function execution from 
+ RAM</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add interrupts macro definitions for IAR compiler</span><span style="font-size: 10pt; font-family: Verdana;"></span></li><li><span style="font-size: 10pt; font-family: Verdana;">Add "INTERRUPT_HANDLER" macro&nbsp;to manage&nbsp;interrupt vector declarations for all supported toochains</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Remove AWU_CSR_MR bit definition</span></li></ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x_awu.c/.h</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;"></span>Update AWU_LSICalibrationConfig() function by </span><span style="font-size: 10pt; font-family: Verdana;">removing AWU_CSR_MR bit&nbsp;call</span></li><li><span style="font-size: 10pt; font-family: Verdana;">Remove&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">AWU_ReInitCounter() function</span></li></ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x_beep.c</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;"></span>Update BEEP_LSICalibrationConfig() function by </span><span style="font-size: 10pt; font-family: Verdana;">removing AWU_CSR_MR bit&nbsp;call</span></li></ul><li><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">stm8l10x_flash.c/.h</span></span></li><ul><li><span style="font-size: 10pt; font-family: Verdana;">Update Flash driver to support IAR and Raisonance Compilers</span></li><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">Add 
+ detailed description of&nbsp;execution from RAM using functions provided by this 
+ driver and with the different supported toolchains. For more information, refer 
+ to stm8l10x_flash.h and&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">stm8l10x_flash</span><span style="font-size: 10pt; font-family: Verdana;">.c files.</span></li></ul></ul><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt; width: 200px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.1.1 / &nbsp;15-September-2010<o:p></o:p></span></h3>
+     <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Main changes<o:p></o:p></span></u></li></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 86.95pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p>
+     <ul style="list-style-type: circle;"><li><span style="font-size: 10pt; font-family: Verdana;">stm8l10x.h and stm8l10x_gpio.h modified for&nbsp;</span><span style="font-size: 10pt; font-family: Verdana; color: black;">compliancy with
+     IAR compiler. Needed for the STM8 TouchSensing firmware examples.</span></li></ul><p class="MsoNormal">&nbsp; &nbsp; &nbsp; &nbsp; </p><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.1.0 / 14-September-2009<o:p></o:p></span></h3>
+     <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana; text-decoration: underline;">Main changes</span></li></ul>
+     <ul style="list-style-type: circle;"><li class="MsoNormal" style="font-family: Verdana;"><span style="font-size: 10pt;">stm8l10x_tim2.h:&nbsp;</span><span style="font-size: 10pt; color: black;">Change "TIM2_SelectTI1XORInput" function name to&nbsp;"TIM2_SelectHallSensor"</span></li><li class="MsoNormal" style="font-family: Verdana;"><span style="font-size: 10pt; color: black;"></span><span style="font-size: 10pt;">stm8l10x_tim3.h:&nbsp;</span><span style="font-size: 10pt; color: black;">Change "TIM3_SelectTI1XORInput" function name to&nbsp;"TIM3_SelectHallSensor"</span></li><li><span class="MsoNormal" style="font-size: 10pt; font-family: Verdana;">stm8l10x_exti.h: </span><span class="MsoNormal" style="font-size: 10pt; color: black; font-family: Verdana;">Change "EXTI_Sensitivity_TypeDef" enumeration name to&nbsp;"EXTI_Trigger_TypeDef"</span><span style="font-family: Verdana;">
+     </span><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"><span style="font-family: Verdana;">&nbsp;</span><span style="font-family: monospace;">&nbsp;</span>&nbsp;&nbsp;</span></span></span></li></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 86.95pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p><span style="font-size: 10pt; font-family: Verdana; color: black;"></span> &nbsp; &nbsp; &nbsp; &nbsp;<br><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;"></span><p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 122.95pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p><h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="License"></a><span style="font-size: 12pt; color: white;">License<o:p></o:p></span></h2><p class="MsoNormal" style="margin-right: 4cm; line-height: normal; text-align: left;"><span style="font-size: 10pt; color: black;">Licensed under MCD-ST Liberty SW License Agreement V2, (the "License").
+ You may not use this file except in compliance with the License.
+ You may obtain a copy of the License at:
+ 
+ 
+ </span></p>
+ <p class="MsoNormal" style="line-height: normal; text-align: center;"><span style="font-size: 10pt;">
+ <a href="http://www.st.com/software_license_agreement_liberty_v2"> http://www.st.com/software_license_agreement_liberty_v2</a></span></p>
+ <p class="MsoNormal" style="margin-right: 4cm; line-height: normal; text-align: left;"><span style="font-size: 10pt; color: black;">Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ </span></p><p class="MsoNormal"><b><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></b></p>
+     <p class="MsoNormal"><span style="color: black;"><o:p>&nbsp;</o:p></span></p>
+     <div class="MsoNormal" style="text-align: center;" align="center"><span style="color: black;">
+     <hr align="center" size="2" width="100%">
+     </span></div>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt; text-align: center;" align="center"><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Arial;">For complete documentation
+         on STM8L10x 8-bit microcontrollers platform visit <span style="color: blue;"><a href="http://www.st.com/internet/mcu/subclass/1381.jsp" target="_blank">STM8L
+         family web site</a></span></span><u><span style="font-size: 10pt; font-family: Verdana; color: black;"><br>
+     </span></u><u><span style="font-size: 10pt; font-family: Verdana; color: blue;"><a href="http://www.st.com/stm32" target="_blank"></a></span></u><span style="color: black;"><o:p></o:p></span></p>
+     </td>
+    </tr>
+    <tr style="">
+     <td style="padding: 0cm;" valign="top">
+     <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;"><o:p>&nbsp;</o:p></span></h2>
+     </td>
+    </tr>
+   </tbody></table>
+   <p class="MsoNormal"><span style="font-size: 10pt;"><o:p></o:p></span></p>
+   </td>
+  </tr>
+ </tbody></table>
+ 
+ </div>
+ 
+ <p class="MsoNormal"><o:p>&nbsp;</o:p></p>
+ 
+ </div>
+ 
+ </body></html>
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_awu.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_awu.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_awu.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_awu.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,203 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_awu.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the AWU peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_awu.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+   
+ /** @defgroup AWU 
+   * @brief AWU driver modules
+   * @{
+   */ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /* See also AWU_Timebase_TypeDef structure in stm8l10x_awu.h file :
+                           N   2   5   1   2   4   8   1   3   6   1   2   5   1   2   1   3
+                           O   5   0   m   m   m   m   6   2   4   2   5   1   s   s   2   0
+                           I   0   0   s   s   s   s   m   m   m   8   6   2           s   s
+                           T   u   u                   s   s   s   m   m   m
+                               s   s                               s   s   s
+ */
+ 
+ /** Contains the different values to write in the APR register (used by AWU_Init function) */
+ /* the following values are calculated for LSI =  32 kHz */
+ CONST uint8_t APR_Array[17] = {0, 8, 16, 32, 62, 62, 62, 62, 62, 62, 62, 62, 62, 61, 61, 36, 14};
+ 
+ /** Contains the different values to write in the TBR register (used by AWU_Init function) */
+ CONST uint8_t TBR_Array[17] = {0,  1,  1,  1, 1,  2,  3,  4,  5,  6, 7,  8,  9, 10, 11, 14, 15};
+ 
+ 
+ 
+ /**
+   * @addtogroup AWU_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the AWU peripheral registers to their default reset values.
+   * @param  None
+   * @retval None
+   */
+ void AWU_DeInit(void)
+ {
+   AWU->CSR = AWU_CSR_RESET_VALUE;
+   AWU->APR = AWU_APR_RESET_VALUE;
+   AWU->TBR = AWU_TBR_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Initializes the AWU peripheral according to the specified parameters.
+   * @note   The LS RC calibration must be performed before calling this function.
+   * @param  AWU_TimeBase Time base selection (interval between AWU interrupts).
+   * @retval None
+   */
+ void AWU_Init(AWU_Timebase_TypeDef AWU_TimeBase)
+ {
+   /* Check parameter */
+   assert_param(IS_AWU_TIMEBASE(AWU_TimeBase));
+ 
+   /* Enable the AWU peripheral */
+   AWU->CSR |= AWU_CSR_AWUEN;
+ 
+   /* Set the TimeBase */
+   AWU->TBR &= (uint8_t)(~AWU_TBR_AWUTB);
+   AWU->TBR |= TBR_Array[(uint8_t)AWU_TimeBase];
+ 
+   /* Set the APR divider */
+   AWU->APR &= (uint8_t)(~AWU_APR_APR);
+   AWU->APR |= APR_Array[(uint8_t)AWU_TimeBase];
+ 
+ }
+ 
+ /**
+   * @brief  Enable or disable the AWU peripheral.
+   * @param  NewState Indicates the new state of the AWU peripheral.
+   * @retval None
+   * @note The initialisation of AWU and LS RC calibration must be done before.
+   */
+ void AWU_Cmd(FunctionalState NewState)
+ {
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the AWU peripheral */
+     AWU->CSR |= AWU_CSR_AWUEN;
+   }
+   else
+   {
+     /* Disable the AWU peripheral */
+     AWU->CSR &= (uint8_t)(~AWU_CSR_AWUEN);
+   }
+ }
+ 
+ /**
+   * @brief  Update APR register with the measured LSI frequency.
+   * @note   AWU must be disabled to avoid unwanted interrupts.
+   * @note   Prescaler calculation:
+   *         A is the integer part of LSIFreqkHz/4 and x the decimal part.
+   *         x <= A/(1+2A) is equivalent to A >= x(1+2A)
+   *         and also to 4A >= 4x(1+2A) [F1]
+   *         but we know that A + x = LSIFreqkHz/4 ==> 4x = LSIFreqkHz-4A
+   *         so [F1] can be written :
+   *         4A >= (LSIFreqkHz-4A)(1+2A)
+   * @param  LSIFreqHz Low Speed RC frequency measured by timer (in Hz).
+   * @retval None
+   */
+ void AWU_LSICalibrationConfig(uint32_t LSIFreqHz)
+ {
+ 
+   uint16_t lsifreqkhz = 0x0;
+   uint16_t A = 0x0;
+ 
+   /* Check parameter */
+   assert_param(IS_LSI_FREQUENCY(LSIFreqHz));
+ 
+   lsifreqkhz = (uint16_t)(LSIFreqHz / 1000); /* Converts value in kHz */
+ 
+   /* Calculation of AWU calibration value */
+ 
+   A = (uint16_t)(lsifreqkhz >> 2U); /* Division by 4, keep integer part only */
+ 
+   if ((4U * A) >= ((lsifreqkhz - (4U * A)) *(1U + (2U * A))))
+   {
+     AWU->APR = (uint8_t)(A - 2U);
+   }
+   else
+   {
+     AWU->APR = (uint8_t)(A - 1U);
+   }
+ 
+ }
+ 
+ /**
+   * @brief  Configures AWU in Idle mode to reduce power consumption.
+   * @param  None
+   * @retval None
+   */
+ void AWU_IdleModeEnable(void)
+ {
+ 
+   /* Disable AWU peripheral */
+   AWU->CSR &= (uint8_t)(~AWU_CSR_AWUEN);
+ 
+   /* No AWU timebase */
+   AWU->TBR = (uint8_t)(~AWU_TBR_AWUTB);
+ 
+ }
+ 
+ /**
+   * @brief  Returns status of the AWU peripheral flag.
+   * @param  None
+   * @retval FlagStatus Status of the AWU flag.
+   */
+ FlagStatus AWU_GetFlagStatus(void)
+ {
+   return((FlagStatus)(((uint8_t)(AWU->CSR & AWU_CSR_AWUF) == (uint8_t)0x00) ? RESET : SET));
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_beep.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_beep.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_beep.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_beep.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,229 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_beep.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file provides firmware functions to manage the following 
+   *          functionalities of the BEEPER (BEEP) peripheral:           
+   *           - Initialization and Configuration
+   *           - Low Speed Internal Clock(LSI) Calibration
+   *
+   *  @verbatim  
+   *          ===================================================================
+   *                                 How to use this driver
+   *          ===================================================================  
+   *          1- Make sure that the LS RC clock calibration is performed by the following 
+   *            steps:
+   *               - Connect internally the LS clock source to TIM2 channel 1 input
+   *                 capture for measurement by setting the MSR bit in the AWU->CSR register.
+   *               - Update the BEEP_CSR register by the measured LSI frequency 
+   *                  --> During this phase the BEEPER must be disabled to avoid 
+   *                      unwanted interrupts  
+   *
+   *          2- Configure the output beeper frequency using the BEEP_Init() function
+   *
+   *          3- Enable the beeper using the BEEP_Cmd() function
+   *
+   *  @endverbatim   
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_beep.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup BEEP 
+   * @brief BEEP driver modules
+   * @{
+   */ 
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /** @defgroup BEEP_Private_Functions
+   * @{
+   */
+ 
+ /** @defgroup BEEP_Group1 Initialization and Configuration functions
+  *  @brief    Initialization and Configuration functions 
+  *
+ @verbatim    
+  ===============================================================================
+                       Initialization and Configuration functions
+  ===============================================================================  
+   This section provides functions allowing to:
+    - Initialize and configure the Beeper frequency
+    - Enable and Disable the Beeper output
+    
+ @endverbatim
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the BEEP peripheral registers to their default
+   *         reset values.
+   * @param  None
+   * @retval None
+   */
+ void BEEP_DeInit(void)
+ {
+   BEEP->CSR = BEEP_CSR_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Initializes the BEEP function according to the specified parameters.
+   * @note   The LS RC calibration must be performed before calling this function.
+   * @param  BEEP_Frequency Frequency selection.
+   *         This parameter can be one of the values of @ref BEEP_Frequency_TypeDef.
+   * @retval None
+   */
+ void BEEP_Init(BEEP_Frequency_TypeDef BEEP_Frequency)
+ {
+ 
+   /* Check parameter */
+   assert_param(IS_BEEP_FREQUENCY(BEEP_Frequency));
+ 
+   /* Set a default calibration value if no calibration is done */
+   if ((BEEP->CSR & BEEP_CSR_BEEPDIV) == BEEP_CSR_BEEPDIV)
+   {
+     BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPDIV); /* Clear bits */
+     BEEP->CSR |= BEEP_CALIBRATION_DEFAULT;
+   }
+ 
+   /* Select the output frequency */
+   BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPSEL);
+   BEEP->CSR |= (uint8_t)(BEEP_Frequency);
+ 
+ }
+ 
+ /**
+   * @brief  Enable or disable the BEEP function.
+   * @note   Initialisation of BEEP and LS RC calibration must be done before.
+   * @param  NewState Indicates the new state of the BEEP function.
+   * @retval None
+   */
+ void BEEP_Cmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the BEEP peripheral */
+     BEEP->CSR |= BEEP_CSR_BEEPEN;
+   }
+   else
+   {
+     /* Disable the BEEP peripheral */
+     BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPEN);
+   }
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /** @defgroup BEEP_Group2 Low Speed Internal Clock(LSI) Calibration functions
+  *  @brief    Low Speed Internal Clock(LSI) Calibration functions 
+  *
+ @verbatim   
+  ===============================================================================
+               Low Speed Internal Clock(LSI) Calibration functions
+  ===============================================================================  
+ 
+   This section provides functions allowing to measure and calibrate the internal 
+   low speed clock source to ensure better BEEPER output frequency .
+   
+   A typical configuration for LSI calibration is done following these steps :
+    1. Disable the Beeper to avoid any unwanted interrupt using BEEP_Cmd() function 
+    2. Measure the LSI clock frequency by connecting it internally to TIM2 input capture  
+       by setting the MSR bit in AWU->CSR register
+    3. Calibrate the beeper frequency with the measured LSI clock frequency using 
+       BEEP_LSICalibrationConfig() function.
+    
+ @endverbatim
+   * @{
+   */
+ 
+ /**
+   * @brief  Update CSR register with the measured LSI frequency.
+   * @note   BEEP must be disabled to avoid unwanted interrupts.
+   * @note   Prescaler calculation:
+   *         A is the integer part of LSIFreqkHz/4 and x the decimal part.
+   *         x <= A/(1+2A) is equivalent to A >= x(1+2A)
+   *         and also to 4A >= 4x(1+2A) [F1]
+   *         but we know that A + x = LSIFreqkHz/4 ==> 4x = LSIFreqkHz-4A
+   *         so [F1] can be written :
+   *         4A >= (LSIFreqkHz-4A)(1+2A)
+   * @param  LSIFreqHz Low Speed RC frequency measured by timer (in Hz).
+   * @retval None
+   */
+ void BEEP_LSICalibrationConfig(uint32_t LSIFreqHz)
+ {
+ 
+   uint16_t lsifreqkhz;
+   uint16_t A;
+ 
+   /* Check parameter */
+   assert_param(IS_LSI_FREQUENCY(LSIFreqHz));
+ 
+   lsifreqkhz = (uint16_t)(LSIFreqHz / 1000); /* Converts value in kHz */
+ 
+   /* Calculation of BEEPER calibration value */
+ 
+   BEEP->CSR &= (uint8_t)(~BEEP_CSR_BEEPDIV); /* Clear bits */
+ 
+   A = (uint16_t)(lsifreqkhz >> 3U); /* Division by 8, keep integer part only */
+ 
+   if ((8U * A) >= ((lsifreqkhz - (8U * A)) * (1U + (2U * A))))
+   {
+     BEEP->CSR |= (uint8_t)(A - 2U);
+   }
+   else
+   {
+     BEEP->CSR |= (uint8_t)(A - 1U);
+   }
+ 
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_clk.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_clk.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_clk.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_clk.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,208 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_clk.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the CLK peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ 
+ #include "stm8l10x_clk.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup CLK 
+   * @brief CLK driver modules
+   * @{
+   */ 
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private Constants ---------------------------------------------------------*/
+ 
+ /**
+   * @addtogroup CLK_Private_Constants
+   * @{
+   */
+ 
+ CONST uint8_t HSIDivFactor[4] = {1, 2, 4, 8}; /*!< Holds the different HSI Dividor factors */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @addtogroup CLK_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the CLK peripheral registers to their default reset values.
+   * @param  None
+   * @retval None
+   */
+ void CLK_DeInit(void)
+ {
+   CLK->CKDIVR = CLK_CKDIVR_RESET_VALUE;
+   CLK->PCKENR = CLK_PCKENR_RESET_VALUE;
+   CLK->CCOR  = CLK_CCOR_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Enables or disable the Configurable Clock Output (CCO).
+   * @param  NewState New state of CCEN bit (CCO register).
+   * @retval None
+   */
+ void CLK_CCOCmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Set CCOEN bit */
+     CLK->CCOR |= CLK_CCOR_CCOEN;
+   }
+   else
+   {
+     /* Reset CCOEN bit */
+     CLK->CCOR &= (uint8_t)(~CLK_CCOR_CCOEN);
+   }
+ 
+ }
+ 
+ /**
+   * @brief  Enables or disables the specified peripheral CLK.
+   * @param  CLK_Peripheral: specifies the peripheral to gate its clock.
+   *          This parameter can be any combination of the following values:
+   *            @arg CLK_Peripheral_TIM2:       TIM2 clock
+   *            @arg CLK_Peripheral_TIM3:       TIM3 clock 
+   *            @arg CLK_Peripheral_TIM4:       TIM4 clock
+   *            @arg CLK_Peripheral_I2C:        I2C clock
+   *            @arg CLK_Peripheral_SPI:        SPI clock
+   *            @arg CLK_Peripheral_USART:      USART clock
+   *            @arg CLK_Peripheral_AWU:        AWU clock
+   * @param  NewState: new state of the specified peripheral clock.
+   *          This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void CLK_PeripheralClockConfig(CLK_Peripheral_TypeDef CLK_Peripheral, FunctionalState NewState)
+ {
+     /* Check the parameters */
+     assert_param(IS_FUNCTIONAL_STATE(NewState));
+     assert_param(IS_CLK_PERIPHERAL(CLK_Peripheral));
+ 
+     if (NewState != DISABLE)
+     {
+       /* Enable the peripheral Clock */
+       CLK->PCKENR |= ((uint8_t)CLK_Peripheral);
+     }
+     else
+     {
+       /* Disable the peripheral Clock */
+       CLK->PCKENR &= (uint8_t)(~(uint8_t)CLK_Peripheral);
+     }
+ }
+ 
+ /**
+   * @brief  Configures the HSI master clock dividers.
+   * @param  CLK_MasterPrescaler Specifies the HSI clock divider to apply.
+   *           This parameter can be any combination of the following values:
+   *            @arg CLK_MasterPrescaler_HSIDiv1:       High speed internal clock not divided
+   *            @arg CLK_MasterPrescaler_HSIDiv2:       High speed internal clock divided by 2
+   *            @arg CLK_MasterPrescaler_HSIDiv4:       High speed internal clock divided by 4
+   *            @arg CLK_MasterPrescaler_HSIDiv8:       High speed internal clock divided by 8     
+   * @retval None
+   */
+ void CLK_MasterPrescalerConfig(CLK_MasterPrescaler_TypeDef CLK_MasterPrescaler)
+ {
+   /* check parameters */
+   assert_param(IS_CLK_MASTER_PRESCALER(CLK_MasterPrescaler));
+ 
+   CLK->CKDIVR &= (uint8_t)(~CLK_CKDIVR_HSIDIV);
+   CLK->CKDIVR = (uint8_t)CLK_MasterPrescaler;
+ }
+ 
+ /**
+   * @brief  Output the selected clock on a dedicated I/O pin.
+   * @note   The I/O dedicated to the CCO pin must be set in output push-pull mode.
+   * @param  CLK_Output Specifies the clock source.
+   *          This parameter can be any combination of the following values:
+   *            @arg CLK_Output_ClockMaster:           Clock Output CKM
+   *            @arg CLK_Output_ClockMasterDiv2:       Clock Output CKM/2
+   *            @arg CLK_Output_ClockMasterDiv4:       Clock Output CKM/4
+   *            @arg CLK_Output_ClockMasterDiv16:      Clock Output CKM/16      
+   * @retval None
+   */
+ void CLK_CCOConfig(CLK_Output_TypeDef CLK_Output)
+ {
+   /* check parameters */
+   assert_param(IS_CLK_OUTPUT(CLK_Output));
+ 
+   /* Clears of the CCO type bits part */
+   CLK->CCOR &= (uint8_t)(~CLK_CCOR_CCOSEL);
+ 
+   /* Selects the source provided on cco_ck output */
+   CLK->CCOR |= ((uint8_t)CLK_Output);
+ 
+   /* Enable the clock output */
+   CLK->CCOR |= CLK_CCOR_CCOEN;
+ }
+ 
+ /**
+   * @brief  This function returns the frequencies of different on chip clocks.
+   * @param  None
+   * @retval The master clock frequency
+   */
+ uint32_t CLK_GetClockFreq(void)
+ {
+   uint32_t clockfrequency = 0;
+   uint8_t tmp = 0, presc = 0;
+ 
+   tmp = (uint8_t)(CLK->CKDIVR & CLK_CKDIVR_HSIDIV);
+   presc = HSIDivFactor[tmp];
+   clockfrequency = HSI_VALUE / presc;
+ 
+   return((uint32_t)clockfrequency);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_comp.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_comp.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_comp.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_comp.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,421 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_comp.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the COMP peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_comp.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup COMP 
+   * @brief COMP driver modules
+   * @{
+   */ 
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ 
+ /**
+   * @addtogroup COMP_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief Deinitializes the COMP peripheral registers to their default reset values.
+   * @param None
+   * @retval None
+   */
+ void COMP_DeInit(void)
+ {
+   COMP->CR   = COMP_CR_RESET_VALUE;
+   COMP->CSR  = COMP_CSR_RESET_VALUE;
+   COMP->CCS  = COMP_CCS_RESET_VALUE;
+ }
+ 
+ 
+ /**
+   * @brief  Initializes the COMP according to the specified parameters
+   * @note   The function @ref COMP_Cmd() should be called to set the BIASEN bit 
+   *         in the COMP_CR register, first.
+   * @param  COMP_Selection The state of the COMP peripheral
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Selection_None:        No comparator selected
+   *            @arg COMP_Selection_COMP1:       COMP1 enable
+   *            @arg COMP_Selection_COMP2:       COMP2 enable
+   *            @arg COMP_Selection_All:         COMP1 & COMP2 enable        
+   * @param  COMP_Reference The reference of the comparison
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Reference_Internal:    Comparator reference is internal
+   *            @arg COMP_Reference_External:    Comparator reference is external
+   * @param  COMP_Polarity  The desired comparator polarity
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Polarity_High:    For a detected event, output comparator is 1
+   *            @arg COMP_Polarity_Low:     For a detected event, output comparator is 0
+   * @retval None
+   */
+ void COMP_Init(COMP_Selection_TypeDef COMP_Selection,
+                COMP_Reference_TypeDef COMP_Reference,
+                COMP_Polarity_TypeDef COMP_Polarity)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_POLARITY(COMP_Polarity));
+   assert_param(IS_COMP_REFERENCE(COMP_Reference));
+   assert_param(IS_COMP_SELECTION(COMP_Selection));
+ 
+   COMP->CR &= (uint8_t)(~((uint8_t)COMP_Polarity | (uint8_t)COMP_Reference | (uint8_t)COMP_Selection));
+   /* Set the Configuration */
+   COMP->CR |= (uint8_t)((uint8_t)COMP_Polarity | (uint8_t)COMP_Reference | (uint8_t)COMP_Selection);
+ 
+ }
+ 
+ /**
+   * @brief  Enables or disables the COMP.
+   * @note   This function must be used 4s before the function @ref COMP_SelectionConfig().
+   * @param  NewState The New state of the COMP peripheral.
+   * @retval None
+   */
+ void COMP_Cmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* set  BIAS_EN  */
+     COMP->CR |= COMP_CR_BIASEN;
+   }
+   else  /* NewState == DISABLE */
+   {
+     COMP->CR &= (uint8_t)(~COMP_CR_BIASEN);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the desired COMP peripheral.
+   * @note   BIAS bit should be set 4s before enabling the comparators.
+   * @param  COMP_Selection The state of the COMP peripheral
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Selection_None:        No comparator selected
+   *            @arg COMP_Selection_COMP1:       COMP1 enable
+   *            @arg COMP_Selection_COMP2:       COMP2 enable
+   *            @arg COMP_Selection_All:         COMP1 & COMP2 enable   
+   * @param  NewState  The new state of the COMP peripheral.
+   * @retval None
+   */
+ void COMP_SelectionConfig(COMP_Selection_TypeDef COMP_Selection,
+                           FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+   assert_param(IS_COMP_SELECTION(COMP_Selection));
+ 
+   if (NewState != DISABLE)
+   {
+     COMP->CR |= (uint8_t)COMP_Selection;
+   }
+   else  /* NewState == DISABLE */
+   {
+     COMP->CR &= (uint8_t)(~(uint8_t)COMP_Selection);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the specified COMP interrupts.
+   * @param  COMP_IT  Specifies the COMP interrupts source.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_IT_ITEN1:        COMP1 interrupt enable
+   *            @arg COMP_IT_ITEN2:        COMP2 interrupt enable
+   *            @arg COMP_IT_CEF1:         COMP1 pending bit
+   *            @arg COMP_IT_CEF2:         COMP2 pending bit     
+   * @param  NewState The new state of the COMP peripheral.
+   * @retval None
+   */
+ void COMP_ITConfig(COMP_IT_TypeDef COMP_IT,
+                    FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_IT(COMP_IT));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the Interrupt sources */
+     COMP->CSR |= (uint8_t)COMP_IT;
+   }
+   else
+   {
+     /* Disable the Interrupt sources */
+     COMP->CSR &= (uint8_t)(~(uint8_t)COMP_IT);
+   }
+ }
+ 
+ /**
+   * @brief  Selection between Timer1 input capture1 or Timer1 break for first comparator output.
+   * @param  COMP_TIM2Config  TIM configartionfor first comparator output.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_TIM2Config_IC1:      Input capture 1 selection
+   *            @arg COMP_TIM2Config_BK:       Break selection  
+   * @retval None
+   */
+ void COMP_TIM2Config(COMP_TIM2Config_TypeDef COMP_TIM2Config)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_TIM2CONFIG(COMP_TIM2Config));
+ 
+   /* Clear the IC1_BK bit*/
+   COMP->CR &= (uint8_t)(~(uint8_t)COMP_CR_IC1BK);
+ 
+   /* Configure the  IC1_BK bit */
+   COMP->CR |= (uint8_t)COMP_TIM2Config;
+ }
+ 
+ /**
+   * @brief  Enables or disables the specified Switch.
+   * @param  COMP_Switch Specifies the COMP SWITCH to be enabled or disabled.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Switch_COMP1Ch1:     Comparator 1 Switch 1 Enable
+   *            @arg COMP_Switch_COMP1Ch2:     Comparator 1 Switch 1 Enable
+   *            @arg COMP_Switch_COMP1Ch3:     Comparator 1 Switch 1 Enable
+   *            @arg COMP_Switch_COMP1Ch4:     Comparator 1 Switch 1 Enable
+   *            @arg COMP_Switch_COMP2Ch1:     Comparator 2 Switch 1 Enable
+   *            @arg COMP_Switch_COMP2Ch2:     Comparator 2 Switch 2 Enable
+   *            @arg COMP_Switch_COMP2Ch3:     Comparator 2 Switch 3 Enable
+   *            @arg COMP_Switch_COMP2Ch4:     Comparator 2 Switch 4 Enable              
+   * @param  NewState    The new state of the COMP peripheral.
+   * @retval None
+   */
+ void COMP_SwitchConfig(COMP_Switch_TypeDef COMP_Switch,
+                        FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_SWITCH(COMP_Switch));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the switch */
+     COMP->CCS |= (uint8_t)COMP_Switch;
+   }
+   else
+   {
+     /* Disable the Switch */
+     COMP->CCS &= (uint8_t)(~(uint8_t)COMP_Switch);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the COMP peripheral Output Connection with Timers peripheral inputs.
+   * @param  COMP_TIMConnection  TIM connection configuration.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_TimersConnection_None:     No connection
+   *            @arg COMP_TimersConnection_COMP1ToTIM2IC1BK:                 COMP1 out to IC1/BK TIM2
+   *            @arg COMP_TimersConnection_COMP1ToTIM2IC1BK_COMP2ToTIM2IC2:  COMP1 out to IC1/BK TIM2 & COMP2 out to IC2 TIM2
+   *            @arg COMP_TimersConnection_COMP1ToTIM2IC1BK_COMP2ToTIM3IC2:  COMP1 out to IC1/BK TIM2 & COMP2 out to IC1 TIM3        
+   * @retval None
+   */
+ void COMP_TIMConnect(COMP_TimersConnection_TypeDef COMP_TIMConnection)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_TIMCONNECTION(COMP_TIMConnection));
+ 
+   /* Clear the TIM connection configuration bits */
+   COMP->CR &= (uint8_t)(~(uint8_t)COMP_CR_CNFTIM);
+ 
+   /* Configure the TIM connection */
+   COMP->CR |= (uint8_t)COMP_TIMConnection;
+ }
+ 
+ /**
+   * @brief  Selects the polarity of both comparators.
+   * @param  COMP_Polarity The desired comparator polarity
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Polarity_High:    For a detected event, output comparator is 1
+   *            @arg COMP_Polarity_Low:     For a detected event, output comparator is 0  
+   * @retval None
+   */
+ void COMP_SelectPolarity(COMP_Polarity_TypeDef COMP_Polarity)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_POLARITY(COMP_Polarity));
+ 
+   /* Clear Polarity bit */
+   COMP->CR &= (uint8_t)(~(uint8_t)COMP_CR_POL);
+ 
+   /* Write the polarity */
+   COMP->CR |= (uint8_t)COMP_Polarity;
+ }
+ 
+ /**
+   * @brief  Selects the internal or external reference of both comparators.
+   * @param  COMP_Reference The reference of the comparison
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Reference_Internal:    Comparator reference is internal
+   *            @arg COMP_Reference_External:    Comparator reference is external
+   * @retval None
+   */
+ void COMP_SetReference(COMP_Reference_TypeDef COMP_Reference)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_REFERENCE(COMP_Reference));
+ 
+   /* Clear Polarity bit */
+   COMP->CR &= (uint8_t)(~(uint8_t)COMP_CR_COMPREF);
+ 
+   /* Write the polarity */
+   COMP->CR |= (uint8_t)COMP_Reference;
+ }
+ 
+ /**
+   * @brief  Checks whether the specified COMP output is set or not.
+   * @param  COMP_Output Specifies the output to check.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_Output_COMP1:    COMP1 output
+   *            @arg COMP_Output_COMP2:    COMP2 output  
+   * @retval The new state of Output.
+   */
+ FlagStatus COMP_GetOutputStatus(COMP_Output_TypeDef COMP_Output)
+ {
+   FlagStatus status = RESET;
+ 
+   /* Check the parameters */
+   assert_param(IS_COMP_OUTPUT(COMP_Output));
+ 
+   if ((COMP->CSR & (uint8_t)COMP_Output) != 0)
+   {
+     status = SET;
+   }
+   else
+   {
+     status = RESET;
+   }
+   return status;
+ }
+ 
+ /**
+   * @brief  Checks whether the specified COMP flag is set or not.
+   * @param  COMP_Flag Specifies the flag to check.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_FLAG_COMP1:    COMP1 event flag
+   *            @arg COMP_FLAG_COMP2:    COMP2 event flag  
+   * @retval The new state of Flag.
+   */
+ FlagStatus COMP_GetFlagStatus(COMP_FLAG_TypeDef COMP_Flag)
+ {
+   FlagStatus status = RESET;
+ 
+   /* Check the parameters */
+   assert_param(IS_COMP_FLAG(COMP_Flag));
+ 
+   if ((COMP->CSR & (uint8_t)COMP_Flag) != 0)
+   {
+     status = SET;
+   }
+   else
+   {
+     status = RESET;
+   }
+   return status;
+ }
+ 
+ /**
+   * @brief  Clears the specified COMP flag.
+   * @param  COMP_Flag Specifies the flag to clear.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_FLAG_COMP1:    COMP1 event flag
+   *            @arg COMP_FLAG_COMP2:    COMP2 event flag    
+   * @retval None
+   */
+ void COMP_ClearFlag(COMP_FLAG_TypeDef COMP_Flag)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_FLAG(COMP_Flag));
+ 
+   /* Clear the flags (rc_w0) clear this bit by writing 1. Writing 0 has no effect*/
+   COMP->CSR |= (uint8_t)COMP_Flag;
+ }
+ 
+ /**
+   * @brief Checks whether the COMP interrupt has occurred or not.
+   * @param COMP_ITPendingBit Specifies the COMP interrupt source to check.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_IT_CEF1:    COMP1 pending bit
+   *            @arg COMP_IT_CEF2:    COMP2 pending bit   
+   * @retval ITStatus The new state of the COMP_IT.
+   */
+ ITStatus COMP_GetITStatus(COMP_IT_TypeDef COMP_ITPendingBit)
+ {
+   ITStatus status = RESET;
+ 
+   /* Check the parameters */
+   assert_param(IS_COMP_ITPENDINGBIT(COMP_ITPendingBit));
+ 
+   if (COMP->CSR & (uint8_t)COMP_ITPendingBit)
+   {
+     status = SET;
+   }
+   else
+   {
+     status = RESET;
+   }
+   return status;
+ }
+ 
+ /**
+   * @brief  Clears the COMP pending bits.
+   * @param  ITPendingBit Specifies the pending bit to clear.
+   *          This parameter can be any combination of the following values:
+   *            @arg COMP_IT_CEF1:    COMP1 pending bit
+   *            @arg COMP_IT_CEF2:    COMP2 pending bit   
+   * @retval None
+   */
+ void COMP_ClearITPendingBit(COMP_IT_TypeDef COMP_ITPendingBit)
+ {
+   /* Check the parameters */
+   assert_param(IS_COMP_ITPENDINGBIT(COMP_ITPendingBit));
+ 
+   /* Clear the flags (rc_w0) clear this bit by writing 1. Writing 0 has no effect*/
+   COMP->CSR |= (uint8_t)COMP_ITPendingBit;
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_exti.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_exti.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_exti.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_exti.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,391 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_exti.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the EXTI peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_exti.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup EXTI 
+   * @brief EXTI driver modules
+   * @{
+   */ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @addtogroup EXTI_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief Deinitializes the external interrupt control registers to their default reset value.
+   * @param None
+   * @retval None
+   */
+ void EXTI_DeInit(void)
+ {
+   EXTI->CR1 = EXTI_CR1_RESET_VALUE;
+   EXTI->CR2 = EXTI_CR2_RESET_VALUE;
+   EXTI->CR3 = EXTI_CR3_RESET_VALUE;
+   EXTI->SR1 = EXTI_SR1_RESET_VALUE;
+   EXTI->SR2 = EXTI_SR2_RESET_VALUE;
+   EXTI->CONF = EXTI_CONF_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Set the external interrupt sensitivity of the selected port.
+   * @note   The modification of external interrupt sensitivity is only possible 
+   *         when the interrupts are disabled.
+   * @note   The normal behavior is to disable the interrupts before calling this 
+   *         function, and re-enable them after.
+   * @note   Global interrupts must be disabled before calling this function.
+   * @param  EXTI_Port         The port number to access.
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_Port_B:   GPIO Port B
+   *            @arg EXTI_Port_D:   GPIO Port D 
+   * @param  EXTI_TriggerValue The external interrupt sensitivity value to set.
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_Trigger_Falling_Low:     Interrupt on Falling edge and Low level
+   *            @arg EXTI_Trigger_Rising:          Interrupt on Rising edge
+   *            @arg EXTI_Trigger_Falling:         Interrupt on Falling edge
+   *            @arg EXTI_Trigger_Rising_Falling:  Interrupt on Rising and Falling edges      
+   * @retval None
+   */
+ void EXTI_SetPortSensitivity(EXTI_Port_TypeDef EXTI_Port,
+                              EXTI_Trigger_TypeDef EXTI_TriggerValue)
+ {
+ 
+   /* Check function parameters */
+   assert_param(IS_EXTI_PORT(EXTI_Port));
+   assert_param(IS_EXTI_Trigger_VALUE(EXTI_TriggerValue));
+ 
+   /* Clear EXTI  port sensitivity */
+   if (EXTI_Port != EXTI_Port_B)
+   {
+     EXTI->CR3 &= (uint8_t)(~EXTI_CR3_PDIS);
+   }
+   else /* PortNum == EXTI_Port_B */
+   {
+     EXTI->CR3 &= (uint8_t)(~EXTI_CR3_PBIS);
+   }
+ 
+   /* Write EXTI  port sensitivity */
+   EXTI->CR3 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << (uint8_t)EXTI_Port);
+ 
+ }
+ 
+ /**
+   * @brief  Set the external interrupt sensitivity of the selected pin.
+   * @note   The modification of external interrupt sensitivity is only possible 
+   *         when the interrupts are disabled.
+   * @note   The normal behavior is to disable the interrupts before calling this 
+   *         function, and re-enable them after.
+   * @note   Global interrupts must be disabled before calling this function.
+   * @param  EXTI_PinNum       The pin to configure.
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_Pin_0:     GPIO Pin 0
+   *            @arg EXTI_Pin_1:     GPIO Pin 1
+   *            @arg EXTI_Pin_2:     GPIO Pin 2
+   *            @arg EXTI_Pin_3:     GPIO Pin 3
+   *            @arg EXTI_Pin_4:     GPIO Pin 4
+   *            @arg EXTI_Pin_5:     GPIO Pin 5
+   *            @arg EXTI_Pin_6:     GPIO Pin 6
+   *            @arg EXTI_Pin_7:     GPIO Pin 7              
+   * @param  EXTI_TriggerValue The external interrupt sensitivity value to set.
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_Trigger_Falling_Low:     Interrupt on Falling edge and Low level
+   *            @arg EXTI_Trigger_Rising:          Interrupt on Rising edge
+   *            @arg EXTI_Trigger_Falling:         Interrupt on Falling edge
+   *            @arg EXTI_Trigger_Rising_Falling:  Interrupt on Rising and Falling edges 
+   * @retval None
+   */
+ void EXTI_SetPinSensitivity(EXTI_Pin_TypeDef EXTI_PinNum,
+                             EXTI_Trigger_TypeDef EXTI_TriggerValue)
+ {
+ 
+   /* Check function parameters */
+   assert_param(IS_EXTI_PINNUM(EXTI_PinNum));
+   assert_param(IS_EXTI_Trigger_VALUE(EXTI_TriggerValue));
+ 
+   /* Clear port sensitivity bits */
+   switch (EXTI_PinNum)
+   {
+     case EXTI_Pin_0:
+       EXTI->CR1 &= (uint8_t)(~EXTI_CR1_P0IS);
+       EXTI->CR1 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << (uint8_t)EXTI_PinNum);
+       break;
+     case EXTI_Pin_1:
+       EXTI->CR1 &= (uint8_t)(~EXTI_CR1_P1IS);
+       EXTI->CR1 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << (uint8_t)EXTI_PinNum);
+       break;
+     case EXTI_Pin_2:
+       EXTI->CR1 &= (uint8_t)(~EXTI_CR1_P2IS);
+       EXTI->CR1 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << (uint8_t)EXTI_PinNum);
+       break;
+     case EXTI_Pin_3:
+       EXTI->CR1 &= (uint8_t)(~EXTI_CR1_P3IS);
+       EXTI->CR1 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << (uint8_t)EXTI_PinNum);
+       break;
+     case EXTI_Pin_4:
+       EXTI->CR2 &= (uint8_t)(~EXTI_CR2_P4IS);
+       EXTI->CR2 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << ((uint8_t)EXTI_PinNum & (uint8_t)0xEF));
+       break;
+     case EXTI_Pin_5:
+       EXTI->CR2 &= (uint8_t)(~EXTI_CR2_P5IS);
+       EXTI->CR2 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << ((uint8_t)EXTI_PinNum & (uint8_t)0xEF));
+       break;
+     case EXTI_Pin_6:
+       EXTI->CR2 &= (uint8_t)(~EXTI_CR2_P6IS);
+       EXTI->CR2 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << ((uint8_t)EXTI_PinNum & (uint8_t)0xEF));
+       break;
+     case EXTI_Pin_7:
+       EXTI->CR2 &= (uint8_t)(~EXTI_CR2_P7IS);
+       EXTI->CR2 |= (uint8_t)((uint8_t)(EXTI_TriggerValue) << ((uint8_t)EXTI_PinNum & (uint8_t)0xEF));
+       break;
+     default:
+       break;
+   }
+ }
+ 
+ /**
+   * @brief  Configure the half port interrupt selection.
+   * @note   This function must be called once the port sensitivity is configured,
+   *          otherwise this function call won't have any effect on the port external interrupt.
+   * @param  EXTI_HalfPort The port part  to access (MSB or LSB).
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_HalfPort_B_LSB:     Interrupt selector PB(3:0)
+   *            @arg EXTI_HalfPort_B_MSB:     Interrupt selector PB(7:4)
+   *            @arg EXTI_HalfPort_D_LSB:     Interrupt selector PE(3:0)
+   *            @arg EXTI_HalfPort_D_MSB:     Interrupt selector PE(7:4)
+   * @param  NewState  The external interrupt new state.
+   * @retval None
+   */
+ void EXTI_SetHalfPortSelection(EXTI_HalfPort_TypeDef EXTI_HalfPort,
+                                FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_EXTI_HALFPORT(EXTI_HalfPort));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     EXTI->CONF |= (uint8_t)EXTI_HalfPort; /* Enable port interrupt selector */
+   }
+   else /*NewState == DISABLE */
+   {
+     EXTI->CONF &= (uint8_t)(~(uint8_t)EXTI_HalfPort); /* Disable port interrupt selector */
+   }
+ }
+ 
+ /**
+   * @brief  Get the external interrupt sensitivity of the selected port.
+   * @param  EXTI_Port         The port number to access.
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_Port_B:   GPIO Port B
+   *            @arg EXTI_Port_D:   GPIO Port D 
+   * @retval EXTI_Trigger_TypeDef The external interrupt sensitivity of the selected port.
+   */
+ EXTI_Trigger_TypeDef EXTI_GetPortSensitivity(EXTI_Port_TypeDef EXTI_Port)
+ {
+   uint8_t value = 0;
+ 
+   /* Check function parameters */
+   assert_param(IS_EXTI_PORT(EXTI_Port));
+ 
+   if (EXTI_Port != EXTI_Port_B)
+   {
+     value = (uint8_t)((EXTI->CR3 & EXTI_CR3_PDIS) >> 2);
+   }
+   else /* PortNum == EXTI_Port_B */
+   {
+     value = (uint8_t)(EXTI->CR3 & EXTI_CR3_PBIS);
+   }
+   return((EXTI_Trigger_TypeDef)value);
+ }
+ 
+ /**
+   * @brief  Get the external interrupt sensitivity of the selected pin.
+   * @param  EXTI_PinNum       The pin to configure.
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_Pin_0:     GPIO Pin 0
+   *            @arg EXTI_Pin_1:     GPIO Pin 1
+   *            @arg EXTI_Pin_2:     GPIO Pin 2
+   *            @arg EXTI_Pin_3:     GPIO Pin 3
+   *            @arg EXTI_Pin_4:     GPIO Pin 4
+   *            @arg EXTI_Pin_5:     GPIO Pin 5
+   *            @arg EXTI_Pin_6:     GPIO Pin 6
+   *            @arg EXTI_Pin_7:     GPIO Pin 7 
+   * @retval EXTI_Trigger_TypeDef The external interrupt sensitivity of the selected port.
+   */
+ EXTI_Trigger_TypeDef EXTI_GetPinSensitivity(EXTI_Pin_TypeDef EXTI_PinNum)
+ {
+   uint8_t value = 0;
+ 
+   /* Check function parameters */
+   assert_param(IS_EXTI_PINNUM(EXTI_PinNum));
+ 
+   switch (EXTI_PinNum)
+   {
+     case EXTI_Pin_0:
+       value = (uint8_t)(EXTI->CR1 & EXTI_CR1_P0IS);
+       break;
+     case EXTI_Pin_1:
+       value = (uint8_t)((EXTI->CR1 & EXTI_CR1_P1IS) >> (uint8_t)EXTI_Pin_1);
+       break;
+     case EXTI_Pin_2:
+       value = (uint8_t)((EXTI->CR1 & EXTI_CR1_P2IS) >> (uint8_t)EXTI_Pin_2);
+       break;
+     case EXTI_Pin_3:
+       value = (uint8_t)((EXTI->CR1 & EXTI_CR1_P3IS) >> (uint8_t)EXTI_Pin_3);
+       break;
+     case EXTI_Pin_4:
+       value = (uint8_t)(EXTI->CR2 & EXTI_CR2_P4IS);
+       break;
+     case EXTI_Pin_5:
+       value = (uint8_t)((EXTI->CR2 & EXTI_CR2_P5IS) >> ((uint8_t)EXTI_Pin_5 & (uint8_t)0x0F));
+       break;
+     case EXTI_Pin_6:
+       value = (uint8_t)((EXTI->CR2 & EXTI_CR2_P6IS) >> ((uint8_t)EXTI_Pin_6 & (uint8_t)0x0F));
+       break;
+     case EXTI_Pin_7:
+       value = (uint8_t)((EXTI->CR2 & EXTI_CR2_P7IS) >> ((uint8_t)EXTI_Pin_7 & (uint8_t)0x0F));
+       break;
+     default:
+       break;
+   }
+   return((EXTI_Trigger_TypeDef)value);
+ }
+ 
+ /**
+   * @brief  Get the external interrupt half port configuration.
+   * @param  EXTI_HalfPort The port part  to access (MSB or LSB).
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_HalfPort_B_LSB:     Interrupt selector PB(3:0)
+   *            @arg EXTI_HalfPort_B_MSB:     Interrupt selector PB(7:4)
+   *            @arg EXTI_HalfPort_D_LSB:     Interrupt selector PE(3:0)
+   *            @arg EXTI_HalfPort_D_MSB:     Interrupt selector PE(7:4)
+   * @retval The external interrupt state of the selected port.
+   */
+ FunctionalState EXTI_GetHalfPortSelection(EXTI_HalfPort_TypeDef EXTI_HalfPort)
+ {
+   FunctionalState value = DISABLE;
+   /* Check function parameters */
+   assert_param(IS_EXTI_HALFPORT(EXTI_HalfPort));
+   if ((EXTI->CONF & (uint8_t)EXTI_HalfPort) != (uint8_t)DISABLE)
+   {
+     value = ENABLE;
+   }
+   else
+   {
+     value = DISABLE;
+   }
+ 
+   return(value);
+ }
+ 
+ /**
+   * @brief  Get the external interrupt status.
+   * @param  EXTI_IT Specifies the interrupt to read.
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_IT_0:     GPIO Pin pos 0
+   *            @arg EXTI_IT_1:     GPIO Pin pos 1
+   *            @arg EXTI_IT_2:     GPIO Pin pos 2
+   *            @arg EXTI_IT_3:     GPIO Pin pos 3
+   *            @arg EXTI_IT_4:     GPIO Pin pos 4
+   *            @arg EXTI_IT_5:     GPIO Pin pos 5
+   *            @arg EXTI_IT_6:     GPIO Pin pos 6
+   *            @arg EXTI_IT_7:     GPIO Pin pos 7 
+   *            @arg EXTI_IT_PortB: GPIO Port B
+   *            @arg EXTI_IT_PortD: GPIO Port D 
+   * @retval The status of the specified interrupt.
+   */
+ ITStatus EXTI_GetITStatus(EXTI_IT_TypeDef EXTI_IT)
+ {
+   ITStatus status = RESET;
+   /* Check function parameters */
+   assert_param(IS_EXTI_ITPENDINGBIT(EXTI_IT));
+ 
+   if (((uint8_t)EXTI_IT & (uint8_t)0xF0) == 0xF0)
+   {
+     status = (ITStatus)(EXTI->SR2 & ((uint8_t)EXTI_IT & (uint8_t)0x0F));
+   }
+   else
+   {
+     status = (ITStatus)(EXTI->SR1 & (uint8_t)EXTI_IT);
+   }
+   return((ITStatus)status);
+ }
+ 
+ /**
+   * @brief  Clear the specified interrupt pending bit
+   * @param  EXTI_IT Specifies the interrupt to clear
+   *          This parameter can be any combination of the following values:
+   *            @arg EXTI_IT_0:     GPIO Pin pos 0
+   *            @arg EXTI_IT_1:     GPIO Pin pos 1
+   *            @arg EXTI_IT_2:     GPIO Pin pos 2
+   *            @arg EXTI_IT_3:     GPIO Pin pos 3
+   *            @arg EXTI_IT_4:     GPIO Pin pos 4
+   *            @arg EXTI_IT_5:     GPIO Pin pos 5
+   *            @arg EXTI_IT_6:     GPIO Pin pos 6
+   *            @arg EXTI_IT_7:     GPIO Pin pos 7 
+   *            @arg EXTI_IT_PortB: GPIO Port B
+   *            @arg EXTI_IT_PortD: GPIO Port D   
+   * @retval None
+   */
+ void EXTI_ClearITPendingBit(EXTI_IT_TypeDef EXTI_IT)
+ {
+   /* Check function parameters */
+   assert_param(IS_EXTI_ITPENDINGBIT(EXTI_IT));
+ 
+   if (((uint8_t)EXTI_IT & (uint8_t)0xF0) == 0xF0)
+   {
+     EXTI->SR2 = (uint8_t)((uint8_t)EXTI_IT & (uint8_t)0x0F);
+   }
+   else
+   {
+     EXTI->SR1 = (uint8_t)EXTI_IT;
+   }
+ }
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_flash.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_flash.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_flash.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_flash.c	2017-09-02 18:39:34.000000000 +0200
***************
*** 0 ****
--- 1,822 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_flash.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file provides all the Flash firmware functions. These functions
+   *          can be executed from Internal FLASH or Internal RAM memories.
+   *            - FLASH program and Data EEPROM memories interface configuration
+   *            - FLASH program and Data EEPROM memories Programming
+   *            - Option Bytes Programming
+   *            - Interrupts and flags management
+   *            - Functions to be executed from RAM
+   *               
+   *  @verbatim
+   *  
+   *          ===================================================================
+   *                                 How to use this driver
+   *          ===================================================================
+   *                           
+   *          This driver provides functions to configure and program the Flash 
+   *          memory of the STM8L10x devices
+   *          These functions are split in 4 groups
+   * 
+   *           1. FLASH program and Data EEPROM memories interface configuration 
+   *              functions: this group includes the management of the following 
+   *              features:
+   *                    - Set the fixed programming time
+   *                    - Get the fixed programming time  
+   *  
+   *           2. FLASH program and Data EEPROM memories Programming functions: 
+   *              this group includes all needed functions to erase and program 
+   *              the FLASH program or the Data EEPROM memory.
+   *                    - Lock and Unlock the Flash program interface.
+   *                    - Lock and Unlock the Data EEPROM interface.  
+   *                    - Erase function: Erase Byte, Erase Word and Erase Block 
+   *                      (this last should be executed from internal RAM). 
+   *                    - Program functions: Program Byte, Program Word, 
+   *                      Program Block (should be executed from internal RAM) 
+   *                      and Fast Program Block (should be executed from internal
+   *                      RAM).
+   *    
+   *           3. FLASH Option Bytes Programming functions: this group includes 
+   *              all needed functions to:
+   *                    - Get the Read Out Protection status (ROP option byte)
+   *                    - Get the User Boot Code size (UBC option byte)
+   *                    - Get the Protected Code size (PCODE option byte) 
+   *                    
+   *           4. FLASH Interrupts and flag management functions: this group 
+   *              includes all needed functions to:
+   *                    - Enable/Disable the flash interrupt sources
+   *                    - Get flags status
+   *                    - Wait for last flash operation(can be executed from 
+   *                      internal RAM)
+   *                        
+   *           5. Functions to be executed from RAM: this group includes the functions
+   *              that should be executed from RAM and provides description on how 
+   *              to handle this with the different supported toolchains
+   *   
+   *  The table below lists the functions that can be executed from RAM.
+   *  
+   *   +--------------------------------------------------------------------------------|
+   *   |   Functions prototypes      |    RAM execution            |     Comments       |
+   *   ---------------------------------------------------------------------------------|
+   *   |                             | Mandatory in case of block  | Can be executed    |
+   *   | FLASH_WaitForLastOperation  | Operation:                  | from Flash in case |
+   *   |                             | - Block programming         | of byte and word   |
+   *   |                             | - Block erase               | Operations         |
+   *   |--------------------------------------------------------------------------------|
+   *   | FLASH_ProgramBlock          |       Exclusively           | useless from Flash |
+   *   |--------------------------------------------------------------------------------|
+   *   | FLASH_EraseBlock            |       Exclusively           | useless from Flash |
+   *   |--------------------------------------------------------------------------------|
+   *  
+   *  To be able to execute functions from RAM several steps have to be followed.
+   *  These steps may differ from one toolchain to another.
+   *  A detailed description is available below within this driver.
+   *  You can also refer to the Flash_DataProgram example provided within the
+   *   STM8L10x_StdPeriph_Lib package.
+   * 
+   *  @endverbatim   
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_flash.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup FLASH 
+   * @brief FLASH driver modules
+   * @{
+   */ 
+   
+ /* Private TypeDef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ #define FLASH_CLEAR_BYTE   ((uint8_t)0x00);
+ #define FLASH_SET_BYTE     ((uint8_t)0xFF);
+ #define OPERATION_TIMEOUT  ((uint16_t)0x1000)
+ /* Private macro -------------------------------------------------------------*/
+ 
+ /* SDCC patch: simplify sdcc && >64kB indicator over different SPLs */
+ #if defined(_SDCC_BIGMEM_)
+   #undef  MemoryAddressCast
+   #define MemoryAddressCast uint32_t
+ #else
+   #undef  MemoryAddressCast
+   #define MemoryAddressCast uint16_t
+ #endif
+ 
+ /* Private variables ---------------------------------------------------------*/
+ 
+ /* SDCC patch: for >64kB to pass data to/from inline ASM (SDCC doesn't support far pointers yet) */
+ #if defined(_SDCC_BIGMEM_)     
+   uint32_t    asm_addr;      // 16b/24b address
+   uint8_t     asm_val;       // 1B data for r/w data
+ #endif // _SDCC_BIGMEM_
+ 
+ /* Private Constants ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ 
+ /* SDCC patch: r/w helper routines for >64kB addresses (SDCC doesn't support far pointers yet) */
+ #if defined (_SDCC_BIGMEM_)
+   void      write_byte_address(uint32_t Address, uint8_t Data);   // write single byte to 16b/24b address
+   uint8_t   read_byte_address(uint32_t Address);                  // read single byte from 16b/24b address
+ #endif // _SDCC_BIGMEM_
+ 
+ /* Private functions ---------------------------------------------------------*/
+  
+ /* SDCC patch: r/w helper routines for >64kB addresses using inline ASM (SDCC doesn't support far pointers yet) */
+ /** @addtogroup FLASH_Helper_functions
+   * @{
+   */
+ 
+ #if defined (_SDCC_BIGMEM_)
+ /**
+   * @brief  write single byte to address
+   * @note   is required for >64kB memory space and SDCC, which doesn't yet support far pointers
+   * @param  Address : address to write to
+   *         Data :    value to write
+   * @retval None
+   */
+ void write_byte_address(uint32_t Address, uint8_t Data)
+ {
+   /* store address & data globally for assember */
+   asm_addr = Address;
+   asm_val  = Data;
+ 
+   /* use inline assembler to write to 16b/24b address */
+ __asm
+   ld	a,_asm_val
+   ldf	[_asm_addr+1].e,a
+ __endasm;
+ 
+ }
+ 
+ 
+ /**
+   * @brief  Reads any byte from flash memory
+   * @note   is required for >64kB memory space and SDCC, which doesn't yet support far pointers
+   * @param  Address : address to read
+   * @retval value read
+   */
+ uint8_t read_byte_address(uint32_t Address)
+ {
+   /* store address globally for assember */
+   asm_addr = Address;
+ 
+   /* use inline assembler to read from 16b/24b address */
+ __asm
+   ldf	a,[_asm_addr+1].e
+   ld	_asm_val,a
+ __endasm;
+ 
+   /* return read byte */
+   return(asm_val);
+   
+ }
+ 
+ #endif // _SDCC_BIGMEM_
+ 
+ /**
+   * @}
+   */
+   
+ 
+ /** @defgroup FLASH_Private_Functions
+   * @{
+   */ 
+ 
+ /** @defgroup FLASH_Group1 FLASH program and Data EEPROM memories Interface 
+   *                        configuration functions
+   *  @brief   FLASH Interface configuration functions 
+  *
+ @verbatim   
+  ===============================================================================
+       FLASH program and Data EEPROM memories interface configuration functions
+  ===============================================================================  
+ 
+    The FLASH program and Data EEPROM memories interface configuration functions,
+     includes the following functions:
+ 		
+    - FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void);
+    - void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgTime);
+ 
+    These functions don't need the unlock sequence.
+ 
+ @endverbatim
+   * @{
+   */
+ 
+ /**
+   * @brief  Sets the fixed programming time
+   * @param  FLASH_ProgTime: Indicates the programming time to be fixed
+   *          This parameter can be one of the following values:
+   *            @arg FLASH_ProgramTime_Standard: Standard programming time fixed at 1/2 tprog
+   *            @arg FLASH_ProgramTime_TProg: Programming time fixed at tprog 
+   * @retval None
+   */
+ void FLASH_SetProgrammingTime(FLASH_ProgramTime_TypeDef FLASH_ProgramTime)
+ {
+   /* Check parameter */
+   assert_param(IS_FLASH_PROGRAM_TIME(FLASH_ProgramTime));
+ 
+   FLASH->CR1 &= (uint8_t)(~FLASH_CR1_FIX);
+   FLASH->CR1 |= (uint8_t)FLASH_ProgramTime;
+ }
+ 
+ /**
+   * @brief  Returns the fixed programming time
+   * @param  None
+   * @retval Fixed programming time value
+   */
+ FLASH_ProgramTime_TypeDef FLASH_GetProgrammingTime(void)
+ {
+   return((FLASH_ProgramTime_TypeDef)(FLASH->CR1 & FLASH_CR1_FIX));
+ }
+ 
+ /**
+   * @}
+   */
+  
+ /** @defgroup FLASH_Group2 FLASH Memory Programming functions
+  *  @brief   FLASH Memory Programming functions
+  *
+ @verbatim   
+  ===============================================================================
+                       FLASH Memory Programming functions
+  ===============================================================================  
+ 
+    The FLASH Memory Programming functions, includes the following functions:
+     - void FLASH_DeInit(void);
+     - void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType);
+     - void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType);
+     - void FLASH_ProgramByte(uint32_t Address, uint8_t Data);
+     - void FLASH_EraseByte(uint32_t Address);
+     - void FLASH_ProgramWord(uint32_t Address, uint32_t Data);
+     - uint8_t FLASH_ReadByte(uint32_t Address);
+    
+    Any operation of erase or program should follow these steps:
+ 
+    1. Call the FLASH_Unlock(FLASH_MemType) function to enable the memory access
+ 
+    2. Call the desired function to erase or program data
+ 
+    3. Call the FLASH_Lock() function to disable the memory access 
+      (it is recommended to protect the FLASH memory against possible unwanted operation)
+ 
+ @endverbatim
+   * @{
+   */
+ 
+ /**
+   * @brief Deinitializes the FLASH peripheral registers to their default reset values.
+   * @param None
+   * @retval None
+   */
+ void FLASH_DeInit(void)
+ {
+   FLASH->CR1 = FLASH_CR1_RESET_VALUE;
+   FLASH->CR2 = FLASH_CR2_RESET_VALUE;
+   FLASH->IAPSR = FLASH_IAPSR_RESET_VALUE;
+   (void) FLASH->IAPSR; /* Reading of this register causes the clearing of status flags */
+ }
+    
+ /**
+   * @brief  Unlocks the program or data EEPROM memory
+   * @param  FLASH_MemType: Memory type to unlock
+   *          This parameter can be one of the following values:
+   *            @arg FLASH_MemType_Program: Program memory
+   *            @arg FLASH_MemType_Data: Data EEPROM memory 
+   * @retval None
+   */
+ void FLASH_Unlock(FLASH_MemType_TypeDef FLASH_MemType)
+ {
+   /* Check parameter */
+   assert_param(IS_MEMORY_TYPE(FLASH_MemType));
+ 
+   /* Unlock program memory */
+   if (FLASH_MemType == FLASH_MemType_Program)
+   {
+     FLASH->PUKR = FLASH_RASS_KEY1;
+     FLASH->PUKR = FLASH_RASS_KEY2;
+   }
+   /* Unlock data memory */
+   if (FLASH_MemType == FLASH_MemType_Data)
+   {
+     FLASH->DUKR = FLASH_RASS_KEY2; /* Warning: keys are reversed on data memory !!! */
+     FLASH->DUKR = FLASH_RASS_KEY1;
+   }
+ }
+ 
+ /**
+   * @brief  Locks the program or data EEPROM memory
+   * @param  FLASH_MemType: Memory type
+   *          This parameter can be one of the following values:
+   *            @arg FLASH_MemType_Program: Program memory
+   *            @arg FLASH_MemType_Data: Data EEPROM memory 
+   * @retval None
+   */
+ void FLASH_Lock(FLASH_MemType_TypeDef FLASH_MemType)
+ {
+   /* Check parameter */
+   assert_param(IS_MEMORY_TYPE(FLASH_MemType));
+   /* Lock memory */
+   FLASH->IAPSR &= (uint8_t)FLASH_MemType;
+ }
+ 
+ /**
+   * @brief  Programs one byte in program or data EEPROM memory
+   * @param  Address: Address where the byte will be programmed
+   * @param  Data: Value to be programmed
+   * @retval None
+   */
+ void FLASH_ProgramByte(uint16_t Address, uint8_t Data)
+ {
+   /* Check parameters */
+   assert_param(IS_FLASH_ADDRESS(Address));
+ 
+   /* Program byte */
+   /* SDCC patch: SDCC requires helper routines for >64kB addresses due to lack of far pointers */
+   #ifndef _SDCC_BIGMEM_
+     *(PointerAttr uint8_t*) (MemoryAddressCast)Address = Data;
+   #else
+     write_byte_address((MemoryAddressCast) Address, Data);
+   #endif // _SDCC_BIGMEM_
+ }
+ 
+ /**
+   * @brief  Erases one byte in the program or data EEPROM memory
+   * @param  Address: Address of the byte to erase
+   * @retval None
+   */
+ void FLASH_EraseByte(uint16_t Address)
+ {
+   /* Check parameter */
+   assert_param(IS_FLASH_ADDRESS(Address));
+   
+   /* Erase byte */
+   /* SDCC patch: SDCC requires helper routines for >64kB addresses due to lack of far pointers */
+   #ifndef _SDCC_BIGMEM_
+     *(PointerAttr uint8_t*) (MemoryAddressCast)Address = FLASH_CLEAR_BYTE;
+   #else
+     write_byte_address((MemoryAddressCast) Address, FLASH_CLEAR_BYTE);
+   #endif // _SDCC_BIGMEM_
+ }
+ 
+ /**
+   * @brief  Programs one word (4 bytes) in program or data EEPROM memory
+   * @param  Address: The address where the data will be programmed
+   * @param  Data: Value to be programmed
+   * @retval None
+   */
+ void FLASH_ProgramWord(uint16_t Address, uint32_t Data)
+ {
+   /* Check parameters */
+   assert_param(IS_FLASH_ADDRESS(Address));
+ 
+   /* Enable Word Write Once */
+   FLASH->CR2 |= FLASH_CR2_WPRG;
+   
+   /* SDCC patch: SDCC requires helper routines for >64kB addresses due to lack of far pointers */
+   #ifndef _SDCC_BIGMEM_
+     /* Write one byte - from lowest address*/
+     *((PointerAttr uint8_t*)(MemoryAddressCast)Address)       = *((uint8_t*)(&Data));
+     /* Write one byte*/
+     *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 1) = *((uint8_t*)(&Data)+1); 
+     /* Write one byte*/    
+     *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 2) = *((uint8_t*)(&Data)+2); 
+     /* Write one byte - from higher address*/
+     *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 3) = *((uint8_t*)(&Data)+3); 
+   #else
+     write_byte_address((MemoryAddressCast) (Address    ), *((uint8_t*)(&Data)));
+     write_byte_address((MemoryAddressCast) (Address + 1), *((uint8_t*)(&Data)+1));
+     write_byte_address((MemoryAddressCast) (Address + 2), *((uint8_t*)(&Data)+2));
+     write_byte_address((MemoryAddressCast) (Address + 3), *((uint8_t*)(&Data)+3));
+   #endif // _SDCC_BIGMEM_
+ }
+ 
+ /**
+   * @brief  Reads one byte from flash memory
+   * @param  Address: Address to read
+   * @retval Value of the byte
+   */
+ uint8_t FLASH_ReadByte(uint16_t Address)
+ {
+   /* Check parameter */
+   assert_param(IS_FLASH_ADDRESS(Address));
+   
+   /* Read byte */
+   /* SDCC patch: SDCC requires helper routines for >64kB addresses due to lack of far pointers */
+   #ifndef _SDCC_BIGMEM_
+     return(*(PointerAttr uint8_t *) (MemoryAddressCast)Address); 
+   #else
+     return(read_byte_address((MemoryAddressCast) Address));
+   #endif // _SDCC_BIGMEM_
+ }
+ /**
+   * @}
+   */
+ 
+ /** @defgroup FLASH_Group3 Option Bytes Programming functions
+  *  @brief   Option Bytes Programming functions 
+  *
+ @verbatim   
+  ===============================================================================
+                         Option Bytes Programming functions
+  ===============================================================================  
+ 
+    The FLASH_Option Bytes Programming_functions, includes the following functions:
+ 
+    - FunctionalState FLASH_GetReadOutProtectionStatus(void);
+    - uint16_t FLASH_GetBootSize(void);
+    - uint16_t FLASH_GetCodeSize(void);
+    
+ @endverbatim
+   * @{
+   */
+   
+ /**
+   * @brief  Returns the FLASH Read Out Protection Status.
+   * @param  None
+   * @retval FLASH Read Out Protection Status.
+   *         This parameter can be a ENABLE or DISABLE
+   */
+ FunctionalState FLASH_GetReadOutProtectionStatus(void)
+ {
+   FunctionalState state = DISABLE;
+     
+   if (OPT->OPT0_LOCKBYTE == FLASH_READOUTPROTECTION_KEY)
+   {
+     /* The status of the Flash read out protection is enabled*/
+     state = ENABLE;
+   }
+   else
+   {
+     /* The status of the Flash read out protection is disabled*/
+     state = DISABLE;
+   }
+   
+     return state;
+ }
+ 
+ /**
+   * @brief  Returns the Boot memory size in bytes
+   * @param  None
+   * @retval Boot memory size in bytes
+   */
+ uint16_t FLASH_GetBootSize(void)
+ {
+   uint16_t temp = 0;
+ 
+   /* Calculates the number of bytes */
+   temp = (uint16_t)(OPT->OPT2_BOOTSIZE * (uint16_t)64);
+ 
+   /* Correction because size upper 8kb doesn't exist */
+   if (OPT->OPT2_BOOTSIZE > 0x7F)
+   {
+     temp = 8192;
+   }
+ 
+   /* Return value */
+   return(temp);
+ }
+ 
+ /**
+   * @brief  Returns the Code Area size in bytes
+   * @param  None
+   * @retval Code Area size in bytes
+   */
+ uint16_t FLASH_GetDataSize(void)
+ {
+   uint16_t temp = 0;
+   
+   /* Calculates the number of bytes */
+   temp = (uint16_t)((uint16_t)OPT->OPT3_DATASIZE * (uint16_t)64);
+ 
+   /* Correction because size upper of 2kb doesn't exist */
+   if (OPT->OPT3_DATASIZE > 0x20)
+   {
+     temp = 2048;
+   }
+ 
+   /* Return value */
+   return(temp);
+ }
+ /**
+   * @}
+   */
+ 
+ /** @defgroup FLASH_Group4 Interrupts and flags management functions
+  *  @brief   Interrupts and flags management functions
+  *
+ @verbatim   
+  ===============================================================================
+                   Interrupts and flags management functions
+  ===============================================================================  
+ 
+ @endverbatim
+   * @{
+   */
+   
+ /**
+   * @brief  Enables or Disables the Flash interrupt mode
+   * @param  NewState: The new state of the flash interrupt mode
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void FLASH_ITConfig(FunctionalState NewState)
+ {
+   /* Check parameter */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     FLASH->CR1 |= FLASH_CR1_IE; /* Enables the interrupt sources */
+   }
+   else
+   {
+     FLASH->CR1 &= (uint8_t)(~FLASH_CR1_IE); /* Disables the interrupt sources */
+   }
+ }
+ 
+ /**
+   * @brief  Checks whether the specified FLASH flag is set or not.
+   * @param  FLASH_FLAG: specifies the Flash Flag to check.
+   *          This parameter can be one of the following values:
+   *            @arg FLASH_FLAG_DUL: Data EEPROM unlocked
+   *            @arg FLASH_FLAG_EOP: End of programming (write or erase operation)
+   *            @arg FLASH_FLAG_PUL: Flash Program memory unlocked
+   *            @arg FLASH_FLAG_WR_PG_DIS: Write attempted to protected page       
+   * @retval Indicates the state of the Flash_FLAG.
+   *         This parameter can be SET or RESET
+   */
+ FlagStatus FLASH_GetFlagStatus(FLASH_FLAG_TypeDef FLASH_FLAG)
+ {
+   FlagStatus status = RESET;
+   
+   assert_param(IS_FLASH_FLAGS(FLASH_FLAG));
+ 
+   /* Check the status of the specified flash flag*/
+   if ((FLASH->IAPSR  & (uint8_t)FLASH_FLAG) != (uint8_t)RESET)
+   {
+     status = SET; /* FLASH_FLAG is set*/
+   }
+   else
+   {
+     status = RESET; /* FLASH_FLAG is reset*/
+   }
+ 
+   /* Return the Flash_Flag status*/
+   return status;
+ }
+ 
+ /**
+   * @}
+   */ 
+   
+ /** @defgroup FLASH_Group5 Functions to be executed from RAM
+  *  @brief  Functions to be executed from RAM
+  *
+ @verbatim   
+  ===============================================================================
+                          Functions to be executed from RAM
+  ===============================================================================  
+  
+  All the functions defined below must be executed from RAM exclusively, except
+  for the FLASH_WaitForLastOperation function which can be executed from Flash.
+ 
+  Steps of the execution from RAM differs from one toolchain to another:
+  - For Cosmic Compiler:
+   1- Define a segment FLASH_CODE by the mean of " #pragma section (FLASH_CODE)".
+     This segment is defined in the stm8l10x_flash.c file.
+   2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l10x.h file,
+     or define it in Cosmic compiler preprocessor to enable the FLASH_CODE segment
+    definition.
+   3- In STVD Select Project\Settings\Linker\Category "input" and in the RAM section
+     add the FLASH_CODE segment with "-ic" options.
+   4- In main.c file call the _fctcpy() function with first segment character as 
+     parameter "_fctcpy('F');" to load the declared moveable code segment
+     (FLASH_CODE) in RAM before execution.
+   5- By default the _fctcpy function is packaged in the Cosmic machine library,
+     so the function prototype "int _fctcopy(char name);" must be added in main.c
+     file.
+ 
+  - For Raisonance Compiler
+    1- Use the inram keyword in the function declaration to specify that it can be
+     executed from RAM.
+     This is done within the stm8l10x_flash.c file, and it's conditioned by 
+     RAM_EXECUTION definition.
+    2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l10x.h file, or 
+    define it in Raisonance compiler preprocessor to enable the access for the 
+    inram functions.
+    3- An inram function code is copied from Flash to RAM by the C startup code. 
+    In some applications, the RAM area where the code was initially stored may be
+    erased or corrupted, so it may be desirable to perform the copy again. 
+    Depending on the application memory model, the memcpy() or fmemcpy() functions
+    should be used to perform the copy.
+       - In case your project uses the SMALL memory model (code smaller than 64K),
+        memcpy()function is recommended to perform the copy
+       - In case your project uses the LARGE memory model, functions can be 
+       everywhere in the 24-bits address space (not limited to the first 64KB of
+       code), In this case, the use of memcpy() function will not be appropriate,
+       you need to use the specific fmemcpy() function (which copies objects with
+       24-bit addresses).
+       - The linker automatically defines 2 symbols for each inram function:
+            - __address__functionname is a symbol that holds the Flash address 
+            where the given function code is stored.
+            - __size__functionname is a symbol that holds the function size in bytes.
+      And we already have the function address (which is itself a pointer)
+   4- In main.c file these two steps should be performed for each inram function:
+      - Import the "__address__functionname" and "__size__functionname" symbols
+        as global variables:
+          extern int __address__functionname; // Symbol holding the flash address
+          extern int __size__functionname;    // Symbol holding the function size
+      - In case of SMALL memory model use, Call the memcpy() function to copy the
+       inram function to the RAM destination address:
+                 memcpy(functionname, // RAM destination address
+                       (void*)&__address__functionname, // Flash source address
+                       (int)&__size__functionname); // Code size of the function
+      - In case of LARGE memory model use, call the fmemcpy() function to copy 
+      the inram function to the RAM destination address:
+                  memcpy(functionname, // RAM destination address
+                       (void @far*)&__address__functionname, // Flash source address
+                       (int)&__size__functionname); // Code size of the function
+ 
+  - For IAR Compiler:
+     1- Use the __ramfunc keyword in the function declaration to specify that it 
+     can be executed from RAM.
+     This is done within the stm8l10x_flash.c file, and it's conditioned by 
+     RAM_EXECUTION definition.
+     2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l10x.h file, or 
+    define it in IAR compiler preprocessor to enable the access for the 
+    __ramfunc functions.
+  
+ 
+  The Flash_DataProgram example provided within the STM8L10x_StdPeriph_Lib package
+  details all the steps described above.
+ 
+ @endverbatim
+   * @{
+   */
+    
+ /**
+   * @brief
+   *******************************************************************************
+   *                         Execution from RAM enable
+   *******************************************************************************
+   *
+   * To enable execution from RAM you can either uncomment the following define 
+   * in the stm8l10x.h file or define it in your toolchain compiler preprocessor
+   *   #define RAM_EXECUTION  (1) 
+   */
+ 
+ /* SDCC patch: code in RAM not yet patched */
+ #if defined (_SDCC_) && defined (RAM_EXECUTION)
+  #error RAM execution not yet implemented in patch, comment RAM_EXECUTION in stm8s.h
+ #endif
+ 
+ #if defined (_COSMIC_) && defined (RAM_EXECUTION)
+  #pragma section (FLASH_CODE)
+ #endif  /* _COSMIC_ && RAM_EXECUTION */
+ 
+ /**
+   * @brief  Programs a memory block
+   * @note   This function should be called and executed from RAM.
+   * @param  BlockNum: The block number
+   * @param  FLASH_ProgramMode: The programming mode.
+   *          This parameter can be one of the following values:
+   *            @arg FLASH_ProgramMode_Standard: Standard programming mode
+   *            @arg FLASH_ProgramMode_Fast: Fast programming mode
+   * @param  Buffer: Pointer to buffer containing source data.
+   * @retval None
+   */
+ IN_RAM(void FLASH_ProgramBlock(uint8_t BlockNum, FLASH_ProgramMode_TypeDef FLASH_ProgramMode, uint8_t *Buffer))
+ {
+   uint16_t Count = 0;
+   uint16_t StartAddress = 0;
+ 
+   /* Check parameters */
+   assert_param(IS_FLASH_BLOCK_NUMBER(BlockNum));
+   assert_param(IS_FLASH_PROGRAM_MODE(FLASH_ProgramMode));
+ 
+   /* Selection of Standard or Fast programming mode */
+   if (FLASH_ProgramMode == FLASH_ProgramMode_Standard)
+   {
+     /* Standard programming mode */
+     FLASH->CR2 |= FLASH_CR2_PRG;
+   }
+   else
+   {
+     /* Fast programming mode */
+     FLASH->CR2 |= FLASH_CR2_FPRG;
+   }
+   StartAddress = FLASH_START_PHYSICAL_ADDRESS;
+   /* Point to the first Block address */
+   StartAddress = StartAddress + ((uint16_t)BlockNum * (uint16_t)FLASH_BLOCK_SIZE);
+ 
+   /* Copy data bytes from RAM to FLASH memory */
+   for (Count = 0; Count < FLASH_BLOCK_SIZE; Count++)
+   {
+     *((PointerAttr uint8_t*) (uint16_t)StartAddress + Count) = ((uint8_t)(Buffer[Count]));
+   }
+ }
+ 
+ /**
+   * @brief  Erases a block in the program or data memory.
+   * @note   This function should be called and executed from RAM.
+   * @param  BlockNum: Indicates the block number to erase
+   * @param  FLASH_MemType:  The type of memory to erase
+   *          This parameter can be one of the following values:
+   *            @arg FLASH_MemType_Program: Program memory
+   *            @arg FLASH_MemType_Data: Data EEPROM memory 
+   * @retval None.
+   */
+ IN_RAM(void FLASH_EraseBlock(uint8_t BlockNum))
+ {
+   uint32_t PointerAttr *pwFlash;
+   uint16_t StartAddress = 0;
+   /* Check parameters */
+   assert_param(IS_FLASH_BLOCK_NUMBER(BlockNum));
+ 
+   StartAddress = FLASH_START_PHYSICAL_ADDRESS;
+   /* Point to the first block address */
+   pwFlash = (PointerAttr uint32_t *)(uint16_t)(StartAddress + ((uint16_t)BlockNum * (uint16_t)FLASH_BLOCK_SIZE));
+ 
+   /* Enable Word Write Once */
+   FLASH->CR2 |= FLASH_CR2_ERASE;
+ 
+   *pwFlash = (uint32_t)0;
+ }
+   
+ /**
+   * @brief  Waits for a Flash operation to complete.
+   * @note   The call and execution of this function must be done from RAM in case
+   *         of Block operation, otherwise it can be executed from Flash
+   * @param  FLASH_MemType : Memory type
+   *          This parameter can be one of the following values:
+   *            @arg FLASH_MemType_Program: Program memory
+   *            @arg FLASH_MemType_Data: Data EEPROM memory 
+   * @retval FLASH status
+   */
+ IN_RAM(FLASH_Status_TypeDef FLASH_WaitForLastOperation(void))
+ {
+   uint16_t timeout = OPERATION_TIMEOUT;
+   uint8_t My_FlagStatus = 0x00;
+ 
+   /* Wait until operation completion or write protected page occurred */
+   while ((My_FlagStatus == 0x00) && (timeout != 0x00))
+   {
+     My_FlagStatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_EOP | FLASH_IAPSR_WR_PG_DIS));
+     timeout--;
+   }
+ 
+   if (timeout == 0x00)
+   {
+     My_FlagStatus = (uint8_t)FLASH_Status_TimeOut;
+   }
+ 
+   return((FLASH_Status_TypeDef)My_FlagStatus);
+ }
+ 
+ #if defined (_COSMIC_) && defined (RAM_EXECUTION)
+  /* End of FLASH_CODE section */
+  #pragma section ()
+ #endif /* _COSMIC_ && RAM_EXECUTION */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */ 
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */ 
+   
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_gpio.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_gpio.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_gpio.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_gpio.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,363 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_gpio.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the GPIO peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_gpio.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup GPIO 
+   * @brief GPIO driver modules
+   * @{
+   */ 
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /**
+   * @addtogroup GPIO_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
+   * @param  GPIOx Select the GPIO peripheral number (x = A to D).
+   * @retval None
+   */
+ void GPIO_DeInit(GPIO_TypeDef* GPIOx)
+ {
+   GPIOx->ODR = GPIO_ODR_RESET_VALUE; /* Reset Output Data Register */
+   GPIOx->DDR = GPIO_DDR_RESET_VALUE; /* Reset Data Direction Register */
+   GPIOx->CR1 = GPIO_CR1_RESET_VALUE; /* Reset Control Register 1 */
+   GPIOx->CR2 = GPIO_CR2_RESET_VALUE; /* Reset Control Register 2 */
+ }
+ 
+ /**
+   * @brief  Initializes the GPIOx according to the specified parameters.
+   * @param  GPIOx     Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin  This parameter contains the pin number
+   *          This parameter can be any combination of the following values:
+   *            @arg GPIO_Pin_0:   GPIO Pin 0
+   *            @arg GPIO_Pin_1:   GPIO Pin 1
+   *            @arg GPIO_Pin_2:   GPIO Pin 2
+   *            @arg GPIO_Pin_3:   GPIO Pin 3
+   *            @arg GPIO_Pin_4:   GPIO Pin 4
+   *            @arg GPIO_Pin_5:   GPIO Pin 5
+   *            @arg GPIO_Pin_6:   GPIO Pin 6
+   *            @arg GPIO_Pin_7:   GPIO Pin 7
+   *            @arg GPIO_Pin_LNib:  Low nibble pins
+   *            @arg GPIO_Pin_HNib:  High nibble pins
+   *            @arg GPIO_Pin_All:   All pins                    
+   * @param  GPIO_Mode Select the mode
+   *          This parameter can be any combination of the following values:
+   *           This parameter can be one of the following values:
+   *            @arg GPIO_Mode_In_FL_No_IT: Input floating, no external interrupt
+   *            @arg GPIO_Mode_In_PU_No_IT: Input pull-up, no external interrupt
+   *            @arg GPIO_Mode_In_FL_IT: Input floating, external interrupt
+   *            @arg GPIO_Mode_In_PU_IT: Input pull-up, external interrupt  
+   *            @arg GPIO_Mode_Out_OD_Low_Fast: Output open-drain, low level, 10MHz
+   *            @arg GPIO_Mode_Out_PP_Low_Fast: Output push-pull, low level, 10MHz
+   *            @arg GPIO_Mode_Out_OD_Low_Slow: Output open-drain, low level, 2MHz
+   *            @arg GPIO_Mode_Out_PP_Low_Slow: Output push-pull, low level, 2MHz
+   *            @arg GPIO_Mode_Out_OD_HiZ_Fast: Output open-drain, high-impedance level, 10MHz
+   *            @arg GPIO_Mode_Out_PP_High_Fast: Output push-pull, high level, 10MHz
+   *            @arg GPIO_Mode_Out_OD_HiZ_Slow: Output open-drain, high-impedance level, 2MHz
+   *            @arg GPIO_Mode_Out_PP_High_Slow: Output push-pull, high level, 2MHz
+   * @retval None
+   */
+ void GPIO_Init(GPIO_TypeDef* GPIOx,
+                uint8_t GPIO_Pin,
+                GPIO_Mode_TypeDef GPIO_Mode)
+ {
+   /*----------------------*/
+   /* Check the parameters */
+   /*----------------------*/
+ 
+   assert_param(IS_GPIO_MODE(GPIO_Mode));
+   assert_param(IS_GPIO_PIN(GPIO_Pin));
+ 
+   /*-----------------------------*/
+   /* Input/Output mode selection */
+   /*-----------------------------*/
+ 
+   if ((((uint8_t)(GPIO_Mode)) & (uint8_t)0x80) != (uint8_t)0x00) /* Output mode */
+   {
+     if ((((uint8_t)(GPIO_Mode)) & (uint8_t)0x10) != (uint8_t)0x00) /* High level */
+     {
+       GPIOx->ODR |= GPIO_Pin;
+     } else /* Low level */
+     {
+       GPIOx->ODR &= (uint8_t)(~(GPIO_Pin));
+     }
+     /* Set Output mode */
+     GPIOx->DDR |= GPIO_Pin;
+   } else /* Input mode */
+   {
+     /* Set Input mode */
+     GPIOx->DDR &= (uint8_t)(~(GPIO_Pin));
+   }
+ 
+   /*------------------------------------------------------------------------*/
+   /* Pull-Up/Float (Input) or Push-Pull/Open-Drain (Output) modes selection */
+   /*------------------------------------------------------------------------*/
+ 
+   if ((((uint8_t)(GPIO_Mode)) & (uint8_t)0x40) != (uint8_t)0x00) /* Pull-Up or Push-Pull */
+   {
+     GPIOx->CR1 |= GPIO_Pin;
+   } else /* Float or Open-Drain */
+   {
+     GPIOx->CR1 &= (uint8_t)(~(GPIO_Pin));
+   }
+ 
+   /*-----------------------------------------------------*/
+   /* Interrupt (Input) or Slope (Output) modes selection */
+   /*-----------------------------------------------------*/
+ 
+   if ((((uint8_t)(GPIO_Mode)) & (uint8_t)0x20) != (uint8_t)0x00) /* Interrupt or Slow slope */
+   {
+     GPIOx->CR2 |= GPIO_Pin;
+   } else /* No external interrupt or No slope control */
+   {
+     GPIOx->CR2 &= (uint8_t)(~(GPIO_Pin));
+   }
+ 
+ }
+ 
+ /**
+   * @brief  Writes data to the specified GPIO data port.
+   * @note   The port must be configured in output mode.
+   * @param  GPIOx  Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_PortVal Specifies the value to be written to the port output data register.
+   * @retval None
+   */
+ void GPIO_Write(GPIO_TypeDef* GPIOx, uint8_t GPIO_PortVal)
+ {
+   GPIOx->ODR = GPIO_PortVal;
+ }
+ 
+ /**
+   * @brief  Sets or clears the selected data port bit.
+   * @param  GPIOx       Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin: Specifies the port bit to be written.
+   *           This parameter can be one of the following values:
+   *            @arg GPIO_Pin_0: Pin 0
+   *            @arg GPIO_Pin_1: Pin 1
+   *            @arg GPIO_Pin_2: Pin 2
+   *            @arg GPIO_Pin_3: Pin 3
+   *            @arg GPIO_Pin_4: Pin 4
+   *            @arg GPIO_Pin_5: Pin 5
+   *            @arg GPIO_Pin_6: Pin 6
+   *            @arg GPIO_Pin_7: Pin 7   
+   * @param  GPIO_BitVal: specifies the desired status to be written.
+   *         This parameter can be SET or RESET
+   * @retval None
+   */
+ void GPIO_WriteBit(GPIO_TypeDef* GPIOx, GPIO_Pin_TypeDef GPIO_Pin, BitAction GPIO_BitVal)
+ {
+   /* Check the parameters */
+   assert_param(IS_GPIO_PIN(GPIO_Pin));
+   assert_param(IS_STATE_VALUE(GPIO_BitVal));
+ 
+   if (GPIO_BitVal != RESET)
+   {
+     SetBit(GPIOx->ODR, GPIO_Pin);
+ 
+   }
+   else
+   {
+     ClrBit(GPIOx->ODR, GPIO_Pin);
+   }
+ }
+ 
+ /**
+   * @brief  Writes high level to the specified GPIO pins.
+   * @note   The port must be configured in output mode.
+   * @param  GPIOx    Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin : Specifies the pins to be turned high.
+   *           This parameter can be one of the following values:
+   *            @arg GPIO_Pin_0: Pin 0
+   *            @arg GPIO_Pin_1: Pin 1
+   *            @arg GPIO_Pin_2: Pin 2
+   *            @arg GPIO_Pin_3: Pin 3
+   *            @arg GPIO_Pin_4: Pin 4
+   *            @arg GPIO_Pin_5: Pin 5
+   *            @arg GPIO_Pin_6: Pin 6
+   *            @arg GPIO_Pin_7: Pin 7.
+   * @retval None
+   */
+ void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin)
+ {
+   GPIOx->ODR |= GPIO_Pin;
+ }
+ 
+ /**
+   * @brief  Writes low level to the specified GPIO pins.
+   * @note   The port must be configured in output mode.
+   * @param  GPIOx    Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin : Specifies the pins to be turned low
+   *           This parameter can be one of the following values:
+   *            @arg GPIO_Pin_0: Pin 0
+   *            @arg GPIO_Pin_1: Pin 1
+   *            @arg GPIO_Pin_2: Pin 2
+   *            @arg GPIO_Pin_3: Pin 3
+   *            @arg GPIO_Pin_4: Pin 4
+   *            @arg GPIO_Pin_5: Pin 5
+   *            @arg GPIO_Pin_6: Pin 6
+   *            @arg GPIO_Pin_7: Pin 7 
+   * @retval None
+   */
+ void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin)
+ {
+   GPIOx->ODR &= (uint8_t)(~GPIO_Pin);
+ }
+ 
+ /**
+   * @brief  Toggles the specified GPIO pins.
+   * @note   The port must be configured in output mode.
+   * @param  GPIOx    Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin Specifies the pins to be toggled data register.
+   * @retval None
+   */
+ void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin)
+ {
+   GPIOx->ODR ^= GPIO_Pin;
+ }
+ 
+ /**
+   * @brief  Reads the specified GPIO input data port.
+   * @note   The port must be configured in input mode.
+   * @param  GPIOx Select the GPIO peripheral number (x = A to D).
+   * @retval uint8_t GPIO input data port value.
+   */
+ uint8_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
+ {
+   return ((uint8_t)GPIOx->IDR);
+ }
+ 
+ /**
+   * @brief  Reads the specified GPIO output data port.
+   * @note   The port must be configured in input mode.
+   * @param  GPIOx Select the GPIO peripheral number (x = A to D).
+   * @retval uint8_t GPIO output data port value.
+   */
+ uint8_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
+ {
+   return ((uint8_t)GPIOx->ODR);
+ }
+ 
+ /**
+   * @brief  Reads the specified GPIO input data pin.
+   * @note   The port must be configured in output mode.
+   * @param  GPIOx    Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin This parameter contains the pin number
+   *           This parameter can be one of the following values:
+   *            @arg GPIO_Pin_0: Pin 0
+   *            @arg GPIO_Pin_1: Pin 1
+   *            @arg GPIO_Pin_2: Pin 2
+   *            @arg GPIO_Pin_3: Pin 3
+   *            @arg GPIO_Pin_4: Pin 4
+   *            @arg GPIO_Pin_5: Pin 5
+   *            @arg GPIO_Pin_6: Pin 6
+   *            @arg GPIO_Pin_7: Pin 7   
+   * @retval BitStatus GPIO input pin status.
+   */
+ BitStatus GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, GPIO_Pin_TypeDef GPIO_Pin)
+ {
+   return ((BitStatus)(GPIOx->IDR & (uint8_t)GPIO_Pin));
+ }
+ 
+ /**
+   * @brief  Reads the specified GPIO Output data pin.
+   * @note   The port must be configured in input mode.
+   * @param  GPIOx    Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin This parameter contains the pin number
+   *           This parameter can be one of the following values:
+   *            @arg GPIO_Pin_0: Pin 0
+   *            @arg GPIO_Pin_1: Pin 1
+   *            @arg GPIO_Pin_2: Pin 2
+   *            @arg GPIO_Pin_3: Pin 3
+   *            @arg GPIO_Pin_4: Pin 4
+   *            @arg GPIO_Pin_5: Pin 5
+   *            @arg GPIO_Pin_6: Pin 6
+   *            @arg GPIO_Pin_7: Pin 7   
+   * @retval GPIO output pin status.
+   */
+ BitStatus GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, GPIO_Pin_TypeDef GPIO_Pin)
+ {
+   return ((BitStatus)(GPIOx->ODR & (uint8_t)GPIO_Pin));
+ }
+ 
+ /**
+   * @brief  Configures the external pull-up on GPIOx pins.
+   * @param  GPIOx    Select the GPIO peripheral number (x = A to D).
+   * @param  GPIO_Pin : Specifies the pin number
+   *           This parameter can be one of the following values:
+   *            @arg GPIO_Pin_0: Pin 0
+   *            @arg GPIO_Pin_1: Pin 1
+   *            @arg GPIO_Pin_2: Pin 2
+   *            @arg GPIO_Pin_3: Pin 3
+   *            @arg GPIO_Pin_4: Pin 4
+   *            @arg GPIO_Pin_5: Pin 5
+   *            @arg GPIO_Pin_6: Pin 6
+   *            @arg GPIO_Pin_7: Pin 7     
+   * @param  NewState : The new state of the pull up pin.
+   *           Can be ENABLE or DISABLE  
+   * @retval None
+   */
+ void GPIO_ExternalPullUpConfig(GPIO_TypeDef* GPIOx, uint8_t GPIO_Pin, FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_GPIO_PIN(GPIO_Pin));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE) /* External Pull-Up Set*/
+   {
+     GPIOx->CR1 |= GPIO_Pin;
+   } else /* External Pull-Up Reset*/
+   {
+     GPIOx->CR1 &= (uint8_t)(~(GPIO_Pin));
+   }
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_i2c.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_i2c.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_i2c.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_i2c.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,1012 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_i2c.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file provides firmware functions to manage the following
+   *          functionalities of the Inter-integrated circuit (I2C)
+   *           - Initialization and Configuration
+   *           - Data transfers
+   *           - Interrupts, events and flags management
+   *
+   *  @verbatim
+   *
+   *          ===================================================================
+   *                                 How to use this driver
+   *          ===================================================================
+   *          1. Enable peripheral clock using CLK_PeripheralClockConfig(CLK_Peripheral_I2C,
+   *             ENABLE) function
+   *
+   *          2. Program the duty cycle , Own address, Ack, Speed and Acknowledged
+   *             Address using the I2C_Init() function.
+   *
+   *          3. Optionally you can enable/configure the following parameters without
+   *             re-initialization (i.e there is no need to call again I2C_Init() function):
+   *              - Enable the acknowledge feature using I2C_AcknowledgeConfig() function
+   *              - Enable the general call using the I2C_GeneralCallCmd() function
+   *              - Enable the clock stretching using I2C_StretchClockCmd() function
+   *              - Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
+   *                function
+   *
+   *          4. Enable the interrupt using the function I2C_ITConfig() if you need
+   *             to use interrupt mode.
+   *
+   *          5. Enable the I2C using the I2C_Cmd() function.
+   *
+   *         Note: The external Pull-up resistors must be connected on SDA and SCL.
+   *
+   *  @endverbatim
+   *
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_clk.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ 
+ /** @defgroup I2C
+   * @brief I2C driver modules
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /** @defgroup I2C_Private_Define
+   * @{
+   */
+ 
+ /* I2C register mask */
+ #define REGISTER_Mask               ((uint16_t)0x3000)
+ #define REGISTER_SR1_Index          ((uint16_t)0x0100)
+ #define REGISTER_SR2_Index          ((uint16_t)0x0200)
+ /* I2C Interrupt Enable mask */
+ #define ITEN_Mask                   ((uint16_t)0x0700)
+ /* I2C FLAG mask */
+ #define FLAG_Mask                   ((uint16_t)0x00FF)
+ /* I2C ADD0 mask */
+ #define OAR1_ADD0_Set               ((uint8_t)0x01)
+ #define OAR1_ADD0_Reset             ((uint8_t)0xFE)
+ 
+ /**
+   * @}
+   */
+ 
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /** @defgroup I2C_Private_Functions
+   * @{
+   */
+ 
+ /** @defgroup I2C_Group1 Initialization and Configuration functions
+  *  @brief   Initialization and Configuration functions
+  *
+ @verbatim
+  ===============================================================================
+                    Initialization and Configuration functions
+  ===============================================================================
+ 
+ @endverbatim
+   * @{
+   */
+ 
+ /**
+   * @brief Deinitializes the I2C peripheral registers to their default reset values.
+   * @param None
+   * @retval None
+   */
+ void I2C_DeInit(void)
+ {
+   I2C->CR1 = I2C_CR1_RESET_VALUE;
+   I2C->CR2 = I2C_CR2_RESET_VALUE;
+   I2C->FREQR = I2C_FREQR_RESET_VALUE;
+   I2C->OARL = I2C_OARL_RESET_VALUE;
+   I2C->OARH = I2C_OARH_RESET_VALUE;
+   I2C->ITR = I2C_ITR_RESET_VALUE;
+   I2C->CCRL = I2C_CCRL_RESET_VALUE;
+   I2C->CCRH = I2C_CCRH_RESET_VALUE;
+   I2C->TRISER = I2C_TRISER_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief Initializes the I2C according to the specified parameters in standard or fast mode.
+   * @param  OutputClockFrequency: Specifies the output clock frequency in Hz.
+   * @param  OwnAddress: Specifies the own address.
+   * @param  I2C_DutyCycle: Specifies the duty cycle to apply in fast mode.
+   *          This parameter can be one of the following values:
+   *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
+   *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
+   * @note   The I2C_DutyCycle parameter doesn't have impact when the OutputClockFrequency
+   *         is lower than 100KHz.
+   * @param  I2C_Ack: Specifies the acknowledge mode to apply.
+   *          This parameter can be one of the following values:
+   *            @arg I2C_Ack_Disable: No acknowledge
+   *            @arg I2C_Ack_Enable: Acknowledge Enabled
+   * @param  I2C_AcknowledgedAddress: Specifies the acknowledge address to apply.
+   *          This parameter can be one of the following values:
+   *            @arg I2C_AcknowledgedAddress_7bit: 7-bit slave address
+   *            @arg I2C_AcknowledgedAddress_10bit: 10-bit slave address
+   * @note   To use the I2C at 400 KHz (in fast mode), the PCLK frequency
+   *         (I2C peripheral input clock) must be a multiple of 10 MHz.
+   * @retval None
+   */
+ void I2C_Init(uint32_t OutputClockFrequency, uint16_t OwnAddress,
+               I2C_DutyCycle_TypeDef I2C_DutyCycle, I2C_Ack_TypeDef I2C_Ack,
+               I2C_AcknowledgedAddress_TypeDef I2C_AcknowledgedAddress)
+ {
+   uint32_t result = 0x0004;
+   uint16_t tmpval = 0;
+   uint8_t tmpccrh = 0;
+   uint8_t input_clock = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_I2C_OUTPUT_CLOCK_FREQ(OutputClockFrequency));
+   assert_param(IS_I2C_OWN_ADDRESS(OwnAddress));
+   assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
+   assert_param(IS_I2C_ACK_STATE(I2C_Ack));
+   assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_AcknowledgedAddress));
+ 
+   /* Get system clock frequency */
+   input_clock = (uint8_t)(CLK_GetClockFreq() / 1000000);
+ 
+   /*------------------------- I2C FREQ Configuration ------------------------*/
+   /* Clear frequency bits */
+   I2C->FREQR &= (uint8_t)(~I2C_FREQR_FREQ);
+   /* Write new value */
+   I2C->FREQR |= input_clock;
+ 
+   /*--------------------------- I2C CCR Configuration ------------------------*/
+   /* Disable I2C to configure TRISER */
+   I2C->CR1 &= (uint8_t)(~I2C_CR1_PE);
+ 
+   /* Clear CCRH & CCRL */
+   I2C->CCRH &= (uint8_t)(~(I2C_CCRH_FS | I2C_CCRH_DUTY | I2C_CCRH_CCR));
+   I2C->CCRL &= (uint8_t)(~I2C_CCRL_CCR);
+ 
+   /* Detect Fast or Standard mode depending on the Output clock frequency selected */
+   if (OutputClockFrequency > I2C_MAX_STANDARD_FREQ) /* FAST MODE */
+   {
+     /* Set F/S bit for fast mode */
+     tmpccrh = I2C_CCRH_FS;
+ 
+     if (I2C_DutyCycle == I2C_DutyCycle_2)
+     {
+       /* Fast mode speed calculate: Tlow/Thigh = 2 */
+       result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 3));
+     }
+     else /* I2C_DutyCycle_16_9 */
+     {
+       /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
+       result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 25));
+       /* Set DUTY bit */
+       tmpccrh |= I2C_CCRH_DUTY;
+     }
+ 
+     /* Verify and correct CCR value if below minimum value */
+     if (result < (uint16_t)0x0001)
+     {
+       /* Set the minimum allowed value */
+       result = (uint16_t)0x0001;
+     }
+ 
+     /* Set Maximum Rise Time: 300ns max in Fast Mode
+        = [300ns/(1/input_clock.10e6)]+1
+        = [(input_clock * 3)/10]+1 */
+     tmpval = ((input_clock * 3) / 10) + 1;
+     I2C->TRISER = (uint8_t)tmpval;
+ 
+   }
+   else /* STANDARD MODE */
+   {
+     /* Calculate standard mode speed */
+     result = (uint16_t)((input_clock * 1000000) / (OutputClockFrequency << (uint8_t)1));
+ 
+     /* Verify and correct CCR value if below minimum value */
+     if (result < (uint16_t)0x0004)
+     {
+       /* Set the minimum allowed value */
+       result = (uint16_t)0x0004;
+     }
+ 
+     /* Set Maximum Rise Time: 1000ns max in Standard Mode
+      = [1000ns/(1/input_clock.10e6)]+1
+      = input_clock+1 */
+      I2C->TRISER = (uint8_t)((uint8_t)input_clock + (uint8_t)1);
+   }
+ 
+   /* Write CCR with new calculated value */
+   I2C->CCRL = (uint8_t)result;
+   I2C->CCRH = (uint8_t)((uint8_t)((uint8_t)((uint8_t)result >> 8) & I2C_CCRH_CCR) | tmpccrh);
+ 
+   /* Enable I2C */
+     I2C->CR1 |= I2C_CR1_PE;
+ 
+   /* Clear the I2C Ack bit */
+   I2C->CR2 &= (uint8_t)(~I2C_CR2_ACK);
+   
+   /* Configure I2C acknowledgement */
+   I2C->CR2 |= (uint8_t)I2C_Ack;
+ 
+     /*--------------------------- I2C OAR Configuration ------------------------*/
+     I2C->OARL = (uint8_t)(OwnAddress);
+     I2C->OARH = (uint8_t)((uint8_t)(I2C_AcknowledgedAddress | I2C_OARH_ADDCONF) |
+                          (uint8_t)((uint16_t)( (uint16_t)OwnAddress &  (uint16_t)0x0300) >> 7));
+ }
+ 
+ /**
+   * @brief Enables or disables the I2C peripheral.
+   * @param  NewState: Indicate the new I2C peripheral state.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_Cmd(FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable I2C peripheral */
+     I2C->CR1 |= I2C_CR1_PE;
+   }
+   else
+   {
+     /* Disable I2C peripheral */
+     I2C->CR1 &= (uint8_t)(~I2C_CR1_PE);
+   }
+ }
+ 
+ /**
+   * @brief Enables or disables the I2C General Call feature.
+   * @param  NewState: State of the General Call feature.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_GeneralCallCmd(FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable General Call */
+     I2C->CR1 |= I2C_CR1_ENGC;
+   }
+   else
+   {
+     /* Disable General Call */
+     I2C->CR1 &= (uint8_t)(~I2C_CR1_ENGC);
+   }
+ }
+ 
+ /**
+   * @brief Generates I2C communication START condition.
+   * @note   CCR must be programmed, i.e. I2C_Init function must have been called
+   *         with a valid I2C_ClockSpeed
+   * @param  NewState: Enable or disable the start condition.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_GenerateSTART(FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Generate a START condition */
+     I2C->CR2 |= I2C_CR2_START;
+   }
+   else
+   {
+     /* Disable the START condition generation */
+     I2C->CR2 &= (uint8_t)(~I2C_CR2_START);
+   }
+ }
+ 
+ /**
+   * @brief Generates I2C communication STOP condition.
+   * @param  NewState: Enable or disable the stop condition.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_GenerateSTOP(FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Generate a STOP condition */
+     I2C->CR2 |= I2C_CR2_STOP;
+   }
+   else /* NewState == DISABLE */
+   {
+     /* Disable the STOP condition generation */
+     I2C->CR2 &= (uint8_t)(~I2C_CR2_STOP);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables I2C software reset.
+   * @note   Before calling this function with the ENABLE parameter, make sure that
+   *         the I2C lines are released and the bus is free.
+   * @param  NewState: Specifies the new state of the I2C software reset.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_SoftwareResetCmd(FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Peripheral under reset */
+     I2C->CR2 |= I2C_CR2_SWRST;
+   }
+   else
+   {
+     /* Peripheral not under reset */
+     I2C->CR2 &= (uint8_t)(~I2C_CR2_SWRST);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the I2C clock stretching.
+   * @param  NewState: Specifies the new state of the I2C Clock stretching.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_StretchClockCmd(FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Clock Stretching Enable */
+     I2C->CR1 &= (uint8_t)(~I2C_CR1_NOSTRETCH);
+   }
+   else /* NewState == DISABLE */
+   {
+     /* Clock Stretching Disable (Slave mode) */
+     I2C->CR1 |= I2C_CR1_NOSTRETCH;
+   }
+ }
+ 
+ /**
+   * @brief  Enable or Disable the I2C acknowledge feature.
+   * @param  NewState: Specifies the new state of the I2C acknowledge.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_AcknowledgeConfig(FunctionalState NewState)
+ {
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the acknowledgement */
+     I2C->CR2 |= I2C_CR2_ACK;
+   }
+   else
+   {
+     /* Disable the acknowledgement */
+     I2C->CR2 &= (uint8_t)(~I2C_CR2_ACK);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the specified I2C Ack position.
+   * @note   This function must be called before data reception starts.
+   * @param  I2C_AckPosition: specifies the Ack position.
+   *          This parameter can be one of the following values:
+   *            @arg I2C_AckPosition_Current: Acknowledge on the current byte
+   *            @arg I2C_AckPosition_Next: Acknowledge on the next byte
+   * @retval None
+   */
+ void I2C_AckPositionConfig(I2C_AckPosition_TypeDef I2C_AckPosition)
+ {
+   /* Check function parameters */
+   assert_param(IS_I2C_ACK_POSITION(I2C_AckPosition));
+ 
+   /* Clear the I2C Ack position */
+   I2C->CR2 &= (uint8_t)(~I2C_CR2_POS);
+ 
+   /* Configure the specified I2C Ack position*/
+   I2C->CR2 |= (uint8_t)I2C_AckPosition;
+ }
+ 
+ /**
+   * @brief  Selects I2C fast mode duty cycle.
+   * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
+   *          This parameter can be one of the following values:
+   *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
+   *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
+   * @retval None
+   */
+ void I2C_FastModeDutyCycleConfig(I2C_DutyCycle_TypeDef I2C_DutyCycle)
+ {
+   /* Check function parameters */
+   assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
+ 
+   if (I2C_DutyCycle == I2C_DutyCycle_16_9)
+   {
+     /* I2C fast mode Tlow/Thigh = 16/9 */
+     I2C->CCRH |= I2C_CCRH_DUTY;
+   }
+   else /* I2C_DUTYCYCLE_2 */
+   {
+     /* I2C fast mode Tlow/Thigh = 2 */
+     I2C->CCRH &= (uint8_t)(~I2C_CCRH_DUTY);
+   }
+ }
+ 
+ /**
+   * @brief  Transmits the 7-bit address (to select the) slave device.
+   * @param  Address: Specifies the slave address which will be transmitted.
+   * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
+   *         or a Receiver.
+   *          This parameter can be one of the following values
+   *            @arg I2C_Direction_Transmitter: Transmitter mode
+   *            @arg I2C_Direction_Receiver: Receiver mode
+   * @retval None
+   */
+ void I2C_Send7bitAddress(uint8_t Address, I2C_Direction_TypeDef I2C_Direction)
+ {
+   /* Check function parameters */
+   assert_param(IS_I2C_ADDRESS(Address));
+   assert_param(IS_I2C_DIRECTION(I2C_Direction));
+ 
+   /* Test on the direction to set/reset the read/write bit */
+   if (I2C_Direction != I2C_Direction_Transmitter)
+   {
+     /* Set the address bit0 for read */
+     Address |= OAR1_ADD0_Set;
+   }
+   else
+   {
+     /* Reset the address bit0 for write */
+     Address &= OAR1_ADD0_Reset;
+   }
+   /* Send the address */
+   I2C->DR = Address;
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /** @defgroup I2C_Group2 Data transfers functions
+  *  @brief   Data transfers functions
+  *
+ @verbatim
+  ===============================================================================
+                         Data transfers functions
+  ===============================================================================
+ 
+ @endverbatim
+   * @{
+   */
+ 
+ /**
+   * @brief  Send a byte by writing in the DR register.
+   * @param  Data: Byte to be sent.
+   * @retval None
+   */
+ void I2C_SendData(uint8_t Data)
+ {
+   /* Write in the DR register the data to be sent */
+   I2C->DR = Data;
+ }
+ 
+ /**
+   * @brief  Returns the most recent received data.
+   * @param  None
+   * @retval The value of the received byte data.
+   */
+ uint8_t I2C_ReceiveData(void)
+ {
+   /* Return the data present in the DR register */
+   return ((uint8_t)I2C->DR);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /** @defgroup I2C_Group3 Interrupts events and flags management functions
+  *  @brief   Interrupts, events and flags management functions
+  *
+ @verbatim
+  ===============================================================================
+                 Interrupts, events and flags management functions
+  ===============================================================================
+   This section provides functions allowing to configure the I2C Interrupts
+   sources and check or clear the flags or pending bits status.
+   The user should identify which mode will be used in his application to manage
+   the communication: Polling mode or Interrupt mode.
+ 
+  ===============================================================================
+                           I2C State Monitoring Functions
+  ===============================================================================
+  This I2C driver provides three different ways for I2C state monitoring
+   depending on the application requirements and constraints:
+ 
+ 
+      1. Basic state monitoring (Using I2C_CheckEvent() function)
+      -----------------------------------------------------------
+     It compares the status registers (SR1, SR2 and SR3) content to a given event
+     (can be the combination of one or more flags).
+     It returns SUCCESS if the current status includes the given flags
+     and returns ERROR if one or more flags are missing in the current status.
+     - When to use:
+       - This function is suitable for most applications as well as for startup
+       activity since the events are fully described in the product reference manual
+       (RM0013).
+       - It is also suitable for users who need to define their own events.
+     - Limitations:
+       - If an error occurs (ie. error flags are set besides to the monitored flags),
+         the I2C_CheckEvent() function may return SUCCESS despite the communication
+         hold or corrupted real state.
+         In this case, it is advised to use error interrupts to monitor the error
+         events and handle them in the interrupt IRQ handler.
+ 
+         @note
+         For error management, it is advised to use the following functions:
+           - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
+           - I2C_IRQHandler() which is called when the I2C interrupts occur.
+           - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into the
+             I2C_IRQHandler() function in order to determine which error occurred.
+           - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
+             and/or I2C_GenerateStop() in order to clear the error flag and
+             source and return to correct communication status.
+ 
+ 
+      2. Advanced state monitoring (Using the function I2C_GetLastEvent())
+      --------------------------------------------------------------------
+      Using the function I2C_GetLastEvent() which returns the image of both SR1
+      & SR3 status registers in a single word (uint16_t) (Status Register 3 value
+      is shifted left by 8 bits and concatenated to Status Register 1).
+      - When to use:
+        - This function is suitable for the same applications above but it allows to
+          overcome the limitations of I2C_GetFlagStatus() function (see below).
+          The returned value could be compared to events already defined in the
+          library (stm8l10x_i2c.h) or to custom values defined by user.
+        - This function is suitable when multiple flags are monitored at the same time.
+        - At the opposite of I2C_CheckEvent() function, this function allows user to
+          choose when an event is accepted (when all events flags are set and no
+          other flags are set or just when the needed flags are set like
+          I2C_CheckEvent() function).
+      - Limitations:
+        - User may need to define his own events.
+        - Same remark concerning the error management is applicable for this
+          function if user decides to check only regular communication flags (and
+          ignores error flags).
+ 
+ 
+      3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
+      -----------------------------------------------------------------------
+      Using the function I2C_GetFlagStatus() which simply returns the status of
+      one single flag (ie. I2C_FLAG_RXNE ...).
+      - When to use:
+         - This function could be used for specific applications or in debug phase.
+         - It is suitable when only one flag checking is needed (most I2C events
+           are monitored through multiple flags).
+      - Limitations:
+         - When calling this function, the Status register is accessed. Some flags are
+           cleared when the status register is accessed. So checking the status
+           of one Flag, may clear other ones.
+         - Function may need to be called twice or more in order to monitor one
+           single event.
+ 
+   For detailed description of Events, please refer to section I2C_Events in
+   stm8l10x_i2c.h file.
+ 
+ 
+ @endverbatim
+   * @{
+   */
+ 
+ /**
+   * @brief  Enables or disables the specified I2C interrupt.
+   * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled.
+   *          This parameter can be any combination of the following values:
+   *            @arg I2C_IT_BUF: Buffer interrupt mask
+   *            @arg I2C_IT_EVT: Event interrupt mask
+   *            @arg I2C_IT_ERR: Error interrupt mask
+   * @param  NewState: State of the interrupt.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void I2C_ITConfig(I2C_IT_TypeDef I2C_IT, FunctionalState NewState)
+ {
+   /* Check functions parameters */
+   assert_param(IS_I2C_CONFIG_IT(I2C_IT));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the selected I2C interrupts */
+     I2C->ITR |= (uint8_t)I2C_IT;
+   }
+   else /* NewState == DISABLE */
+   {
+     /* Disable the selected I2C interrupts */
+     I2C->ITR &= (uint8_t)(~(uint8_t)I2C_IT);
+   }
+ }
+ /**
+  ===============================================================================
+                           1. Basic state monitoring
+  ===============================================================================
+  */
+ 
+ /**
+   * @brief  Checks whether the last I2C Event is equal to the one passed
+   *   as parameter.
+   * @param  I2C_EVENT: specifies the event to be checked.
+   *          This parameter can be one of the following values:
+   *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
+   *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
+   *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
+   *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
+   *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
+   *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
+   *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
+   *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
+   *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
+   *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
+   *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6
+   *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
+   *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
+   *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
+   *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
+   *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
+   *
+   * @note: For detailed description of Events, please refer to section
+   *    I2C_Events in stm8l10x_i2c.h file.
+   *
+   * @retval An ErrorStatus enumeration value:
+   *         - SUCCESS: Last event is equal to the I2C_EVENT
+   *         - ERROR: Last event is different from the I2C_EVENT
+   */
+ ErrorStatus I2C_CheckEvent(I2C_Event_TypeDef I2C_Event)
+ {
+   uint16_t lastevent = 0;
+   uint8_t flag1= 0;
+   uint8_t flag2= 0;
+   ErrorStatus status = ERROR;
+ 
+   /* Check the parameters */
+   assert_param(IS_I2C_EVENT(I2C_Event));
+ 
+   if (I2C_Event == I2C_EVENT_SLAVE_ACK_FAILURE)
+   {
+     /* This flag is reset only by writing 0 in the AF bit or by disabling the I2C peripheral */
+       lastevent = (uint16_t)(I2C->SR2& I2C_SR2_AF);
+   }
+   else
+   {
+     /* Read flags */
+     flag1 = I2C->SR1;
+     flag2 = I2C->SR3;
+     lastevent = ((uint16_t)((uint16_t)flag2 << (uint16_t)8) | (uint16_t)flag1);
+   }
+ 
+   /* Check whether the last event is equal to I2C_EVENT */
+   if (((uint16_t)lastevent & (uint16_t)I2C_Event) == (uint16_t)I2C_Event)
+   {
+     /* SUCCESS: last event is equal to I2C_EVENT */
+     status = SUCCESS;
+   }
+   else
+   {
+     /* ERROR: last event is different from I2C_EVENT */
+     status = ERROR;
+   }
+ 
+   /* Return status */
+   return status;
+ }
+ 
+ /**
+  ===============================================================================
+                           2. Advanced state monitoring
+  ===============================================================================
+  */
+ 
+ /**
+   * @brief  Returns the last I2C Event.
+   * @param  None
+   *
+   * @note: For detailed description of Events, please refer to section
+   *    I2C_Events in stm8l10x_i2c.h file.
+   *
+   * @retval The last event
+   */
+ I2C_Event_TypeDef I2C_GetLastEvent(void)
+ {
+   __IO uint16_t lastevent = 0;
+   uint16_t flag1 = 0;
+   uint16_t flag2 = 0;
+ 
+   if ((I2C->SR2 & I2C_SR2_AF) != 0x00)
+   {
+     lastevent = I2C_EVENT_SLAVE_ACK_FAILURE;
+   }
+   else
+   {
+     /* Read the I2C status register */
+     flag1 = I2C->SR1;
+     flag2 = I2C->SR3;
+ 
+     /* Get the last event value from I2C status register */
+     lastevent = ((uint16_t)((uint16_t)flag2 << 8) | (uint16_t)flag1);
+   }
+   /* Return status */
+   return (I2C_Event_TypeDef)lastevent;
+ }
+ 
+ /**
+  ===============================================================================
+                           3. Flag-based state monitoring
+  ===============================================================================
+  */
+ 
+ /**
+   * @brief  Checks whether the specified I2C flag is set or not.
+   * @param  I2C_FLAG: specifies the flag to check.
+   *          This parameter can be one of the following values:
+   *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
+   *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
+   *            @arg I2C_FLAG_BUSY: Bus busy flag
+   *            @arg I2C_FLAG_MSL: Master/Slave flag
+   *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+   *            @arg I2C_FLAG_AF: Acknowledge failure flag
+   *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+   *            @arg I2C_FLAG_BERR: Bus error flag
+   *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
+   *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
+   *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
+   *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
+   *            @arg I2C_FLAG_BTF: Byte transfer finished flag
+   *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) ADSL
+   *   Address matched flag (Slave mode)ENDAD
+   *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
+   * @retval The new state of I2C_FLAG (SET or RESET).
+   */
+ FlagStatus I2C_GetFlagStatus(I2C_FLAG_TypeDef I2C_FLAG)
+ {
+   uint8_t tempreg = 0;
+   uint8_t regindex = 0;
+   FlagStatus bitstatus = RESET;
+ 
+   /* Check the parameters */
+   assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
+ 
+   /* Read flag register index (see I2C_FLAG_TypeDef definition) */
+   regindex = (uint8_t)((uint16_t)I2C_FLAG >> 8);
+ 
+   /* Check SRx index */
+   switch (regindex)
+   {
+       /* Returns whether the status register to check is SR1 */
+     case 0x01:
+       tempreg = (uint8_t)I2C->SR1;
+       break;
+     
+       /* Returns whether the status register to check is SR2 */
+     case 0x02:
+       tempreg = (uint8_t)I2C->SR2;
+       break;
+       
+       /* Returns whether the status register to check is SR3 */
+     case 0x03:
+       tempreg = (uint8_t)I2C->SR3;
+       break;
+     default:
+       break;
+   }
+ 
+   /* Check the status of the specified I2C flag */
+   if ((tempreg & (uint8_t)I2C_FLAG) != 0)
+   {
+     /* Flag is set */
+     bitstatus = SET;
+   }
+   else
+   {
+     /* Flag is reset */
+     bitstatus = RESET;
+   }
+   /* Return the flag status */
+   return bitstatus;
+ }
+ 
+ /**
+   * @brief  Clear flags
+   * @param  I2C_Flag: Specifies the flag to clear
+   *          This parameter can be any combination of the following values:
+   *            @arg I2C_FLAG_WUFH: Wakeup from Halt
+   *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
+   *            @arg I2C_FLAG_AF: Acknowledge failure flag
+   *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
+   *            @arg I2C_FLAG_BERR: Bus error flag.
+   * @note   STOPF (STOP detection) is cleared by software sequence: a read operation
+   *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation
+   *          to I2C_CR2 register.
+   * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read
+   *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the
+   *          second byte of the address in DR register.
+   * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read
+   *         operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a
+   *         read/write to I2C_DR register (I2C_SendData()).
+   * @note   ADDR (Address sent) is cleared by software sequence: a read operation
+   *         to I2C_SR1 register(I2C_GetFlagStatus()) followed by a read operation
+   *         to I2C_SR3 register ((void)(I2C->SR3)).
+   * @note   SB (Start Bit) is cleared software sequence: a read operation to
+   *         I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation
+   *         to I2C_DR register (I2C_SendData()).
+   * @retval None
+   */
+ void I2C_ClearFlag(I2C_FLAG_TypeDef I2C_FLAG)
+ {
+   uint16_t flagpos = 0;
+   /* Check the parameters */
+   assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
+ 
+   /* Get the I2C flag position */
+   flagpos = (uint16_t)I2C_FLAG & FLAG_Mask;
+   /* Clear the selected I2C flag */
+   I2C->SR2 = (uint8_t)((uint16_t)(~flagpos));
+ }
+ 
+ /**
+   * @brief  Checks whether the specified I2C interrupt has occurred or not.
+   * @param  I2C_IT: specifies the interrupt source to check.
+   *            This parameter can be one of the following values:
+   *            @arg I2C_IT_WUFH: Wakeup from Halt
+   *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
+   *            @arg I2C_IT_AF: Acknowledge failure flag
+   *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
+   *            @arg I2C_IT_BERR: Bus error flag
+   *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
+   *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
+   *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
+   *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
+   *            @arg I2C_IT_BTF: Byte transfer finished flag
+   *            @arg I2C_IT_ADDR: Address sent flag (Master mode) ADSL
+   *                              Address matched flag (Slave mode)ENDAD
+   *            @arg I2C_IT_SB: Start bit flag (Master mode)
+   * @retval The new state of I2C_IT
+   */
+ ITStatus I2C_GetITStatus(I2C_IT_TypeDef I2C_IT)
+ {
+   ITStatus bitstatus = RESET;
+   __IO uint8_t enablestatus = 0;
+   uint16_t tempregister = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_I2C_GET_IT(I2C_IT));
+ 
+   tempregister = (uint8_t)( ((uint16_t)((uint16_t)I2C_IT & ITEN_Mask)) >> 8);
+ 
+   /* Check if the interrupt source is enabled or not */
+   enablestatus = (uint8_t)(I2C->ITR & ( uint8_t)tempregister);
+ 
+   if ((uint16_t)((uint16_t)I2C_IT & REGISTER_Mask) == REGISTER_SR1_Index)
+   {
+     /* Check the status of the specified I2C flag */
+     if (((I2C->SR1 & (uint8_t)I2C_IT) != RESET) && enablestatus)
+     {
+       /* I2C_IT is set */
+       bitstatus = SET;
+     }
+     else
+     {
+       /* I2C_IT is reset */
+       bitstatus = RESET;
+     }
+   }
+   else
+   {
+     /* Check the status of the specified I2C flag */
+     if (((I2C->SR2 & (uint8_t)I2C_IT) != RESET) && enablestatus)
+     {
+       /* I2C_IT is set */
+       bitstatus = SET;
+     }
+     else
+     {
+       /* I2C_IT is reset */
+       bitstatus = RESET;
+     }
+   }
+   /* Return the I2C_IT status */
+   return  bitstatus;
+ }
+ 
+ /**
+   * @brief  Clear IT pending bit
+   * @param  I2C_IT: specifies the interrupt pending bit to clear.
+   *            @arg I2C_IT_WUFH: Wakeup from Halt
+   *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
+   *            @arg I2C_IT_AF: Acknowledge failure interrupt
+   *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
+   *            @arg I2C_IT_BERR: Bus error interrupt
+   *
+   * @note   STOPF (STOP detection) is cleared by software sequence: a read operation
+   *         to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
+   *         I2C_CR2 register (I2C_AcknowledgeConfig() to configure the I2C peripheral Acknowledge).
+   * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read
+   *         operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second
+   *         byte of the address in I2C_DR register.
+   * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read
+   *         operation to I2C_SR1 register (I2C_GetITStatus()) followed by a read/write to
+   *         I2C_DR register (I2C_SendData()).
+   * @note   ADDR (Address sent) is cleared by software sequence: a read operation
+   *         to I2C_SR1 register (I2C_GetITStatus()) followed by a read operation
+   *         to I2C_SR3 register ((void)(I2C->SR3)).
+   * @note   SB (Start Bit) is cleared by software sequence: a read operation to
+   *         I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
+   *         I2C_DR register (I2C_SendData()).
+   * @retval None
+   */
+ void I2C_ClearITPendingBit(I2C_IT_TypeDef I2C_IT)
+ {
+   uint16_t flagpos = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_I2C_CLEAR_IT(I2C_IT));
+ 
+   /* Get the I2C flag position */
+   flagpos = (uint16_t)I2C_IT & FLAG_Mask;
+ 
+   /* Clear the selected I2C flag */
+   I2C->SR2 = (uint8_t)((uint16_t)~flagpos);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_irtim.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_irtim.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_irtim.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_irtim.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,134 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_irtim.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the IRTIM peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_irtim.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup IRTIM 
+   * @brief IRTIM driver modules
+   * @{
+   */ 
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ 
+ /**
+   * @addtogroup IRTIM_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the IRTIM peripheral registers to their default reset values.
+   * @param  None
+   * @retval None
+   */
+ void IRTIM_DeInit(void)
+ {
+   IRTIM->CR = IRTIM_CR_RESET_VALUE;
+ }
+ 
+ 
+ /**
+   * @brief  Enables or disables the IRTIM peripheral.
+   * @param  NewState The new state of the IRTIM peripheral.
+   * @retval None
+   */
+ void IRTIM_Cmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* set or Reset the EN Bit */
+   if (NewState ==  DISABLE)
+   {
+     IRTIM->CR &= (uint8_t)(~IRTIM_CR_EN);
+   }
+   else
+   {
+     IRTIM->CR |= IRTIM_CR_EN;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the High sink open drain buffer IRTIM peripheral.
+   * @param  NewState The new state of the High sink open drain buffer IRTIM peripheral.
+   * @retval None
+   */
+ void IRTIM_HighSinkODCmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* set or Reset the EN Bit */
+   if (NewState == DISABLE)
+   {
+     IRTIM->CR &= (uint8_t)(~IRTIM_CR_HSEN);
+   }
+   else
+   {
+     IRTIM->CR |= IRTIM_CR_HSEN;
+   }
+ }
+ 
+ /**
+   * @brief  Checks whether the IRTIM device is enabled or not.
+   * @param  None
+   * @retval The new state of the IRTIM device.
+   */
+ FunctionalState IRTIM_GetStatus(void)
+ {
+   return ((FunctionalState)(IRTIM->CR & IRTIM_CR_EN));
+ }
+ 
+ /**
+   * @brief  Checks whether the IRTIM High Sink Open Drain buffer is Enabled or not.
+   * @param  None
+   * @retval The state of High Sink Open Drain buffer.
+   */
+ FunctionalState IRTIM_GetHighSinkODStatus(void)
+ {
+   return ((FunctionalState)(IRTIM->CR & IRTIM_CR_HSEN));
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_itc.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_itc.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_itc.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_itc.c	2017-08-16 14:30:29.000000000 +0200
***************
*** 0 ****
--- 1,329 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_itc.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the ITC peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_itc.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup ITC 
+   * @brief ITC driver modules
+   * @{
+   */ 
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /** @addtogroup ITC_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Utility function used to read CC register.
+   * @note   A warning may appear during compilation, you can ignore it.
+   * @param  None
+   * @retval Content of CC register.
+   */
+ 
+ uint8_t ITC_GetCPUCC(void)
+ {
+ #ifdef _COSMIC_
+   _asm("push cc");
+   _asm("pop a");
+   return; /* Ignore compiler warning, the returned value is in A register */
+ #elif defined _RAISONANCE_ /* _RAISONANCE_ */
+   return _getCC_();
+ #elif defined(_SDCC_)                    /* SDCC patch: do same as IAR */
+   __asm__("push cc");
+   __asm__("pop a");
+ #else /* _IAR_ */
+   asm("push cc");
+   asm("pop a"); /* Ignore compiler warning, the returned value is in A register */
+ #endif /* _COSMIC_*/
+ }
+ 
+ /**
+   * @brief  Deinitializes the ITC registers to their default reset value.
+   * @param  None
+   * @retval None
+   */
+ void ITC_DeInit(void)
+ {
+   ITC->ISPR1 = ITC_SPR1_RESET_VALUE;
+   ITC->ISPR2 = ITC_SPR2_RESET_VALUE;
+   ITC->ISPR3 = ITC_SPR3_RESET_VALUE;
+   ITC->ISPR4 = ITC_SPR4_RESET_VALUE;
+   ITC->ISPR5 = ITC_SPR5_RESET_VALUE;
+   ITC->ISPR6 = ITC_SPR6_RESET_VALUE;
+   ITC->ISPR7 = ITC_SPR7_RESET_VALUE;
+   ITC->ISPR8 = ITC_SPR8_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Get the software interrupt priority bits (I1, I0) value from CPU CC register.
+   * @param  None
+   * @retval The software interrupt priority bits value.
+   */
+ uint8_t ITC_GetSoftIntStatus(void)
+ {
+   return ((uint8_t)(ITC_GetCPUCC() & CPU_SOFT_INT_DISABLED));
+ }
+ 
+ /**
+   * @brief  Get the software priority of the specified interrupt source.
+   * @param  IRQn The IRQ to access.
+   *          This parameter can be any combination of the following values:
+   *            @arg FLASH_IRQn:                    Flash interrupt
+   *            @arg AWU_IRQn:                      Auto Wake-Up interrupt
+   *            @arg EXTIB_IRQn:                    GPIOB interrupt
+   *            @arg EXTID_IRQn:                    GPIOD interrupt
+   *            @arg EXTI0_IRQn:                    PIN0 interrupt
+   *            @arg EXTI1_IRQn:                    PIN1 interrupt
+   *            @arg EXTI2_IRQn:                    PIN2 interrupt
+   *            @arg EXTI3_IRQn:                    PIN3 interrupt
+   *            @arg EXTI4_IRQn:                    PIN4 interrupt
+   *            @arg EXTI5_IRQn:                    PIN5 interrupt
+   *            @arg EXTI6_IRQn:                    PIN6 interrupt
+   *            @arg EXTI7_IRQn:                    PIN7 interrupt
+   *            @arg COMP_IRQn:                     Comparator interrupt
+   *            @arg TIM2_UPD_OVF_TRG_BRK_IRQn:     TIM2 UPD/OVF/TRG/BRK interrupt
+   *            @arg TIM2_CAP_IRQn:                 TIM2 CAP interrupt
+   *            @arg TIM3_UPD_OVF_TRG_BRK_IRQn:     TIM3 overflow interrupt
+   *            @arg TIM3_CAP_IRQn:                 TIM3 input capture/output compare interrupt
+   *            @arg TIM4_UPD_OVF_IRQn:             TIM4 overflow interrupt
+   *            @arg SPI_IRQn:                      SPI interrupt
+   *            @arg USART_TX_IRQn:                 USART TX interrupt
+   *            @arg USART_RX_IRQn:                 USART RX interrupt
+   *            @arg I2C_IRQn:                      I2C interrupt                                           
+   * @retval The software priority of the interrupt source.
+   */
+ ITC_PriorityLevel_TypeDef ITC_GetSoftwarePriority(IRQn_TypeDef IRQn)
+ {
+   uint8_t Value = 0;
+   uint8_t Mask = 0;
+ 
+   /* Check function parameters */
+   assert_param(IS_ITC_IRQ((uint8_t)IRQn));
+ 
+   /* Define the mask corresponding to the bits position in the SPR register */
+   Mask = (uint8_t)(0x03U << (((uint8_t)IRQn % 4U) * 2U));
+ 
+   switch (IRQn)
+   {
+     case FLASH_IRQn:
+       Value = (uint8_t)(ITC->ISPR1 & Mask); /* Read software priority */
+       break;
+ 
+     case AWU_IRQn:
+     case EXTIB_IRQn:
+     case EXTID_IRQn:
+       Value = (uint8_t)(ITC->ISPR2 & Mask); /* Read software priority */
+       break;
+ 
+     case EXTI0_IRQn:
+     case EXTI1_IRQn:
+     case EXTI2_IRQn:
+     case EXTI3_IRQn:
+       Value = (uint8_t)(ITC->ISPR3 & Mask); /* Read software priority */
+       break;
+ 
+     case EXTI4_IRQn:
+     case EXTI5_IRQn:
+     case EXTI6_IRQn:
+     case EXTI7_IRQn:
+       Value = (uint8_t)(ITC->ISPR4 & Mask); /* Read software priority */
+       break;
+ 
+     case COMP_IRQn:
+     case TIM2_UPD_OVF_TRG_BRK_IRQn:
+       Value = (uint8_t)(ITC->ISPR5 & Mask); /* Read software priority */
+       break;
+ 
+     case TIM2_CAP_IRQn:
+     case TIM3_UPD_OVF_TRG_BRK_IRQn:
+     case TIM3_CAP_IRQn:
+       Value = (uint8_t)(ITC->ISPR6 & Mask); /* Read software priority */
+       break;
+ 
+     case TIM4_UPD_OVF_IRQn:
+     case SPI_IRQn:
+     case USART_TX_IRQn:
+       Value = (uint8_t)(ITC->ISPR7 & Mask); /* Read software priority */
+       break;
+ 
+     case USART_RX_IRQn:
+     case I2C_IRQn:
+       Value = (uint8_t)(ITC->ISPR8 & Mask); /* Read software priority */
+       break;
+ 
+     default:
+       break;
+   }
+ 
+   Value >>= (uint8_t)(((uint8_t)IRQn % 4u) * 2u);
+ 
+   return((ITC_PriorityLevel_TypeDef)Value);
+ 
+ }
+ 
+ /**
+   * @brief  Set the software priority of the specified interrupt source.
+   * @note   The modification of the software priority is only possible when the 
+   *         interrupts are disabled.
+   * @note   The normal behavior is to disable the interrupts before calling 
+   *         this function, and re-enable it after.
+   * @note   The priority level 0 cannot be set (see product specification for more details).
+   * @param  IRQn  The interrupt source to access.
+   *          This parameter can be any combination of the following values:
+   *            @arg FLASH_IRQn:                    Flash interrupt
+   *            @arg AWU_IRQn:                      Auto Wake-Up interrupt
+   *            @arg EXTIB_IRQn:                    GPIOB interrupt
+   *            @arg EXTID_IRQn:                    GPIOD interrupt
+   *            @arg EXTI0_IRQn:                    PIN0 interrupt
+   *            @arg EXTI1_IRQn:                    PIN1 interrupt
+   *            @arg EXTI2_IRQn:                    PIN2 interrupt
+   *            @arg EXTI3_IRQn:                    PIN3 interrupt
+   *            @arg EXTI4_IRQn:                    PIN4 interrupt
+   *            @arg EXTI5_IRQn:                    PIN5 interrupt
+   *            @arg EXTI6_IRQn:                    PIN6 interrupt
+   *            @arg EXTI7_IRQn:                    PIN7 interrupt
+   *            @arg COMP_IRQn:                     Comparator interrupt
+   *            @arg TIM2_UPD_OVF_TRG_BRK_IRQn:     TIM2 UPD/OVF/TRG/BRK interrupt
+   *            @arg TIM2_CAP_IRQn:                 TIM2 CAP interrupt
+   *            @arg TIM3_UPD_OVF_TRG_BRK_IRQn:     TIM3 overflow interrupt
+   *            @arg TIM3_CAP_IRQn:                 TIM3 input capture/output compare interrupt
+   *            @arg TIM4_UPD_OVF_IRQn:             TIM4 overflow interrupt
+   *            @arg SPI_IRQn:                      SPI interrupt
+   *            @arg USART_TX_IRQn:                 USART TX interrupt
+   *            @arg USART_RX_IRQn:                 USART RX interrupt
+   *            @arg I2C_IRQn:                      I2C interrupt  
+   * @param  ITC_PriorityLevel The software priority value to set.
+   *          This parameter can be any combination of the following values:
+   *            @arg ITC_PriorityLevel_0:    Software priority level 0 (cannot be written)
+   *            @arg ITC_PriorityLevel_1:    Software priority level 1
+   *            @arg ITC_PriorityLevel_2:    Software priority level 2
+   *            @arg ITC_PriorityLevel_3:    Software priority level 3      
+   * @retval None
+   */
+ void ITC_SetSoftwarePriority(IRQn_TypeDef IRQn, ITC_PriorityLevel_TypeDef ITC_PriorityLevel)
+ {
+   uint8_t Mask = 0;
+   uint8_t NewPriority = 0;
+ 
+   /* Check function parameters */
+   assert_param(IS_ITC_IRQ((uint8_t)IRQn));
+   assert_param(IS_ITC_PRIORITY(ITC_PriorityLevel));
+ 
+   /* Check if interrupts are disabled */
+   assert_param(IS_ITC_INTERRUPTS_DISABLED);
+ 
+   /* Define the mask corresponding to the bits position in the SPR register */
+   /* The mask is reversed in order to clear the 2 bits after more easily */
+   Mask = (uint8_t)(~(uint8_t)(0x03U << (((uint8_t)IRQn % 4U) * 2U)));
+ 
+   /* Define the new priority to write */
+   NewPriority = (uint8_t)((uint8_t)(ITC_PriorityLevel) << (((uint8_t)IRQn % 4U) * 2U));
+ 
+   switch (IRQn)
+   {
+     case FLASH_IRQn:
+       ITC->ISPR1 &= Mask;
+       ITC->ISPR1 |= NewPriority;
+       break;
+ 
+     case AWU_IRQn:
+     case EXTIB_IRQn:
+     case EXTID_IRQn:
+       ITC->ISPR2 &= Mask;
+       ITC->ISPR2 |= NewPriority;
+       break;
+ 
+     case EXTI0_IRQn:
+     case EXTI1_IRQn:
+     case EXTI2_IRQn:
+     case EXTI3_IRQn:
+       ITC->ISPR3 &= Mask;
+       ITC->ISPR3 |= NewPriority;
+       break;
+ 
+     case EXTI4_IRQn:
+     case EXTI5_IRQn:
+     case EXTI6_IRQn:
+     case EXTI7_IRQn:
+       ITC->ISPR4 &= Mask;
+       ITC->ISPR4 |= NewPriority;
+       break;
+ 
+     case COMP_IRQn:
+     case TIM2_UPD_OVF_TRG_BRK_IRQn:
+       ITC->ISPR5 &= Mask;
+       ITC->ISPR5 |= NewPriority;
+       break;
+ 
+     case TIM2_CAP_IRQn:
+     case TIM3_UPD_OVF_TRG_BRK_IRQn:
+     case TIM3_CAP_IRQn:
+       ITC->ISPR6 &= Mask;
+       ITC->ISPR6 |= NewPriority;
+       break;
+ 
+     case TIM4_UPD_OVF_IRQn:
+     case SPI_IRQn:
+     case USART_TX_IRQn:
+       ITC->ISPR7 &= Mask;
+       ITC->ISPR7 |= NewPriority;
+       break;
+ 
+     case USART_RX_IRQn:
+     case I2C_IRQn:
+       ITC->ISPR8 &= Mask;
+       ITC->ISPR8 |= NewPriority;
+       break;
+ 
+     default:
+       break;
+   }
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_iwdg.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_iwdg.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_iwdg.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_iwdg.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,131 ----
+ /**
+   ********************************************************************************
+   * @file    stm8l10x_iwdg.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the IWDG peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_iwdg.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup IWDG 
+   * @brief IWDG driver modules
+   * @{
+   */ 
+   
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /** @addtogroup IWDG_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Enables or disables write access to IWDG_PR and IWDG_RLR registers.
+   * @param  IWDG_WriteAccess: new state of write access to IWDG_PR and IWDG_RLR registers.
+   *          This parameter can be one of the following values:
+   *            @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
+   *            @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
+   * @retval None
+   */
+ void IWDG_WriteAccessCmd(IWDG_WriteAccess_TypeDef IWDG_WriteAccess)
+ {
+   /* Check the parameters */
+   assert_param(IS_IWDG_WRITEACCESS_MODE(IWDG_WriteAccess));
+   IWDG->KR = (uint8_t)IWDG_WriteAccess; /* Write Access */
+ }
+ 
+ /**
+   * @brief  Sets IWDG Prescaler value.
+   * @note   The WDG write access must be enabled.
+   * @param  IWDG_Prescaler: specifies the IWDG Prescaler value.
+   *          This parameter can be one of the following values:
+   *            @arg IWDG_Prescaler_4: IWDG prescaler set to 4
+   *            @arg IWDG_Prescaler_8: IWDG prescaler set to 8
+   *            @arg IWDG_Prescaler_16: IWDG prescaler set to 16
+   *            @arg IWDG_Prescaler_32: IWDG prescaler set to 32
+   *            @arg IWDG_Prescaler_64: IWDG prescaler set to 64
+   *            @arg IWDG_Prescaler_128: IWDG prescaler set to 128
+   *            @arg IWDG_Prescaler_256: IWDG prescaler set to 256
+   * @retval None
+   */
+ void IWDG_SetPrescaler(IWDG_Prescaler_TypeDef IWDG_Prescaler)
+ {
+   /* Check the parameters */
+   assert_param(IS_IWDG_PRESCALER_VALUE(IWDG_Prescaler));
+   IWDG->PR = (uint8_t)IWDG_Prescaler;
+ }
+ 
+ /**
+   * @brief  Sets IWDG Reload value.
+   * @note   Write access should be enabled
+   * @param  IWDG_Reload : Reload register value.
+   *         This parameter must be a number between 0 and 0xFF.
+   * @retval None
+   */
+ void IWDG_SetReload(uint8_t IWDG_Reload)
+ {
+   IWDG->RLR = IWDG_Reload;
+ }
+ 
+ /**
+   * @brief  Reloads IWDG counter with value defined in the reload register
+   *         (write access to IWDG_PR and IWDG_RLR registers disabled).
+   * @param  None
+   * @retval None
+   */
+ void IWDG_ReloadCounter(void)
+ {
+   IWDG->KR = IWDG_KEY_REFRESH;
+ }
+ 
+ /**
+   * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).
+   * @param  None
+   * @retval None
+   */
+ void IWDG_Enable(void)
+ {
+   IWDG->KR = IWDG_KEY_ENABLE;
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_rst.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_rst.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_rst.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_rst.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,115 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_rst.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the RST peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ 
+ #include "stm8l10x_rst.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ 
+ /** @defgroup RST 
+   * @brief RST driver modules
+   * @{
+   */ 
+   
+ /* Private typedef -----------------------------------------------------------*/
+ #define RST_CR_MASK  0xD0 /*!< Enable the GPIO */
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private Constants ---------------------------------------------------------*/
+ 
+ /**
+   * @addtogroup RST_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief   Checks whether the specified RST flag is set or not.
+   * @param   RST_Flag : specify the reset flag to check.
+   *          This parameter can be one of the following values:
+   *            @arg RST_FLAG_POR_PDR: POR reset flag
+   *            @arg RST_FLAG_SWIMF: SWIM reset flag
+   *            @arg RST_FLAG_ILLOPF: Illegal opcode reset flag
+   *            @arg RST_FLAG_IWDGF: Independent watchdog reset flag 
+   *            @arg RST_FLAG_BORF: BOR reset flag
+   * @retval  The new state of RST_Flag (SET or RESET).
+   */
+ FlagStatus RST_GetFlagStatus(RST_Flag_TypeDef RST_Flag)
+ {
+   /* Check the parameters */
+   assert_param(IS_RST_FLAG(RST_Flag));
+ 
+   /* Get flag status */
+ 
+   return((FlagStatus)(((uint8_t)(RST->SR & RST_Flag) == (uint8_t)0x00) ? RESET : SET));
+ }
+ 
+ /**
+   * @brief  Clears the specified RST flag.
+   * @param  RST_Flag : specify the reset flag to clear.
+   *          This parameter can be one of the following values:
+   *            @arg RST_FLAG_POR_PDR: POR reset flag
+   *            @arg RST_FLAG_SWIMF: SWIM reset flag
+   *            @arg RST_FLAG_ILLOPF: Illegal opcode reset flag
+   *            @arg RST_FLAG_IWDGF: Independent watchdog reset flag 
+   *            @arg RST_FLAG_BORF: BOR reset flag  
+   * @retval None
+   */
+ void RST_ClearFlag(RST_Flag_TypeDef RST_Flag)
+ {
+   /* Check the parameters */
+   assert_param(IS_RST_FLAG(RST_Flag));
+ 
+   RST->SR = (uint8_t)RST_Flag;
+ }
+ 
+ /**
+   * @brief  Configures the reset pad as GP output.
+   * @param  None
+   * @retval None
+   */
+ void RST_GPOutputEnable(void)
+ {
+ 
+   RST->CR = RST_CR_MASK;
+ }
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_spi.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_spi.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_spi.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_spi.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,383 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_spi.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the SPI peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_spi.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup SPI 
+   * @brief SPI driver modules
+   * @{
+   */ 
+   
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /** @addtogroup SPI_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the SPI peripheral registers to their default reset values.
+   * @param  None
+   * @retval None
+   */
+ void SPI_DeInit(void)
+ {
+   SPI->CR1 = SPI_CR1_RESET_VALUE;
+   SPI->CR2 = SPI_CR2_RESET_VALUE;
+   SPI->ICR = SPI_ICR_RESET_VALUE;
+   SPI->SR = SPI_SR_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Initializes the SPI according to the specified parameters.
+   * @param  SPI_FirstBit: MSB or LSB is transmitted first
+   *          This parameter can be one of the following values:
+   *            @arg SPI_FirstBit_MSB: MSB bit will be transmitted first
+   *            @arg SPI_FirstBit_LSB: LSB bit will be transmitted first  
+   * @param  SPI_BaudRatePrescaler: Select the baud rate prescaler
+   *          This parameter can be one of the following values:
+   *            @arg SPI_BaudRatePrescaler_2: SPI frequency = frequency(CPU)/2
+   *            @arg SPI_BaudRatePrescaler_4: SPI frequency = frequency(CPU)/4
+   *            @arg SPI_BaudRatePrescaler_8: SPI frequency = frequency(CPU)/8
+   *            @arg SPI_BaudRatePrescaler_16: SPI frequency = frequency(CPU)/16
+   *            @arg SPI_BaudRatePrescaler_32: SPI frequency = frequency(CPU)/32
+   *            @arg SPI_BaudRatePrescaler_64: SPI frequency = frequency(CPU)/64
+   *            @arg SPI_BaudRatePrescaler_128: SPI frequency = frequency(CPU)/128
+   *            @arg SPI_BaudRatePrescaler_256: SPI frequency = frequency(CPU)/256 
+   * @param  SPI_Mode: Select the master or slave configuration
+   *          This parameter can be one of the following values:
+   *            @arg SPI_Mode_Master: SPI Master configuration
+   *            @arg SPI_Mode_Slave: SPI Slave configuration
+   * @param  SPI_CPOL: Select the polarity of the signals
+   *          This parameter can be one of the following values:
+   *            @arg SPI_CPOL_Low: Clock to 0 when idle
+   *            @arg SPI_CPOL_High: Clock to 1 when idle
+   * @param  SPI_CPHA: Select the phase of the signals
+   *          This parameter can be one of the following values:
+   *            @arg SPI_CPHA_1Edge: The first clock transition is the first data capture edge
+   *            @arg SPI_CPHA_2Edge: The second clock transition is the first data capture edge
+   * @param  SPI_DirectionMode: Select the number of lines used and TX or RX
+   *          This parameter can be one of the following values:
+   *            @arg SPI_Direction_2Lines_FullDuplex: 2-line uni-directional data mode
+   *            @arg SPI_Direction_2Lines_RxOnly: Receiver only in 2 line uni-directional data mode
+   *            @arg SPI_Direction_1Line_Rx: Receiver only in 1 line bi-directional data mode
+   *            @arg SPI_Direction_1Line_Tx: transmit only in 1 line bi-directional data mode      
+   * @param  SPI_NSS: Select the type of the NSS pin (HW or SW)
+   *          This parameter can be one of the following values:
+   *            @arg SPI_NSS_Soft: Software slave management disabled
+   *            @arg SPI_NSS_Hard: Software slave management enabled
+   * @retval None
+   */
+ void SPI_Init(SPI_FirstBit_TypeDef SPI_FirstBit, SPI_BaudRatePrescaler_TypeDef SPI_BaudRatePrescaler,
+               SPI_Mode_TypeDef SPI_Mode, SPI_CPOL_TypeDef SPI_CPOL, SPI_CPHA_TypeDef SPI_CPHA,
+               SPI_DirectionMode_TypeDef SPI_DirectionMode, SPI_NSS_TypeDef SPI_NSS)
+ {
+ 
+   /* Check structure elements */
+   assert_param(IS_SPI_FIRST_BIT(SPI_FirstBit));
+   assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));
+   assert_param(IS_SPI_MODE(SPI_Mode));
+   assert_param(IS_SPI_CPOL(SPI_CPOL));
+   assert_param(IS_SPI_CPHA(SPI_CPHA));
+   assert_param(IS_SPI_DIRECTION_MODE(SPI_DirectionMode));
+   assert_param(IS_SPI_NSS(SPI_NSS));
+ 
+   /* Frame Format, BaudRate, Clock Polarity and Phase configuration */
+   SPI->CR1 = (uint8_t)((uint8_t)(SPI_FirstBit) |
+                        (uint8_t)(SPI_BaudRatePrescaler) |
+                        (uint8_t)(SPI_CPOL) |
+                        (uint8_t)(SPI_CPHA));
+ 
+   /* Data direction configuration: BDM, BDOE and RXONLY bits */
+   SPI->CR2 = (uint8_t)((uint8_t)(SPI_DirectionMode) | (uint8_t)(SPI_NSS));
+ 
+   if (SPI_Mode == SPI_Mode_Master)
+   {
+     SPI->CR2 |= (uint8_t)SPI_CR2_SSI;
+   }
+   else
+   {
+     SPI->CR2 &= (uint8_t)~(SPI_CR2_SSI);
+   }
+ 
+   /* Master/Slave mode configuration */
+   SPI->CR1 |= (uint8_t)(SPI_Mode);
+ }
+ 
+ /**
+   * @brief  Enables or disables the specified SPI peripheral.
+   * @param  NewState New state of the SPI peripheral.
+   *         This parameter can be: ENABLE or DISABLE
+   * @retval None
+   */
+ void SPI_Cmd(FunctionalState NewState)
+ {
+ 
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     SPI->CR1 |= SPI_CR1_SPE; /* Enable the SPI peripheral */
+   }
+   else
+   {
+     SPI->CR1 &= (uint8_t)(~SPI_CR1_SPE); /* Disable the SPI peripheral */
+   }
+ 
+ }
+ 
+ /**
+   * @brief Enables or disables the specified interrupts.
+   * @param  SPI_IT Specifies the SPI interrupts sources to be enabled or disabled.
+   *          This parameter can be one of the following values:
+   *            @arg SPI_IT_TXE: Transmit buffer empty
+   *            @arg SPI_IT_RXNE: Receive buffer not empty
+   *            @arg SPI_IT_ERR: Error
+   *            @arg SPI_IT_WKUP: Wake-up
+   * @param  NewState: The new state of the specified SPI interrupts.
+   *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void SPI_ITConfig(SPI_IT_TypeDef SPI_IT, FunctionalState NewState)
+ {
+   uint8_t itpos = 0;
+   /* Check function parameters */
+   assert_param(IS_SPI_CONFIG_IT(SPI_IT));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Get the SPI IT index */
+   itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)SPI_IT & (uint8_t)0x0F));
+ 
+   if (NewState != DISABLE)
+   {
+     SPI->ICR |= itpos; /* Enable interrupt*/
+   }
+   else
+   {
+     SPI->ICR &= (uint8_t)(~itpos); /* Disable interrupt*/
+   }
+ }
+ 
+ /**
+   * @brief  Transmits a Data through the SPI peripheral.
+   * @param  Data Byte to be transmitted.
+   * @retval None
+   */
+ void SPI_SendData(uint8_t Data)
+ {
+   SPI->DR = Data; /* Write in the DR register the data to be sent*/
+ }
+ 
+ /**
+   * @brief  Returns the most recent received data by the SPI peripheral.
+   * @param  None
+   * @retval The value of the received data.
+   */
+ uint8_t SPI_ReceiveData(void)
+ {
+   return ((uint8_t)SPI->DR); /* Return the data in the DR register */
+ }
+ 
+ /**
+   * @brief  Configures internally by software the NSS pin.
+   * @note   This function is used only when SPI NSS software mode is enabled
+   * @param  NewState Indicates the new state of the SPI Software slave management.
+   *         This parameter can be: ENABLE or DISABLE  
+   * @retval None
+   */
+ void SPI_NSSInternalSoftwareCmd(FunctionalState NewState)
+ {
+ 
+   /* Check function parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     SPI->CR2 |= SPI_CR2_SSI; /* Set NSS pin internally by software */
+   }
+   else
+   {
+     SPI->CR2 &= (uint8_t)(~SPI_CR2_SSI); /* Reset NSS pin internally by software */
+   }
+ 
+ }
+ 
+ /**
+   * @brief  Selects the data transfer direction in bi-directional mode.
+   * @param  SPI_Direction Specifies the data transfer direction in bi-directional mode.
+   *          This parameter can be one of the following values:
+   *            @arg SPI_Direction_Rx: Rx receive direction in bi-directional mode
+   *            @arg SPI_Direction_Tx: Tx transmission direction in bi-directional mode  
+   * @retval None
+   */
+ void SPI_BiDirectionalLineConfig(SPI_Direction_TypeDef SPI_Direction)
+ {
+ 
+   /* Check function parameters */
+   assert_param(IS_SPI_DIRECTION(SPI_Direction));
+   if (SPI_Direction != SPI_Direction_Rx)
+   {
+     SPI->CR2 |= SPI_CR2_BDOE; /* Set the Tx only mode*/
+   }
+   else
+   {
+     SPI->CR2 &= (uint8_t)(~SPI_CR2_BDOE); /* Set the Rx only mode*/
+   }
+ }
+ 
+ /**
+   * @brief  Checks whether the specified SPI flag is set or not.
+   * @param  SPI_FLAG: Specifies the flag to check.
+   *          This parameter can be one of the following values:
+   *            @arg SPI_FLAG_BSY: Busy
+   *            @arg SPI_FLAG_OVR: Overrun
+   *            @arg SPI_FLAG_MODF: Mode fault
+   *            @arg SPI_FLAG_WKUP: Wake-up 
+   *            @arg SPI_FLAG_TXE: Transmit buffer empty
+   *            @arg SPI_FLAG_RXNE: Receive buffer empty
+   * @retval Indicates the state of SPI_FLAG.
+   *         This parameter can be SET or RESET.
+   */
+ 
+ FlagStatus SPI_GetFlagStatus(SPI_FLAG_TypeDef SPI_FLAG)
+ {
+   FlagStatus status = RESET;
+   /* Check parameters */
+   assert_param(IS_SPI_FLAG(SPI_FLAG));
+ 
+   /* Check the status of the specified SPI flag */
+   if ((SPI->SR & (uint8_t)SPI_FLAG) != (uint8_t)RESET)
+   {
+     status = SET; /* SPI_FLAG is set */
+   }
+   else
+   {
+     status = RESET; /* SPI_FLAG is reset*/
+   }
+ 
+   /* Return the SPI_FLAG status */
+   return status;
+ }
+ 
+ /**
+   * @brief Clears the WKUP (Wake-up) flag.
+   * @param  None
+   * @note   OVR (OverRun Error) interrupt pending bit is cleared by software
+   *         sequence: a read operation to SPI_DR register (SPI_ReceiveData()) followed by
+   *         a read operation to SPI_SR register (SPI_GetFlagStatus()).
+   * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
+   *         a read/write operation to SPI_SR register (SPI_GetFlagStatus()) followed by
+   *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
+   * @retval None
+   */
+ void SPI_ClearFlag(void)
+ {
+   /* Clear the flag bit */
+   SPI->SR = (uint8_t)(~SPI_SR_WKUP);
+ }
+ 
+ /**
+   * @brief Checks whether the specified interrupt has occurred or not.
+   * @param  SPI_IT: Specifies the SPI interrupt pending bit to check.
+   *         This parameter can be one of the following values:
+   *            @arg SPI_IT_WKUP
+   *            @arg SPI_IT_OVR
+   *            @arg SPI_IT_MODF
+   *            @arg SPI_IT_RXNE
+   *            @arg SPI_IT_TXE
+   * @retval Indicates the state of the SPI_IT.
+   */
+ ITStatus SPI_GetITStatus(SPI_IT_TypeDef SPI_IT)
+ {
+   ITStatus pendingbitstatus = RESET;
+   uint8_t itpos = 0;
+   uint8_t itmask1 = 0;
+   uint8_t itmask2 = 0;
+   uint8_t enablestatus = 0;
+   assert_param(IS_SPI_GET_IT(SPI_IT));
+   /* Get the SPI IT index */
+   itpos = (uint8_t)((uint8_t)1 << ((uint8_t)SPI_IT & (uint8_t)0x0F));
+ 
+   /* Get the SPI IT mask */
+   itmask1 = (uint8_t)((uint8_t)SPI_IT >> (uint8_t)4);
+   /* Set the IT mask */
+   itmask2 = (uint8_t)((uint8_t)1 << itmask1);
+   /* Get the SPI_IT enable bit status */
+   enablestatus = (uint8_t)((uint8_t)SPI->SR & itmask2);
+   /* Check the status of the specified SPI interrupt */
+   if (((SPI->ICR & itpos) != (uint8_t)RESET) && enablestatus)
+   {
+     /* SPI_IT is set */
+     pendingbitstatus = SET;
+   }
+   else
+   {
+     /* SPI_IT is reset */
+     pendingbitstatus = RESET;
+   }
+   /* Return the SPI_IT status */
+   return  pendingbitstatus;
+ }
+ 
+ /**
+   * @brief Clears the WKUP (Wake-up) interrupt pending bit.
+   * @param None
+   * @note   OVR (OverRun Error) interrupt pending bit is cleared by software
+   *         sequence: a read operation to SPI_DR register (SPI_ReceiveData()) followed by
+   *         a read operation to SPI_SR register (SPI_GetFlagStatus()).
+   * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
+   *         a read/write operation to SPI_SR register (SPI_GetFlagStatus()) followed by
+   *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
+   * @retval None
+   * @note
+   */
+ void SPI_ClearITPendingBit(void)
+ {
+   /* Clear the WKUP pending bit */
+   SPI->SR = (uint8_t)(~SPI_SR_WKUP);
+ }
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim2.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim2.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim2.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim2.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,1839 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_tim2.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the TIM2 peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_tim2.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ /** @defgroup TIM2 
+   * @brief TIM2 driver modules
+   * @{
+   */ 
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void TI1_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                        TIM2_ICSelection_TypeDef TIM2_ICSelection,
+                        uint8_t TIM2_ICFilter);
+ 
+ static void TI2_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                        TIM2_ICSelection_TypeDef TIM2_ICSelection,
+                        uint8_t TIM2_ICFilter);
+ 
+ 
+ /**
+   * @addtogroup TIM2_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the TIM2 peripheral registers to their default reset values.
+   * @param  None
+   * @retval None
+   */
+ void TIM2_DeInit(void)
+ {
+   TIM2->CR1 = TIM_CR1_RESET_VALUE;
+   TIM2->CR2 = TIM_CR2_RESET_VALUE;
+   TIM2->SMCR = TIM_SMCR_RESET_VALUE;
+   TIM2->ETR = TIM_ETR_RESET_VALUE;
+   TIM2->IER = TIM_IER_RESET_VALUE;
+   TIM2->SR2 = TIM_SR2_RESET_VALUE;
+ 
+   /* Disable channels */
+   TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
+   /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
+   TIM2->CCMR1 = 0x01;/*TIM2_ICxSource_TIxFPx */
+   TIM2->CCMR2 = 0x01;/*TIM2_ICxSource_TIxFPx */
+ 
+   /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
+   TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
+   TIM2->CCMR1 = TIM_CCMR1_RESET_VALUE;
+   TIM2->CCMR2 = TIM_CCMR2_RESET_VALUE;
+ 
+   TIM2->CNTRH = TIM_CNTRH_RESET_VALUE;
+   TIM2->CNTRL = TIM_CNTRL_RESET_VALUE;
+ 
+   TIM2->PSCR = TIM_PSCR_RESET_VALUE;
+ 
+   TIM2->ARRH = TIM_ARRH_RESET_VALUE;
+   TIM2->ARRL = TIM_ARRL_RESET_VALUE;
+ 
+   TIM2->CCR1H = TIM_CCR1H_RESET_VALUE;
+   TIM2->CCR1L = TIM_CCR1L_RESET_VALUE;
+   TIM2->CCR2H = TIM_CCR2H_RESET_VALUE;
+   TIM2->CCR2L = TIM_CCR2L_RESET_VALUE;
+ 
+   TIM2->OISR = TIM_OISR_RESET_VALUE;
+   TIM2->EGR = 0x01;/*TIM_EGR_UG;*/
+   TIM2->BKR = TIM_BKR_RESET_VALUE;
+   TIM2->SR1 = TIM_SR1_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Initializes the TIM2 Time Base Unit according to the specified  parameters.
+   * @param  TIM2_Prescaler: Prescaler 
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            @arg TIM2_Prescaler_2: Time base Prescaler = 2
+   *            @arg TIM2_Prescaler_4: Time base Prescaler = 4
+   *            @arg TIM2_Prescaler_8: Time base Prescaler = 8
+   *            @arg TIM2_Prescaler_16: Time base Prescaler = 16
+   *            @arg TIM2_Prescaler_32: Time base Prescaler = 32
+   *            @arg TIM2_Prescaler_64: Time base Prescaler = 64
+   *            @arg TIM2_Prescaler_128: Time base Prescaler = 128                            
+   * @param  TIM2_CounterMode: Counter mode
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_CounterMode_Up: Counter Up Mode
+   *            @arg TIM2_CounterMode_Down: Counter Down Mode
+   *            @arg TIM2_CounterMode_CenterAligned1: Counter Central aligned Mode 1
+   *            @arg TIM2_CounterMode_CenterAligned2: Counter Central aligned Mode 2
+   *            @arg TIM2_CounterMode_CenterAligned3: Counter Central aligned Mode 3        
+   * @param  TIM2_Period: This parameter must be a value between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM2_TimeBaseInit(TIM2_Prescaler_TypeDef TIM2_Prescaler,
+                        TIM2_CounterMode_TypeDef TIM2_CounterMode,
+                        uint16_t TIM2_Period)
+ {
+ 
+   assert_param(IS_TIM2_PRESCALER(TIM2_Prescaler));
+   assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
+ 
+   /* Set the Autoreload value */
+   TIM2->ARRH = (uint8_t)(TIM2_Period >> 8) ;
+   TIM2->ARRL = (uint8_t)(TIM2_Period);
+ 
+   /* Set the Prescaler value */
+   TIM2->PSCR = (uint8_t)(TIM2_Prescaler);
+ 
+   /* Select the Counter Mode */
+   TIM2->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
+   TIM2->CR1 |= (uint8_t)(TIM2_CounterMode);
+ }
+ 
+ /**
+   * @brief Initializes the TIM2 Channel1 according to the specified parameters.
+   * @param  TIM2_OCMode: Output Compare Mode 
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
+   *            @arg TIM2_OCMode_Active: Active Mode
+   *            @arg TIM2_OCMode_Inactive: Inactive Mode
+   *            @arg TIM2_OCMode_Toggle: Toggle Mode
+   *            @arg TIM2_OCMode_PWM1: PWM Mode 1
+   *            @arg TIM2_OCMode_PWM2: PWM Mode 2          
+   * @param  TIM2_OutputState: Output state
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OutputState_Disable: Output compare State disabled (channel output disabled)
+   *            @arg TIM2_OutputState_Enable: Output compare State enabled (channel output enabled)
+   * @param  TIM2_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
+   * @param  TIM2_OCPolarity: Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
+   * @param  TIM2_OCIdleState: Output Compare Idle State
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCIdleState_Reset: Output Compare Idle state  = Reset
+   *            @arg TIM2_OCIdleState_Set: Output Compare Idle state  = Set
+   * @retval None
+   */
+ void TIM2_OC1Init(TIM2_OCMode_TypeDef TIM2_OCMode,
+                   TIM2_OutputState_TypeDef TIM2_OutputState,
+                   uint16_t TIM2_Pulse,
+                   TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
+                   TIM2_OCIdleState_TypeDef TIM2_OCIdleState)
+ {
+   uint8_t tmpccmr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
+   assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
+   assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
+   assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
+ 
+   tmpccmr1 = TIM2->CCMR1;
+ 
+   /* Disable the Channel 1: Reset the CCE Bit */
+   TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+   /* Reset the Output Compare Bits */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Set the Ouput Compare Mode */
+   tmpccmr1 |= (uint8_t)TIM2_OCMode;
+ 
+   TIM2->CCMR1 = tmpccmr1;
+ 
+   /* Set the Output State */
+   if (TIM2_OutputState == TIM2_OutputState_Enable)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC1E;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+   }
+ 
+   /* Set the Output Polarity */
+   if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC1P;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
+   }
+ 
+   /* Set the Output Idle state */
+   if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
+   {
+     TIM2->OISR |= TIM_OISR_OIS1;
+   }
+   else
+   {
+     TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS1);
+   }
+ 
+   /* Set the Pulse value */
+   TIM2->CCR1H = (uint8_t)(TIM2_Pulse >> 8);
+   TIM2->CCR1L = (uint8_t)(TIM2_Pulse);
+ }
+ 
+ /**
+   * @brief Initializes the TIM2 Channel2 according to the specified parameters.
+   * @param  TIM2_OCMode: Output Compare Mode 
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
+   *            @arg TIM2_OCMode_Active: Active Mode
+   *            @arg TIM2_OCMode_Inactive: Inactive Mode
+   *            @arg TIM2_OCMode_Toggle: Toggle Mode
+   *            @arg TIM2_OCMode_PWM1: PWM Mode 1
+   *            @arg TIM2_OCMode_PWM2: PWM Mode 2          
+   * @param  TIM2_OutputState: Output state
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OutputState_Disable: Output compare State disabled (channel output disabled)
+   *            @arg TIM2_OutputState_Enable: Output compare State enabled (channel output enabled)
+   * @param  TIM2_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
+   * @param  TIM2_OCPolarity: Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
+   * @param  TIM2_OCIdleState: Output Compare Idle State
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCIdleState_Reset: Output Compare Idle state  = Reset
+   *            @arg TIM2_OCIdleState_Set: Output Compare Idle state  = Set
+   * @retval None
+   */
+ void TIM2_OC2Init(TIM2_OCMode_TypeDef TIM2_OCMode,
+                   TIM2_OutputState_TypeDef TIM2_OutputState,
+                   uint16_t TIM2_Pulse,
+                   TIM2_OCPolarity_TypeDef TIM2_OCPolarity,
+                   TIM2_OCIdleState_TypeDef TIM2_OCIdleState)
+ {
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
+   assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
+   assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
+   assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
+ 
+   tmpccmr2 = TIM2->CCMR2;
+ 
+   /* Disable the Channel 2: Reset the CCE Bit */
+   TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+ 
+   /* Reset the Output Compare Bits */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Set the Output Compare Mode */
+   tmpccmr2 |= (uint8_t)TIM2_OCMode;
+ 
+   TIM2->CCMR2 = tmpccmr2;
+ 
+   /* Set the Output State */
+   if (TIM2_OutputState == TIM2_OutputState_Enable)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC2E;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+   }
+ 
+   /* Set the Output Polarity */
+   if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC2P;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
+   }
+ 
+ 
+   /* Set the Output Idle state */
+   if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
+   {
+     TIM2->OISR |= TIM_OISR_OIS2;
+   }
+   else
+   {
+     TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS2);
+   }
+ 
+   /* Set the Pulse value */
+   TIM2->CCR2H = (uint8_t)(TIM2_Pulse >> 8);
+   TIM2->CCR2L = (uint8_t)(TIM2_Pulse);
+ }
+ 
+ /**
+   * @brief Configures the Break feature, dead time, Lock level, the OSSI,
+   * @param  TIM2_OSSIState: Off-State Selection for Idle mode states.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OSSIState_Enable: Off-State Selection for Idle mode enabled
+   *            @arg TIM2_OSSIState_Disable: Off-State Selection for Idle mode disabled 
+   * @param  TIM2_LockLevel: Lock level.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_LockLevel_Off: Lock option disabled
+   *            @arg TIM2_LockLevel_1: Select Lock Level 1
+   *            @arg TIM2_LockLevel_2: Select Lock Level 2
+   *            @arg TIM2_LockLevel_3: Select Lock Level 3    
+   * @param  TIM2_BreakState: Break Input enable/disable .
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_BreakState_Disable: Break State disabled (break option disabled)
+   *            @arg TIM2_BreakState_Enable: Break State enabled (break option enabled) 
+   * @param  TIM2_BreakPolarity: Break Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_BreakPolarity_High: if Break, channel polarity = High
+   *            @arg TIM2_BreakPolarity_Low: if Break, channel polarity = Low   
+   * @param  TIM2_AutomaticOutput: TIM2 AOE Bit Set/Reset .
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_AutomaticOutput_Enable: Automatic Output option enabled
+   *            @arg TIM2_AutomaticOutput_Disable: Automatic Output option disabled
+   * @retval None
+   */
+ void TIM2_BKRConfig(TIM2_OSSIState_TypeDef TIM2_OSSIState,
+                     TIM2_LockLevel_TypeDef TIM2_LockLevel,
+                     TIM2_BreakState_TypeDef TIM2_BreakState,
+                     TIM2_BreakPolarity_TypeDef TIM2_BreakPolarity,
+                     TIM2_AutomaticOutput_TypeDef TIM2_AutomaticOutput)
+ 
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_OSSI_STATE(TIM2_OSSIState));
+   assert_param(IS_TIM2_LOCK_LEVEL(TIM2_LockLevel));
+   assert_param(IS_TIM2_BREAK_STATE(TIM2_BreakState));
+   assert_param(IS_TIM2_BREAK_POLARITY(TIM2_BreakPolarity));
+   assert_param(IS_TIM2_AUTOMATIC_OUTPUT_STATE(TIM2_AutomaticOutput));
+ 
+   /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSI State,
+   the dead time value and the Automatic Output Enable Bit */
+ 
+   TIM2->BKR = (uint8_t)((uint8_t)TIM2_OSSIState | (uint8_t)TIM2_LockLevel | \
+                         (uint8_t)TIM2_BreakState | (uint8_t)TIM2_BreakPolarity | \
+                         (uint8_t)TIM2_AutomaticOutput);
+ }
+ 
+ /**
+   * @brief  Initializes the TIM2 peripheral according to the specified parameters.
+   * @param  TIM2_Channel: TIM2 Channel
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_Channel_1: Channel 1
+   *            @arg TIM2_Channel_2: Channel 2     
+   * @param  TIM2_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM2_ICSelection: Input Capture Selection
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM2_ICPrescaler: Input Capture Prescaler
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
+   * @param  TIM2_ICFilter: This parameter must be a value between 0x00 and 0x0F.
+   * @retval None
+   */
+ void TIM2_ICInit(TIM2_Channel_TypeDef TIM2_Channel,
+                  TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                  TIM2_ICSelection_TypeDef TIM2_ICSelection,
+                  TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
+                  uint8_t TIM2_ICFilter)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
+ 
+   if (TIM2_Channel == TIM2_Channel_1)
+   {
+     /* TI1 Configuration */
+     TI1_Config(TIM2_ICPolarity,
+                TIM2_ICSelection,
+                TIM2_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
+   }
+   else /* if (TIM2_Channel == TIM2_Channel_2) */
+   {
+     /* TI2 Configuration */
+     TI2_Config(TIM2_ICPolarity,
+                TIM2_ICSelection,
+                TIM2_ICFilter);
+     /* Set the Input Capture Prescaler value */
+     TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 peripheral in PWM Input Mode according to the
+   *         specified parameters.
+   * @param  TIM2_Channel: TIM2 Channel
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_Channel_1: Channel 1
+   *            @arg TIM2_Channel_2: Channel 2     
+   * @param  TIM2_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM2_ICSelection: Input Capture Selection
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM2_ICPrescaler: Input Capture Prescaler
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
+   * @retval None
+   */
+ void TIM2_PWMIConfig(TIM2_Channel_TypeDef TIM2_Channel,
+                      TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                      TIM2_ICSelection_TypeDef TIM2_ICSelection,
+                      TIM2_ICPSC_TypeDef TIM2_ICPrescaler,
+                      uint8_t TIM2_ICFilter)
+ {
+   uint8_t icpolarity = (uint8_t)TIM2_ICPolarity_Rising;
+   uint8_t icselection = (uint8_t)TIM2_ICSelection_DirectTI;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
+ 
+   /* Select the Opposite Input Polarity */
+   if (TIM2_ICPolarity == TIM2_ICPolarity_Rising)
+   {
+     icpolarity = (uint8_t)TIM2_ICPolarity_Falling;
+   }
+   else
+   {
+     icpolarity = (uint8_t)TIM2_ICPolarity_Rising;
+   }
+ 
+   /* Select the Opposite Input */
+   if (TIM2_ICSelection == TIM2_ICSelection_DirectTI)
+   {
+     icselection = (uint8_t)TIM2_ICSelection_IndirectTI;
+   }
+   else
+   {
+     icselection = (uint8_t)TIM2_ICSelection_DirectTI;
+   }
+ 
+   if (TIM2_Channel == TIM2_Channel_1)
+   {
+     /* TI1 Configuration */
+     TI1_Config(TIM2_ICPolarity, TIM2_ICSelection,
+                TIM2_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
+ 
+     /* TI2 Configuration */
+     TI2_Config((TIM2_ICPolarity_TypeDef)icpolarity, (TIM2_ICSelection_TypeDef)icselection, TIM2_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
+   }
+   else
+   {
+     /* TI2 Configuration */
+     TI2_Config(TIM2_ICPolarity, TIM2_ICSelection,
+                TIM2_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
+ 
+     /* TI1 Configuration */
+     TI1_Config((TIM2_ICPolarity_TypeDef)icpolarity, (TIM2_ICSelection_TypeDef)icselection, TIM2_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
+   }
+ }
+ 
+ /**
+   * @brief Enables or disables the TIM2 peripheral.
+   * @param NewState The new state of the TIM2 peripheral.
+   *          This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void TIM2_Cmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* set or Reset the CEN Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CR1 |= TIM_CR1_CEN;
+   }
+   else
+   {
+     TIM2->CR1 &= (uint8_t)(~TIM_CR1_CEN);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM2 peripheral Main Outputs.
+   * @param  NewState: The new state of the TIM2 peripheral.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_CtrlPWMOutputs(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the MOE Bit */
+ 
+   if (NewState != DISABLE)
+   {
+     TIM2->BKR |= TIM_BKR_MOE ;
+   }
+   else
+   {
+     TIM2->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the specified TIM2 interrupts.
+   * @param  TIM2_IT: Specifies the TIM2 interrupts sources to be enabled or disabled.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM2_IT_Update: Update
+   *            @arg TIM2_IT_CC1: Capture Compare Channel1
+   *            @arg TIM2_IT_CC2: Capture Compare Channel2 
+   *            @arg TIM2_IT_Trigger: Trigger 
+   *            @arg TIM2_IT_Break: Break  
+   * @param  NewState: The new state of the TIM2 peripheral.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_ITConfig(TIM2_IT_TypeDef TIM2_IT, FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_IT(TIM2_IT));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the Interrupt sources */
+     TIM2->IER |= (uint8_t)TIM2_IT;
+   }
+   else
+   {
+     /* Disable the Interrupt sources */
+     TIM2->IER &= (uint8_t)(~(uint8_t)TIM2_IT);
+   }
+ }
+ 
+ /**
+   * @brief  Enables the TIM2 internal Clock.
+   * @param  None
+   * @retval None
+   */
+ void TIM2_InternalClockConfig(void)
+ {
+   /* Disable slave mode to clock the prescaler directly with the internal clock */
+   TIM2->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 External clock Mode1.
+   * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
+   *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
+   *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
+   *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)   
+   * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
+   *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
+   * @param  ExtTRGFilter: Specifies the External Trigger Filter.
+   *          This parameter must be a value between 0x00 and 0x0F
+   * @retval None
+   */
+ void TIM2_ETRClockMode1Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
+                               TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
+                               uint8_t TIM2_ExtTRGFilter)
+ {
+   /* Configure the ETR Clock source */
+   TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, TIM2_ExtTRGFilter);
+ 
+   /* Select the External clock mode1 */
+   TIM2->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
+   TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
+ 
+   /* Select the Trigger selection : ETRF */
+   TIM2->SMCR &= (uint8_t)(~TIM_SMCR_TS);
+   TIM2->SMCR |= (uint8_t)((TIM2_TRGSelection_TypeDef)TIM2_TRGSelection_ETRF);
+ }
+ 
+ /**
+   * @brief Configures the TIM2 External clock Mode2.
+   * @param TIM2_ExtTRGPrescaler Specifies the external Trigger Prescaler
+   * @param TIM2_ExtTRGPolarity  Specifies the external Trigger Polarity
+   * @param TIM2_ExtTRGFilter    Specifies the External Trigger Filter (must be a value between 0 and 15)
+   * @retval None
+   */
+ void TIM2_ETRClockMode2Config(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
+                               TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
+                               uint8_t TIM2_ExtTRGFilter)
+ {
+   /* Configure the ETR Clock source */
+   TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, TIM2_ExtTRGFilter);
+ 
+   /* Enable the External clock mode2 */
+   TIM2->ETR |= TIM_ETR_ECE ;
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 External clock Mode2.
+   * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
+   *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
+   *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
+   *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8) 
+   * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
+   *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
+   * @param  ExtTRGFilter: Specifies the External Trigger Filter.
+   *          This parameter must be a value between 0x00 and 0x0F
+   */
+ void TIM2_ETRConfig(TIM2_ExtTRGPSC_TypeDef TIM2_ExtTRGPrescaler,
+                     TIM2_ExtTRGPolarity_TypeDef TIM2_ExtTRGPolarity,
+                     uint8_t TIM2_ExtTRGFilter)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_EXT_PRESCALER(TIM2_ExtTRGPrescaler));
+   assert_param(IS_TIM2_EXT_POLARITY(TIM2_ExtTRGPolarity));
+   assert_param(IS_TIM2_EXT_FILTER(TIM2_ExtTRGFilter));
+   /* Set the Prescaler, the Filter value and the Polarity */
+   TIM2->ETR |= (uint8_t)((uint8_t)TIM2_ExtTRGPrescaler | (uint8_t)TIM2_ExtTRGPolarity | (uint8_t)TIM2_ExtTRGFilter);
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 Trigger as External Clock.
+   * @param  TIM2_TIxExternalCLKSource: Specifies Trigger source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_TIxExternalCLK1Source_TI1ED: External Clock mode 1 source = TI1ED
+   *            @arg TIM2_TIxExternalCLK1Source_TI1: External Clock mode 1 source = TI1 
+   *            @arg TIM2_TIxExternalCLK1Source_TI2: External Clock mode 1 source = TI2  
+   * @param  TIM2_ICPolarity: Specifies the TIx Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  ICFilter: Specifies the filter value.
+   *          This parameter must be a value between 0x00 and 0x0F
+   * @retval None
+   */
+ void TIM2_TIxExternalClockConfig(TIM2_TIxExternalCLK1Source_TypeDef TIM2_TIxExternalCLKSource,
+                                  TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                                  uint8_t TIM2_ICFilter)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_TIXCLK_SOURCE(TIM2_TIxExternalCLKSource));
+   assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
+   assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
+ 
+   /* Configure the TIM2 Input Clock Source */
+   if (TIM2_TIxExternalCLKSource == TIM2_TIxExternalCLK1Source_TI2)
+   {
+     TI2_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, TIM2_ICFilter);
+   }
+   else
+   {
+     TI1_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, TIM2_ICFilter);
+   }
+ 
+   /* Select the Trigger source */
+   TIM2_SelectInputTrigger((TIM2_TRGSelection_TypeDef)TIM2_TIxExternalCLKSource);
+ 
+   /* Select the External clock mode1 */
+   TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
+ }
+ 
+ /**
+   * @brief  Selects the TIM2 Input Trigger source.
+   * @param  TIM2_InputTriggerSource: Specifies Input Trigger source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_TRGSelection_TIM4: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM2_TRGSelection_TIM1: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM2_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM2_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM2_TRGSelection_TI1F_ED: TRIG Input source = TI1F_ED (TI1 Edge Detector)
+   *            @arg TIM2_TRGSelection_TI1FP1: TRIG Input source = TI1FP1 (Filtered Timer Input 1)
+   *            @arg TIM2_TRGSelection_TI2FP2: TRIG Input source = TI2FP2 (Filtered Timer Input 2)
+   *            @arg TIM2_TRGSelection_ETRF: TRIG Input source =  ETRF (External Trigger Input ) 
+   * @retval None
+   */
+ void TIM2_SelectInputTrigger(TIM2_TRGSelection_TypeDef TIM2_InputTriggerSource)
+ {
+   uint8_t tmpsmcr = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_TRIGGER_SELECTION(TIM2_InputTriggerSource));
+ 
+   tmpsmcr = TIM2->SMCR;
+ 
+   /* Select the Trigger Source */
+   tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
+   tmpsmcr |= (uint8_t)TIM2_InputTriggerSource;
+ 
+   TIM2->SMCR = (uint8_t)tmpsmcr;
+ }
+ 
+ /**
+   * @brief  Enables or Disables the TIM2 Update event.
+   * @param  NewState: The new state of the TIM2 peripheral Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_UpdateDisableConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the UDIS Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CR1 |= TIM_CR1_UDIS;
+   }
+   else
+   {
+     TIM2->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIM2 Update Request Interrupt source.
+   * @param  TIM2_UpdateSource: Specifies the Update source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_UpdateSource_Global: Global Update request source
+   *            @arg TIM2_UpdateSource_Regular: Regular Update request source 
+   * @retval None
+   */
+ void TIM2_UpdateRequestConfig(TIM2_UpdateSource_TypeDef TIM2_UpdateSource)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_UPDATE_SOURCE(TIM2_UpdateSource));
+ 
+   /* Set or Reset the URS Bit */
+   if (TIM2_UpdateSource == TIM2_UpdateSource_Regular)
+   {
+     TIM2->CR1 |= TIM_CR1_URS ;
+   }
+   else
+   {
+     TIM2->CR1 &= (uint8_t)(~TIM_CR1_URS);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or Disables the TIMs Hall sensor interface.
+   * @param  NewState: The new state of the TIM2 Hall sensor interface.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_SelectHallSensor(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the TI1S Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CR2 |= TIM_CR2_TI1S;
+   }
+   else
+   {
+     TIM2->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIMs One Pulse Mode.
+   * @param  TIM2_OPMode: Specifies the OPM Mode to be used.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OPMode_Single: Single one Pulse mode (OPM Active)
+   *            @arg TIM2_OPMode_Repetitive: Single one Pulse mode (OPM Active)  
+   * @retval None
+   */
+ void TIM2_SelectOnePulseMode(TIM2_OPMode_TypeDef TIM2_OPMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_OPM_MODE(TIM2_OPMode));
+ 
+   /* Set or Reset the OPM Bit */
+   if (TIM2_OPMode == TIM2_OPMode_Single)
+   {
+     TIM2->CR1 |= TIM_CR1_OPM ;
+   }
+   else
+   {
+     TIM2->CR1 &= (uint8_t)(~TIM_CR1_OPM);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIM2 Trigger Output Mode.
+   * @param  TIM2_TRGOSource: Specifies the Trigger Output source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_TRGOSource_Reset: Trigger Output source = Reset 
+   *            @arg TIM2_TRGOSource_Enable: Trigger Output source = TIM2 is enabled 
+   *            @arg TIM2_TRGOSource_Update: Trigger Output source = Update event
+   *            @arg TIM2_TRGOSource_OC1: Trigger Output source = output compare channel1
+   *            @arg TIM2_TRGOSource_OC1REF: Trigger Output source = output compare channel 1 reference
+   *            @arg TIM2_TRGOSource_OC2REF: Trigger Output source = output compare channel 2 reference   
+   * @retval None
+   */
+ void TIM2_SelectOutputTrigger(TIM2_TRGOSource_TypeDef TIM2_TRGOSource)
+ {
+   uint8_t tmpcr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_TRGO_SOURCE(TIM2_TRGOSource));
+ 
+   tmpcr2 = TIM2->CR2;
+ 
+   /* Reset the MMS Bits */
+   tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
+ 
+   /* Select the TRGO source */
+   tmpcr2 |= (uint8_t)TIM2_TRGOSource;
+ 
+   TIM2->CR2 = tmpcr2;
+ }
+ 
+ /**
+   * @brief  Selects the TIM2 Slave Mode.
+   * @param  TIM2_SlaveMode: Specifies the TIM2 Slave Mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_SlaveMode_Reset: Slave Mode Selection  = Reset
+   *            @arg TIM2_SlaveMode_Gated: Slave Mode Selection  = Gated
+   *            @arg TIM2_SlaveMode_Trigger: Slave Mode Selection  = Trigger
+   *            @arg TIM2_SlaveMode_External1: Slave Mode Selection  = External 1 
+   * @retval None
+   */
+ void TIM2_SelectSlaveMode(TIM2_SlaveMode_TypeDef TIM2_SlaveMode)
+ {
+   uint8_t tmpsmcr = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_SLAVE_MODE(TIM2_SlaveMode));
+ 
+   tmpsmcr = TIM2->SMCR;
+ 
+   /* Reset the SMS Bits */
+   tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
+ 
+   /* Select the Slave Mode */
+   tmpsmcr |= (uint8_t)TIM2_SlaveMode;
+ 
+   TIM2->SMCR = tmpsmcr;
+ }
+ 
+ /**
+   * @brief  Sets or Resets the TIM2 Master/Slave Mode.
+   * @param  NewState: The new state of the synchronization between TIM2 and its slaves (through TRGO).
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_SelectMasterSlaveMode(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the MSM Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->SMCR |= TIM_SMCR_MSM;
+   }
+   else
+   {
+     TIM2->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 Encoder Interface.
+   * @param  TIM2_EncoderMode: Specifies the TIM2 Encoder Mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_EncoderMode_TI1: Encoder mode 1
+   *            @arg TIM2_EncoderMode_TI2: Encoder mode 2
+   *            @arg TIM2_EncoderMode_TI12: Encoder mode 3   
+   * @param  TIM2_IC1Polarity: Specifies the IC1 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM2_IC2Polarity: Specifies the IC2 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge 
+   * @retval None
+   */
+ void TIM2_EncoderInterfaceConfig(TIM2_EncoderMode_TypeDef TIM2_EncoderMode,
+                                  TIM2_ICPolarity_TypeDef TIM2_IC1Polarity,
+                                  TIM2_ICPolarity_TypeDef TIM2_IC2Polarity)
+ {
+   uint8_t tmpsmcr = 0;
+   uint8_t tmpccmr1 = 0;
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_ENCODER_MODE(TIM2_EncoderMode));
+   assert_param(IS_TIM2_IC_POLARITY(TIM2_IC1Polarity));
+   assert_param(IS_TIM2_IC_POLARITY(TIM2_IC2Polarity));
+ 
+   tmpsmcr = TIM2->SMCR;
+   tmpccmr1 = TIM2->CCMR1;
+   tmpccmr2 = TIM2->CCMR2;
+ 
+   /* Set the encoder Mode */
+   tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
+   tmpsmcr |= (uint8_t)TIM2_EncoderMode;
+ 
+   /* Select the Capture Compare 1 and the Capture Compare 2 as input */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
+   tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
+   tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
+ 
+   /* Set the TI1 and the TI2 Polarities */
+   if (TIM2_IC1Polarity == TIM2_ICPolarity_Falling)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC1P ;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
+   }
+ 
+   if (TIM2_IC2Polarity == TIM2_ICPolarity_Falling)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC2P ;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
+   }
+ 
+   TIM2->SMCR = tmpsmcr;
+   TIM2->CCMR1 = tmpccmr1;
+   TIM2->CCMR2 = tmpccmr2;
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 Prescaler.
+   * @param  Prescaler: Specifies the Prescaler Register value
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            @arg TIM2_Prescaler_2: Time base Prescaler = 2
+   *            @arg TIM2_Prescaler_4: Time base Prescaler = 4
+   *            @arg TIM2_Prescaler_8: Time base Prescaler = 8
+   *            @arg TIM2_Prescaler_16: Time base Prescaler = 16
+   *            @arg TIM2_Prescaler_32: Time base Prescaler = 32
+   *            @arg TIM2_Prescaler_64: Time base Prescaler = 64
+   *            @arg TIM2_Prescaler_128: Time base Prescaler = 128  
+   * @param  TIM2_PSCReloadMode: Specifies the TIM2 Prescaler Reload mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_PSCReloadMode_Update: Prescaler value is reloaded at every update
+   *            @arg TIM2_PSCReloadMode_Immediate: Prescaler value is reloaded at every update  
+   * @retval None
+   */
+ void TIM2_PrescalerConfig(TIM2_Prescaler_TypeDef TIM2_Prescaler,
+                           TIM2_PSCReloadMode_TypeDef TIM2_PSCReloadMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_PRESCALER(TIM2_Prescaler));
+   assert_param(IS_TIM2_PRESCALER_RELOAD(TIM2_PSCReloadMode));
+ 
+   /* Set the Prescaler value */
+   TIM2->PSCR = (uint8_t)(TIM2_Prescaler);
+ 
+   /* Set or reset the UG Bit */
+   if (TIM2_PSCReloadMode == TIM2_PSCReloadMode_Immediate)
+   {
+     TIM2->EGR |= TIM_EGR_UG ;
+   }
+   else
+   {
+     TIM2->EGR &= (uint8_t)(~TIM_EGR_UG) ;
+   }
+ }
+ 
+ /**
+   * @brief  Specifies the TIM2 Counter Mode to be used.
+   * @param  TIM2_CounterMode: Specifies the Counter Mode to be used
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_CounterMode_Up: Counter Up Mode
+   *            @arg TIM2_CounterMode_Down: Counter Down Mode
+   *            @arg TIM2_CounterMode_CenterAligned1: Counter Central aligned Mode 1
+   *            @arg TIM2_CounterMode_CenterAligned2: Counter Central aligned Mode 2
+   *            @arg TIM2_CounterMode_CenterAligned3: Counter Central aligned Mode 3   
+   * @retval None
+   */
+ void TIM2_CounterModeConfig(TIM2_CounterMode_TypeDef TIM2_CounterMode)
+ {
+   uint8_t tmpcr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
+ 
+   tmpcr1 = TIM2->CR1;
+ 
+   /* Reset the CMS and DIR Bits */
+   tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
+ 
+   /* Set the Counter Mode */
+   tmpcr1 |= (uint8_t)TIM2_CounterMode;
+ 
+   TIM2->CR1 = tmpcr1;
+ }
+ 
+ /**
+   * @brief  Forces the TIM2 Channel1 output waveform to active or inactive level.
+   * @param  TIM2_ForcedAction: Specifies the forced Action to be set to the output waveform.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ForcedAction_Active: Output Reference is forced low 
+   *            @arg TIM2_ForcedAction_Inactive: Output Reference is forced high 
+   * @retval None
+   */
+ void TIM2_ForcedOC1Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction)
+ {
+   uint8_t tmpccmr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
+ 
+   tmpccmr1 = TIM2->CCMR1;
+ 
+   /* Reset the OCM Bits */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Configure The Forced output Mode */
+   tmpccmr1 |= (uint8_t)TIM2_ForcedAction;
+ 
+   TIM2->CCMR1 = tmpccmr1;
+ }
+ 
+ /**
+   * @brief  Forces the TIM2 Channel2 output waveform to active or inactive level.
+   * @param  TIM2_ForcedAction: Specifies the forced Action to be set to the output waveform.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ForcedAction_Active: Output Reference is forced low 
+   *            @arg TIM2_ForcedAction_Inactive: Output Reference is forced high 
+   * @retval None
+   */
+ void TIM2_ForcedOC2Config(TIM2_ForcedAction_TypeDef TIM2_ForcedAction)
+ {
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
+ 
+   tmpccmr2 = TIM2->CCMR2;
+ 
+   /* Reset the OCM Bits */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Configure The Forced output Mode */
+   tmpccmr2 |= (uint8_t)TIM2_ForcedAction;
+ 
+   TIM2->CCMR2 = tmpccmr2;
+ }
+ 
+ /**
+   * @brief  Enables or disables TIM2 peripheral Preload register on ARR.
+   * @param  NewState: The new state of the TIM2 peripheral Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_ARRPreloadConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the ARPE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CR1 |= TIM_CR1_ARPE;
+   }
+   else
+   {
+     TIM2->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR1.
+   * @param  NewState: The new state of the Capture Compare Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_OC1PreloadConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC1PE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CCMR1 |= TIM_CCMR_OCxPE ;
+   }
+   else
+   {
+     TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR2.
+   * @param  NewState: The new state of the Capture Compare Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_OC2PreloadConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC2PE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CCMR2 |= TIM_CCMR_OCxPE ;
+   }
+   else
+   {
+     TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
+   }
+ }
+ 
+ /**
+   * @brief Configures the TIM2 Capture Compare 1 Fast feature.
+   * @param NewState The new state of the Output Compare Fast Enable bit.
+   * @retval None
+   */
+ void TIM2_OC1FastCmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC1FE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CCMR1 |= TIM_CCMR_OCxFE ;
+   }
+   else
+   {
+     TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
+   }
+ }
+ 
+ /**
+   * @brief Configures the TIM2 Capture Compare 2 Fast feature.
+   * @param NewState The new state of the Output Compare Fast Enable bit.
+   * @retval None
+   */
+ void TIM2_OC2FastCmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC2FE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM2->CCMR2 |= TIM_CCMR_OCxFE ;
+   }
+   else
+   {
+     TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 event to be generated by software.
+   * @param  TIM2_EventSource: Specifies the event source.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM2_EventSource_Update: Update
+   *            @arg TIM2_EventSource_CC1: Capture Compare Channel1
+   *            @arg TIM2_EventSource_CC2: Capture Compare Channel2 
+   *            @arg TIM2_EventSource_Trigger: Trigger 
+   *            @arg TIM2_EventSource_Break: Break  
+   * @retval None
+   */
+ void TIM2_GenerateEvent(TIM2_EventSource_TypeDef TIM2_EventSource)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_EVENT_SOURCE((uint8_t)TIM2_EventSource));
+ 
+   /* Set the event sources */
+   TIM2->EGR |= (uint8_t)TIM2_EventSource;
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 Channel 1 polarity.
+   * @param  TIM2_OCPolarity: Specifies the OC1 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
+   * @retval None
+   */
+ void TIM2_OC1PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
+ 
+   /* Set or Reset the CC1P Bit */
+   if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC1P ;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM2 Channel 2 polarity.
+   * @param  TIM2_OCPolarity: Specifies the OC2 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
+   * @retval None
+   */
+ void TIM2_OC2PolarityConfig(TIM2_OCPolarity_TypeDef TIM2_OCPolarity)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
+ 
+   /* Set or Reset the CC2P Bit */
+   if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC2P ;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM2 Capture Compare Channel x.
+   * @param  TIM2_Channel: Specifies the TIM2 Channel.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_Channel_1: Channel 1
+   *            @arg TIM2_Channel_2: Channel 2  
+   * @param  NewState: Specifies the TIM2 Channel CCxE bit new state.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM2_CCxCmd(TIM2_Channel_TypeDef TIM2_Channel,
+                  FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (TIM2_Channel == TIM2_Channel_1)
+   {
+     /* Set or Reset the CC1E Bit */
+     if (NewState != DISABLE)
+     {
+       TIM2->CCER1 |= TIM_CCER1_CC1E ;
+     }
+     else
+     {
+       TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
+     }
+ 
+   }
+   else /* if (TIM2_Channel == TIM2_Channel_2) */
+   {
+     /* Set or Reset the CC2E Bit */
+     if (NewState != DISABLE)
+     {
+       TIM2->CCER1 |= TIM_CCER1_CC2E;
+     }
+     else
+     {
+       TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
+     }
+   }
+ 
+ }
+ 
+ /**
+   * @brief  Selects the TIM2 Output Compare Mode. This function disables the
+   *         selected channel before changing the Output Compare Mode. User has to
+   *         enable this channel using TIM2_CCxCmd and TIM2_CCxNCmd functions.
+   * @param  TIM2_Channel: Specifies the TIM2 Channel.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_Channel_1: Channel 1
+   *            @arg TIM2_Channel_2: Channel 2  
+   * @param  TIM2_OCMode: Specifies the TIM2 Output Compare Mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
+   *            @arg TIM2_OCMode_Active: Active Mode
+   *            @arg TIM2_OCMode_Inactive: Inactive Mode
+   *            @arg TIM2_OCMode_Toggle: Toggle Mode
+   *            @arg TIM2_OCMode_PWM1: PWM Mode 1
+   *            @arg TIM2_OCMode_PWM2: PWM Mode 2  
+   * @retval None
+   */
+ void TIM2_SelectOCxM(TIM2_Channel_TypeDef TIM2_Channel,
+                      TIM2_OCMode_TypeDef TIM2_OCMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
+   assert_param(IS_TIM2_OCM(TIM2_OCMode));
+ 
+   if (TIM2_Channel == TIM2_Channel_1)
+   {
+     /* Disable the Channel 1: Reset the CCE Bit */
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+ 
+     /* Reset the Output Compare Bits */
+     TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+     /* Set the Ouput Compare Mode */
+     TIM2->CCMR1 |= (uint8_t)TIM2_OCMode;
+   }
+   else /* if (TIM2_Channel == TIM2_Channel_2) */
+   {
+     /* Disable the Channel 2: Reset the CCE Bit */
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+ 
+     /* Reset the Output Compare Bits */
+     TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+     /* Set the Ouput Compare Mode */
+     TIM2->CCMR2 |= (uint8_t)TIM2_OCMode;
+   }
+ }
+ 
+ /**
+   * @brief  Sets the TIM2 Counter Register value.
+   * @param  Counter: Specifies the Counter register new value.
+   *          This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM2_SetCounter(uint16_t TIM2_Counter)
+ {
+ 
+   /* Set the Counter Register value */
+   TIM2->CNTRH = (uint8_t)(TIM2_Counter >> 8);
+   TIM2->CNTRL = (uint8_t)(TIM2_Counter);
+ }
+ 
+ /**
+   * @brief  Sets the TIM2 Autoreload Register value.
+   * @param  Autoreload: Specifies the Autoreload register new value.
+   *          This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM2_SetAutoreload(uint16_t TIM2_Autoreload)
+ {
+   /* Set the Autoreload Register value */
+   TIM2->ARRH = (uint8_t)(TIM2_Autoreload >> 8);
+   TIM2->ARRL = (uint8_t)(TIM2_Autoreload);
+ }
+ 
+ /**
+   * @brief  Sets the TIM2 Capture Compare1 Register value.
+   * @param  Compare: Specifies the Capture Compare1 register new value.
+   *         This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM2_SetCompare1(uint16_t TIM2_Compare)
+ {
+   /* Set the Capture Compare1 Register value */
+   TIM2->CCR1H = (uint8_t)(TIM2_Compare >> 8);
+   TIM2->CCR1L = (uint8_t)(TIM2_Compare);
+ }
+ 
+ /**
+   * @brief  Sets the TIM2 Capture Compare2 Register value.
+   * @param  Compare: Specifies the Capture Compare2 register new value.
+   *         This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM2_SetCompare2(uint16_t TIM2_Compare)
+ {
+   /* Set the Capture Compare2 Register value */
+   TIM2->CCR2H = (uint8_t)(TIM2_Compare >> 8);
+   TIM2->CCR2L = (uint8_t)(TIM2_Compare);
+ }
+ 
+ /**
+   * @brief  Sets the TIM2 Input Capture 1 prescaler.
+   * @param  TIM2_IC1Prescaler: Specifies the Input Capture prescaler new value
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
+   * @retval None
+   */
+ void TIM2_SetIC1Prescaler(TIM2_ICPSC_TypeDef TIM2_IC1Prescaler)
+ {
+   uint8_t tmpccmr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC1Prescaler));
+ 
+   tmpccmr1 = TIM2->CCMR1;
+ 
+   /* Reset the IC1PSC Bits */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
+ 
+   /* Set the IC1PSC value */
+   tmpccmr1 |= (uint8_t)TIM2_IC1Prescaler;
+ 
+   TIM2->CCMR1 = tmpccmr1;
+ }
+ 
+ /**
+   * @brief  Sets the TIM2 Input Capture 2 prescaler.
+   * @param  TIM2_IC2Prescaler: Specifies the Input Capture prescaler new value
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
+   * @retval None
+   */
+ void TIM2_SetIC2Prescaler(TIM2_ICPSC_TypeDef TIM2_IC2Prescaler)
+ {
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC2Prescaler));
+ 
+   tmpccmr2 = TIM2->CCMR2;
+ 
+   /* Reset the IC2PSC Bits */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
+ 
+   /* Set the IC2PSC value */
+   tmpccmr2 |= (uint8_t)TIM2_IC2Prescaler;
+ 
+   TIM2->CCMR2 = tmpccmr2;
+ }
+ 
+ /**
+   * @brief  Gets the TIM2 Input Capture 1 value.
+   * @param  None
+   * @retval Capture Compare 1 Register value.
+   */
+ uint16_t TIM2_GetCapture1(void)
+ {
+   uint16_t tmpccr1 = 0;
+   uint8_t tmpccr1l, tmpccr1h;
+ 
+   tmpccr1h = TIM2->CCR1H;
+   tmpccr1l = TIM2->CCR1L;
+ 
+   tmpccr1 = (uint16_t)(tmpccr1l);
+   tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
+   /* Get the Capture 1 Register value */
+   return ((uint16_t)tmpccr1);
+ }
+ 
+ /**
+   * @brief  Gets the TIM2 Input Capture 2 value.
+   * @param  None
+   * @retval Capture Compare 2 Register value.
+   */
+ uint16_t TIM2_GetCapture2(void)
+ {
+   uint16_t tmpccr2 = 0;
+   uint8_t tmpccr2l, tmpccr2h;
+ 
+   tmpccr2h = TIM2->CCR2H;
+   tmpccr2l = TIM2->CCR2L;
+ 
+   tmpccr2 = (uint16_t)(tmpccr2l);
+   tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
+   /* Get the Capture 2 Register value */
+   return ((uint16_t)tmpccr2);
+ }
+ 
+ /**
+   * @brief  Gets the TIM2 Counter value.
+   * @param  None
+   * @retval Counter Register value.
+   */
+ uint16_t TIM2_GetCounter(void)
+ {
+   uint16_t tmpcnt = 0;
+   uint8_t tmpcntrl, tmpcntrh;
+ 
+   tmpcntrh = TIM2->CNTRH;
+   tmpcntrl = TIM2->CNTRL;
+ 
+   tmpcnt = (uint16_t)(tmpcntrl);
+   tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
+   /* Get the Counter Register value */
+   return ((uint16_t)tmpcnt);
+ }
+ 
+ /**
+   * @brief  Gets the TIM2 Prescaler value.
+   * @param  None
+   * @retval Prescaler Register value.
+   */
+ TIM2_Prescaler_TypeDef TIM2_GetPrescaler(void)
+ {
+   /* Get the Prescaler Register value */
+   return ((TIM2_Prescaler_TypeDef)TIM2->PSCR);
+ }
+ 
+ /**
+   * @brief  Checks whether the specified TIM2 flag is set or not.
+   * @param  TIM2_FLAG: Specifies the flag to check.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM2_FLAG_Update: Update
+   *            @arg TIM2_FLAG_CC1: Capture Compare Channel1
+   *            @arg TIM2_FLAG_CC2: Capture Compare Channel2 
+   *            @arg TIM2_FLAG_Trigger: Trigger 
+   *            @arg TIM2_FLAG_Break: Break  
+   *            @arg TIM2_FLAG_CC1OF: Capture compare 1 over capture
+   *            @arg TIM2_FLAG_CC2OF: Capture compare 2 over capture  
+   * @retval FlagStatus The new state of TIM2_FLAG.
+   */
+ FlagStatus TIM2_GetFlagStatus(TIM2_FLAG_TypeDef TIM2_FLAG)
+ {
+   FlagStatus bitstatus = RESET;
+   uint8_t tim2_flag_l, tim2_flag_h;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_GET_FLAG(TIM2_FLAG));
+ 
+   tim2_flag_l = (uint8_t)(TIM2->SR1 & (uint8_t)(TIM2_FLAG));
+   tim2_flag_h = (uint8_t)(TIM2->SR2 & (uint8_t)((uint16_t)TIM2_FLAG >> 8));
+ 
+   if ((uint8_t)(tim2_flag_l | tim2_flag_h) != 0)
+   {
+     bitstatus = SET;
+   }
+   else
+   {
+     bitstatus = RESET;
+   }
+   return ((FlagStatus)bitstatus);
+ }
+ 
+ /**
+   * @brief  Clears the TIMs pending flags.
+   * @param  TIM2_FLAG: Specifies the flag to clear.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM2_FLAG_Update: Update
+   *            @arg TIM2_FLAG_CC1: Capture Compare Channel1
+   *            @arg TIM2_FLAG_CC2: Capture Compare Channel2 
+   *            @arg TIM2_FLAG_Trigger: Trigger 
+   *            @arg TIM2_FLAG_Break: Break  
+   * @retval None
+   */
+ void TIM2_ClearFlag(TIM2_FLAG_TypeDef TIM2_FLAG)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_CLEAR_FLAG((uint16_t)TIM2_FLAG));
+   /* Clear the flags (rc_w0) clear this bit by writing 0. Writing 1 has no effect*/
+   TIM2->SR1 = (uint8_t)(~(uint8_t)(TIM2_FLAG));
+   TIM2->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM2_FLAG >> 8));
+ }
+ 
+ /**
+   * @brief  Checks whether the TIM2 interrupt has occurred or not.
+   * @param  TIM2_IT: Specifies the TIM2 interrupt source to check.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM2_IT_Update: Update
+   *            @arg TIM2_IT_CC1: Capture Compare Channel1
+   *            @arg TIM2_IT_CC2: Capture Compare Channel2 
+   *            @arg TIM2_IT_Trigger: Trigger 
+   *            @arg TIM2_IT_Break: Break  
+   * @retval ITStatus: The new state of the TIM2_IT (SET or RESET)
+   */
+ ITStatus TIM2_GetITStatus(TIM2_IT_TypeDef TIM2_IT)
+ {
+   __IO ITStatus bitstatus = RESET;
+ 
+   __IO uint8_t TIM2_itStatus = 0x0, TIM2_itEnable = 0x0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_GET_IT(TIM2_IT));
+ 
+   TIM2_itStatus = (uint8_t)(TIM2->SR1 & (uint8_t)TIM2_IT);
+ 
+   TIM2_itEnable = (uint8_t)(TIM2->IER & (uint8_t)TIM2_IT);
+ 
+   if ((TIM2_itStatus != (uint8_t)RESET) && (TIM2_itEnable != (uint8_t)RESET))
+   {
+     bitstatus = (ITStatus)SET;
+   }
+   else
+   {
+     bitstatus = (ITStatus)RESET;
+   }
+   return ((ITStatus)bitstatus);
+ }
+ 
+ /**
+   * @brief  Clears the TIM's interrupt pending bits.
+   * @param  TIM2_IT: Specifies the pending bit to clear.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM2_IT_Update: Update
+   *            @arg TIM2_IT_CC1: Capture Compare Channel1
+   *            @arg TIM2_IT_CC2: Capture Compare Channel2 
+   *            @arg TIM2_IT_Trigger: Trigger 
+   *            @arg TIM2_IT_Break: Break  
+   * @retval None
+   */
+ void TIM2_ClearITPendingBit(TIM2_IT_TypeDef TIM2_IT)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM2_IT(TIM2_IT));
+ 
+   /* Clear the IT pending Bit */
+   TIM2->SR1 = (uint8_t)(~(uint8_t)TIM2_IT);
+ }
+ 
+ /**
+   * @brief  Configure the TI1 as Input.
+   * @param  TIM2_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM2_ICSelection: Specifies the input to be used.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM2_ICFilter: Specifies the Input Capture Filter.
+   *          This parameter must be a value between 0x00 and 0x0F.
+   * @retval None
+   */
+ static void TI1_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity, \
+                        TIM2_ICSelection_TypeDef TIM2_ICSelection, \
+                        uint8_t TIM2_ICFilter)
+ {
+   uint8_t tmpccmr1 = 0;
+   uint8_t tmpicpolarity = (uint8_t)TIM2_ICPolarity;
+   tmpccmr1 = TIM2->CCMR1;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
+   assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
+   assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
+ 
+   /* Disable the Channel 1: Reset the CCE Bit */
+   TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+ 
+   /* Select the Input and set the filter */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
+   tmpccmr1 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
+ 
+   TIM2->CCMR1 = tmpccmr1;
+ 
+   /* Select the Polarity */
+   if (tmpicpolarity == (uint8_t)(TIM2_ICPolarity_Falling))
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC1P;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
+   }
+ 
+   /* Set the CCE Bit */
+   TIM2->CCER1 |=  TIM_CCER1_CC1E;
+ }
+ 
+ /**
+   * @brief  Configure the TI2 as Input.
+   * @param  TIM2_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM2_ICSelection: Specifies the input to be used.
+   *          This parameter can be one of the following values:
+   *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM2_ICFilter: Specifies the Input Capture Filter.
+   *          This parameter must be a value between 0x00 and 0x0F.
+   * @retval None
+   */
+ static void TI2_Config(TIM2_ICPolarity_TypeDef TIM2_ICPolarity,
+                        TIM2_ICSelection_TypeDef TIM2_ICSelection,
+                        uint8_t TIM2_ICFilter)
+ {
+   uint8_t tmpccmr2 = 0;
+   uint8_t tmpicpolarity = (uint8_t)TIM2_ICPolarity;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
+   assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
+   assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
+ 
+   tmpccmr2 = TIM2->CCMR2;
+ 
+   /* Disable the Channel 2: Reset the CCE Bit */
+   TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+ 
+   /* Select the Input and set the filter */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
+   tmpccmr2 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
+ 
+   TIM2->CCMR2 = tmpccmr2;
+ 
+   /* Select the Polarity */
+   if (tmpicpolarity == (uint8_t)TIM2_ICPolarity_Falling)
+   {
+     TIM2->CCER1 |= TIM_CCER1_CC2P ;
+   }
+   else
+   {
+     TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
+   }
+ 
+   /* Set the CCE Bit */
+   TIM2->CCER1 |=  TIM_CCER1_CC2E;
+ }
+ 
+ /**
+   * @brief  Compute the frequency of the LSI clock expressed in Hertz.
+   * @note   The timer clock must be a high speed clock: HSI or HSE
+   * @note   It is recommended to use the maximum clock frequency, that is 10 MHz,
+   *         to obtain a more precise result.
+   * @param  TIM2_TimerClockFreq The TIM2 clock frequency expressed in Hertz.
+   * @retval LSI Clock Frequency value.
+   */
+ uint32_t TIM2_ComputeLsiClockFreq(uint32_t TIM2_TimerClockFreq)
+ {
+   uint32_t LSIClockFreq;
+   uint16_t ICValue1, ICValue2;
+ 
+   /* Capture only every 8 events!!! */
+   TIM2_ICInit(TIM2_Channel_1, TIM2_ICPolarity_Rising, TIM2_ICSelection_DirectTI, TIM2_ICPSC_Div8, 0x0);
+ 
+   /* Enable CC1 interrupt */
+   TIM2_ITConfig(TIM2_IT_CC1, ENABLE);
+ 
+   /* Enable TIM2 */
+   TIM2_Cmd(ENABLE);
+ 
+   TIM2->SR1 = 0x00;
+   TIM2->SR2 = 0x00;
+ 
+   /* Clear CC1 Flag*/
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+ 
+   /* wait a capture on cc1 */
+   while ((TIM2->SR1 & (uint8_t)TIM2_FLAG_CC1) != (uint8_t)TIM2_FLAG_CC1)
+   {}
+   /* Get CCR1 value*/
+   ICValue1 = TIM2_GetCapture1();
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+ 
+   /* wait a capture on cc1 */
+   while ((TIM2->SR1 & (uint8_t)TIM2_FLAG_CC1) != (uint8_t)TIM2_FLAG_CC1)
+   {}
+   /* Get CCR1 value*/
+   ICValue2 = TIM2_GetCapture1();
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+ 
+   /* Disable IC1 input capture */
+   TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+   /* Reset CCMR1 register */
+   TIM2->CCMR1 = 0x00;
+   /* Disable TIM2 */
+   TIM2_Cmd(DISABLE);
+ 
+   /* Compute LSI clock frequency */
+   LSIClockFreq = (8 * TIM2_TimerClockFreq) / (ICValue2 - ICValue1);
+   return LSIClockFreq;
+ }
+ 
+ /**
+   * @brief Checks whether the TIM2 device is enabled or not.
+   * @param None
+   * @retval FunctionalState The new state of the TIM2 device.
+   */
+ FunctionalState TIM2_GetStatus(void)
+ {
+   return ((FunctionalState)(TIM2->CR1 & TIM_CR1_CEN));
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim3.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim3.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim3.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim3.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,1813 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_tim3.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the TIM3 peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_tim3.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ 
+ /** @defgroup TIM3 
+   * @brief TIM3 driver modules
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ 
+ /* Private function prototypes -----------------------------------------------*/
+ static void TI1_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                        TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                        uint8_t TIM3_ICFilter);
+ 
+ static void TI2_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                        TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                        uint8_t TIM3_ICFilter);
+ 
+ /**
+   * @addtogroup TIM3_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the TIM3 peripheral registers to their default reset values.
+   * @param  None
+   * @retval None
+   */
+ void TIM3_DeInit(void)
+ {
+   TIM3->CR1 = TIM_CR1_RESET_VALUE;
+   TIM3->CR2 = TIM_CR2_RESET_VALUE;
+   TIM3->SMCR = TIM_SMCR_RESET_VALUE;
+   TIM3->ETR = TIM_ETR_RESET_VALUE;
+   TIM3->IER = TIM_IER_RESET_VALUE;
+   TIM3->SR2 = TIM_SR2_RESET_VALUE;
+ 
+   /* Disable channels */
+   TIM3->CCER1 = TIM_CCER1_RESET_VALUE;
+   /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
+   TIM3->CCMR1 = 0x01;/*TIM3_ICxSource_TIxFPx */
+   TIM3->CCMR2 = 0x01;/*TIM3_ICxSource_TIxFPx */
+ 
+   /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
+   TIM3->CCER1 = TIM_CCER1_RESET_VALUE;
+   TIM3->CCMR1 = TIM_CCMR1_RESET_VALUE;
+   TIM3->CCMR2 = TIM_CCMR2_RESET_VALUE;
+ 
+   TIM3->CNTRH = TIM_CNTRH_RESET_VALUE;
+   TIM3->CNTRL = TIM_CNTRL_RESET_VALUE;
+ 
+   TIM3->PSCR = TIM_PSCR_RESET_VALUE;
+ 
+   TIM3->ARRH = TIM_ARRH_RESET_VALUE;
+   TIM3->ARRL = TIM_ARRL_RESET_VALUE;
+ 
+   TIM3->CCR1H = TIM_CCR1H_RESET_VALUE;
+   TIM3->CCR1L = TIM_CCR1L_RESET_VALUE;
+   TIM3->CCR2H = TIM_CCR2H_RESET_VALUE;
+   TIM3->CCR2L = TIM_CCR2L_RESET_VALUE;
+ 
+ 
+   TIM3->OISR = TIM_OISR_RESET_VALUE;
+   TIM3->EGR = 0x01;/*TIM_EGR_UG;*/
+   TIM3->BKR = TIM_BKR_RESET_VALUE;
+   TIM3->SR1 = TIM_SR1_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Initializes the TIM3 Time Base Unit according to the specified  parameters.
+   * @param  TIM3_Prescaler: Prescaler 
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            @arg TIM3_Prescaler_2: Time base Prescaler = 2
+   *            @arg TIM3_Prescaler_4: Time base Prescaler = 4
+   *            @arg TIM3_Prescaler_8: Time base Prescaler = 8
+   *            @arg TIM3_Prescaler_16: Time base Prescaler = 16
+   *            @arg TIM3_Prescaler_32: Time base Prescaler = 32
+   *            @arg TIM3_Prescaler_64: Time base Prescaler = 64
+   *            @arg TIM3_Prescaler_128: Time base Prescaler = 128                            
+   * @param  TIM3_CounterMode: Counter mode
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_CounterMode_Up: Counter Up Mode
+   *            @arg TIM3_CounterMode_Down: Counter Down Mode
+   *            @arg TIM3_CounterMode_CenterAligned1: Counter Central aligned Mode 1
+   *            @arg TIM3_CounterMode_CenterAligned2: Counter Central aligned Mode 2
+   *            @arg TIM3_CounterMode_CenterAligned3: Counter Central aligned Mode 3        
+   * @param  TIM3_Period: This parameter must be a value between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ 
+ void TIM3_TimeBaseInit(TIM3_Prescaler_TypeDef TIM3_Prescaler,
+                        TIM3_CounterMode_TypeDef TIM3_CounterMode,
+                        uint16_t TIM3_Period)
+ {
+ 
+   assert_param(IS_TIM3_PRESCALER(TIM3_Prescaler));
+   assert_param(IS_TIM3_COUNTER_MODE(TIM3_CounterMode));
+ 
+ 
+ 
+   /* Set the Autoreload value */
+   TIM3->ARRH = (uint8_t)(TIM3_Period >> 8) ;
+   TIM3->ARRL = (uint8_t)(TIM3_Period);
+ 
+   /* Set the Prescaler value */
+   TIM3->PSCR = (uint8_t)(TIM3_Prescaler);
+ 
+   /* Select the Counter Mode */
+   TIM3->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
+   TIM3->CR1 |= (uint8_t)(TIM3_CounterMode);
+ }
+ 
+ /**
+   * @brief  Initializes the TIM3 Channel1 according to the specified parameters.
+   * @param  TIM3_OCMode: Output Compare Mode 
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCMode_Timing: Timing (Frozen) Mode
+   *            @arg TIM3_OCMode_Active: Active Mode
+   *            @arg TIM3_OCMode_Inactive: Inactive Mode
+   *            @arg TIM3_OCMode_Toggle: Toggle Mode
+   *            @arg TIM3_OCMode_PWM1: PWM Mode 1
+   *            @arg TIM3_OCMode_PWM2: PWM Mode 2          
+   * @param  TIM3_OutputState: Output state
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OutputState_Disable: Output compare State disabled (channel output disabled)
+   *            @arg TIM3_OutputState_Enable: Output compare State enabled (channel output enabled)
+   * @param  TIM3_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
+   * @param  TIM3_OCPolarity: Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
+   * @param  TIM3_OCIdleState: Output Compare Idle State
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCIdleState_Reset: Output Compare Idle state  = Reset
+   *            @arg TIM3_OCIdleState_Set: Output Compare Idle state  = Set
+   * @retval None
+   */
+ void TIM3_OC1Init(TIM3_OCMode_TypeDef TIM3_OCMode,
+                   TIM3_OutputState_TypeDef TIM3_OutputState,
+                   uint16_t TIM3_Pulse,
+                   TIM3_OCPolarity_TypeDef TIM3_OCPolarity,
+                   TIM3_OCIdleState_TypeDef TIM3_OCIdleState)
+ {
+   uint8_t tmpccmr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_OC_MODE(TIM3_OCMode));
+   assert_param(IS_TIM3_OUTPUT_STATE(TIM3_OutputState));
+   assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
+   assert_param(IS_TIM3_OCIDLE_STATE(TIM3_OCIdleState));
+ 
+   tmpccmr1 = TIM3->CCMR1;
+ 
+   /* Disable the Channel 1: Reset the CCE Bit */
+   TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+   /* Reset the Output Compare Bits */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Set the Ouput Compare Mode */
+   tmpccmr1 |= (uint8_t)TIM3_OCMode;
+ 
+   TIM3->CCMR1 = tmpccmr1;
+ 
+   /* Set the Output State */
+   if (TIM3_OutputState == TIM3_OutputState_Enable)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC1E;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+   }
+ 
+   /* Set the Output Polarity */
+   if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC1P;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
+   }
+ 
+   /* Set the Output Idle state */
+   if (TIM3_OCIdleState == TIM3_OCIdleState_Set)
+   {
+     TIM3->OISR |= TIM_OISR_OIS1;
+   }
+   else
+   {
+     TIM3->OISR &= (uint8_t)(~TIM_OISR_OIS1);
+   }
+ 
+   /* Set the Pulse value */
+   TIM3->CCR1H = (uint8_t)(TIM3_Pulse >> 8);
+   TIM3->CCR1L = (uint8_t)(TIM3_Pulse);
+ }
+ 
+ /**
+   * @brief  Initializes the TIM3 Channel2 according to the specified parameters.
+   * @param  TIM3_OCMode: Output Compare Mode 
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCMode_Timing: Timing (Frozen) Mode
+   *            @arg TIM3_OCMode_Active: Active Mode
+   *            @arg TIM3_OCMode_Inactive: Inactive Mode
+   *            @arg TIM3_OCMode_Toggle: Toggle Mode
+   *            @arg TIM3_OCMode_PWM1: PWM Mode 1
+   *            @arg TIM3_OCMode_PWM2: PWM Mode 2          
+   * @param  TIM3_OutputState: Output state
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OutputState_Disable: Output compare State disabled (channel output disabled)
+   *            @arg TIM3_OutputState_Enable: Output compare State enabled (channel output enabled)
+   * @param  TIM3_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
+   * @param  TIM3_OCPolarity: Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
+   * @param  TIM3_OCIdleState: Output Compare Idle State
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCIdleState_Reset: Output Compare Idle state  = Reset
+   *            @arg TIM3_OCIdleState_Set: Output Compare Idle state  = Set
+   * @retval None
+   */
+ void TIM3_OC2Init(TIM3_OCMode_TypeDef TIM3_OCMode,
+                   TIM3_OutputState_TypeDef TIM3_OutputState,
+                   uint16_t TIM3_Pulse,
+                   TIM3_OCPolarity_TypeDef TIM3_OCPolarity,
+                   TIM3_OCIdleState_TypeDef TIM3_OCIdleState)
+ {
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_OC_MODE(TIM3_OCMode));
+   assert_param(IS_TIM3_OUTPUT_STATE(TIM3_OutputState));
+   assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
+   assert_param(IS_TIM3_OCIDLE_STATE(TIM3_OCIdleState));
+ 
+   tmpccmr2 = TIM3->CCMR2;
+ 
+   /* Disable the Channel 2: Reset the CCE Bit */
+   TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+ 
+   /* Reset the Output Compare Bits */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Set the Ouput Compare Mode */
+   tmpccmr2 |= (uint8_t)TIM3_OCMode;
+ 
+   TIM3->CCMR2 = tmpccmr2;
+ 
+   /* Set the Output State */
+   if (TIM3_OutputState == TIM3_OutputState_Enable)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC2E;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+   }
+ 
+   /* Set the Output Polarity */
+   if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC2P;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
+   }
+ 
+ 
+   /* Set the Output Idle state */
+   if (TIM3_OCIdleState == TIM3_OCIdleState_Set)
+   {
+     TIM3->OISR |= TIM_OISR_OIS2;
+   }
+   else
+   {
+     TIM3->OISR &= (uint8_t)(~TIM_OISR_OIS2);
+   }
+ 
+   /* Set the Pulse value */
+   TIM3->CCR2H = (uint8_t)(TIM3_Pulse >> 8);
+   TIM3->CCR2L = (uint8_t)(TIM3_Pulse);
+ }
+ 
+ /**
+   * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
+   *         and the AOE(automatic output enable).
+   * @param  TIM3_OSSIState: Off-State Selection for Idle mode states.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OSSIState_Enable: Off-State Selection for Idle mode enabled
+   *            @arg TIM3_OSSIState_Disable: Off-State Selection for Idle mode disabled 
+   * @param  TIM3_LockLevel: Lock level.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_LockLevel_Off: Lock option disabled
+   *            @arg TIM3_LockLevel_1: Select Lock Level 1
+   *            @arg TIM3_LockLevel_2: Select Lock Level 2
+   *            @arg TIM3_LockLevel_3: Select Lock Level 3    
+   * @param  TIM3_BreakState: Break Input enable/disable .
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_BreakState_Disable: Break State disabled (break option disabled)
+   *            @arg TIM3_BreakState_Enable: Break State enabled (break option enabled) 
+   * @param  TIM3_BreakPolarity: Break Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_BreakPolarity_High: if Break, channel polarity = High
+   *            @arg TIM3_BreakPolarity_Low: if Break, channel polarity = Low   
+   * @param  TIM3_AutomaticOutput: TIM3 AOE Bit Set/Reset .
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_AutomaticOutput_Enable: Automatic Output option enabled
+   *            @arg TIM3_AutomaticOutput_Disable: Automatic Output option disabled
+   * @retval None
+   */
+ void TIM3_BKRConfig(TIM3_OSSIState_TypeDef TIM3_OSSIState,
+                     TIM3_LockLevel_TypeDef TIM3_LockLevel,
+                     TIM3_BreakState_TypeDef TIM3_BreakState,
+                     TIM3_BreakPolarity_TypeDef TIM3_BreakPolarity,
+                     TIM3_AutomaticOutput_TypeDef TIM3_AutomaticOutput)
+ 
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_OSSI_STATE(TIM3_OSSIState));
+   assert_param(IS_TIM3_LOCK_LEVEL(TIM3_LockLevel));
+   assert_param(IS_TIM3_BREAK_STATE(TIM3_BreakState));
+   assert_param(IS_TIM3_BREAK_POLARITY(TIM3_BreakPolarity));
+   assert_param(IS_TIM3_AUTOMATIC_OUTPUT_STATE(TIM3_AutomaticOutput));
+ 
+ 
+ 
+   /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
+   the dead time value and the Automatic Output Enable Bit */
+ 
+   TIM3->BKR = (uint8_t)((uint8_t)TIM3_OSSIState | (uint8_t)TIM3_LockLevel | \
+                         (uint8_t)TIM3_BreakState | (uint8_t)TIM3_BreakPolarity | \
+                         (uint8_t)TIM3_AutomaticOutput);
+ }
+ 
+ /**
+   * @brief  Initializes the TIM3 peripheral according to the specified parameters.
+   * @param  TIM3_Channel: TIM3 Channel
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_Channel_1: Channel 1
+   *            @arg TIM3_Channel_2: Channel 2     
+   * @param  TIM3_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM3_ICSelection: Input Capture Selection
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM3_ICPrescaler: Input Capture Prescaler
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
+   * @param  TIM3_ICFilter: This parameter must be a value between 0x00 and 0x0F.
+   * @retval None
+   */
+ void TIM3_ICInit(TIM3_Channel_TypeDef TIM3_Channel,
+                  TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                  TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                  TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
+                  uint8_t TIM3_ICFilter)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
+ 
+   if (TIM3_Channel == TIM3_Channel_1)
+   {
+     /* TI1 Configuration */
+     TI1_Config(TIM3_ICPolarity,
+                TIM3_ICSelection,
+                TIM3_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
+   }
+   else /* if (TIM3_Channel == TIM3_Channel_2) */
+   {
+     /* TI2 Configuration */
+     TI2_Config(TIM3_ICPolarity,
+                TIM3_ICSelection,
+                TIM3_ICFilter);
+     /* Set the Input Capture Prescaler value */
+     TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 peripheral in PWM Input Mode according to the
+   *         specified parameters.
+   * @param  TIM3_Channel: TIM3 Channel
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_Channel_1: Channel 1
+   *            @arg TIM3_Channel_2: Channel 2     
+   * @param  TIM3_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM3_ICSelection: Input Capture Selection
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM3_ICPrescaler: Input Capture Prescaler
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
+   * @retval None
+   */
+ void TIM3_PWMIConfig(TIM3_Channel_TypeDef TIM3_Channel,
+                      TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                      TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                      TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
+                      uint8_t TIM3_ICFilter)
+ {
+   uint8_t icpolarity = (uint8_t)TIM3_ICPolarity_Rising;
+   uint8_t icselection = (uint8_t)TIM3_ICSelection_DirectTI;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
+ 
+   /* Select the Opposite Input Polarity */
+   if (TIM3_ICPolarity == TIM3_ICPolarity_Rising)
+   {
+     icpolarity = (uint8_t)TIM3_ICPolarity_Falling;
+   }
+   else
+   {
+     icpolarity = (uint8_t)TIM3_ICPolarity_Rising;
+   }
+ 
+   /* Select the Opposite Input */
+   if (TIM3_ICSelection == TIM3_ICSelection_DirectTI)
+   {
+     icselection = (uint8_t)TIM3_ICSelection_IndirectTI;
+   }
+   else
+   {
+     icselection = (uint8_t)TIM3_ICSelection_DirectTI;
+   }
+ 
+   if (TIM3_Channel == TIM3_Channel_1)
+   {
+     /* TI1 Configuration */
+     TI1_Config(TIM3_ICPolarity, TIM3_ICSelection,
+                TIM3_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
+ 
+     /* TI2 Configuration */
+     TI2_Config((TIM3_ICPolarity_TypeDef)icpolarity, (TIM3_ICSelection_TypeDef)icselection, TIM3_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
+   }
+   else
+   {
+     /* TI2 Configuration */
+     TI2_Config(TIM3_ICPolarity, TIM3_ICSelection,
+                TIM3_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
+ 
+     /* TI1 Configuration */
+     TI1_Config((TIM3_ICPolarity_TypeDef)icpolarity, (TIM3_ICSelection_TypeDef)icselection, TIM3_ICFilter);
+ 
+     /* Set the Input Capture Prescaler value */
+     TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM3 peripheral.
+   * @param  NewState: The new state of the TIM3 peripheral.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_Cmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* set or Reset the CEN Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CR1 |= TIM_CR1_CEN;
+   }
+   else
+   {
+     TIM3->CR1 &= (uint8_t)(~TIM_CR1_CEN);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM3 peripheral Main Outputs.
+   * @param  NewState: The new state of the TIM3 peripheral.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_CtrlPWMOutputs(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the MOE Bit */
+ 
+   if (NewState != DISABLE)
+   {
+     TIM3->BKR |= TIM_BKR_MOE ;
+   }
+   else
+   {
+     TIM3->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the specified TIM3 interrupts.
+   * @param  TIM3_IT: Specifies the TIM3 interrupts sources to be enabled or disabled.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM3_IT_Update: Update
+   *            @arg TIM3_IT_CC1: Capture Compare Channel1
+   *            @arg TIM3_IT_CC2: Capture Compare Channel2 
+   *            @arg TIM3_IT_Trigger: Trigger 
+   *            @arg TIM3_IT_Break: Break  
+   * @param  NewState: The new state of the TIM3 peripheral.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_ITConfig(TIM3_IT_TypeDef TIM3_IT, FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_IT(TIM3_IT));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the Interrupt sources */
+     TIM3->IER |= (uint8_t)TIM3_IT;
+   }
+   else
+   {
+     /* Disable the Interrupt sources */
+     TIM3->IER &= (uint8_t)(~(uint8_t)TIM3_IT);
+   }
+ }
+ 
+ /**
+   * @brief  Enables the TIM3 internal Clock.
+   * @param  None
+   * @retval None
+   */
+ void TIM3_InternalClockConfig(void)
+ {
+   /* Disable slave mode to clock the prescaler directly with the internal clock */
+   TIM3->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 External clock Mode1.
+   * @param  TIM3_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ExtTRGPSC_OFF: No External Trigger prescaler
+   *            @arg TIM3_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
+   *            @arg TIM3_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
+   *            @arg TIM3_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)   
+   * @param  TIM3_ExtTRGPolarity: Specifies the external Trigger Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
+   *            @arg TIM3_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
+   * @param  ExtTRGFilter: Specifies the External Trigger Filter.
+   *          This parameter must be a value between 0x00 and 0x0F
+   * @retval None
+   */
+ void TIM3_ETRClockMode1Config(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
+                               TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
+                               uint8_t TIM3_ExtTRGFilter)
+ {
+   /* Configure the ETR Clock source */
+   TIM3_ETRConfig(TIM3_ExtTRGPrescaler, TIM3_ExtTRGPolarity, TIM3_ExtTRGFilter);
+ 
+   /* Select the External clock mode1 */
+   TIM3->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
+   TIM3->SMCR |= (uint8_t)(TIM3_SlaveMode_External1);
+ 
+   /* Select the Trigger selection : ETRF */
+   TIM3->SMCR &= (uint8_t)(~TIM_SMCR_TS);
+   TIM3->SMCR |= (uint8_t)((TIM3_TRGSelection_TypeDef)TIM3_TRGSelection_ETRF);
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 External clock Mode2.
+   * @param  TIM3_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ExtTRGPSC_OFF: No External Trigger prescaler
+   *            @arg TIM3_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
+   *            @arg TIM3_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
+   *            @arg TIM3_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8) 
+   * @param  TIM3_ExtTRGPolarity: Specifies the external Trigger Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
+   *            @arg TIM3_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
+   * @param  ExtTRGFilter: Specifies the External Trigger Filter.
+   *          This parameter must be a value between 0x00 and 0x0F
+   * @retval None
+   */
+ void TIM3_ETRClockMode2Config(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
+                               TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
+                               uint8_t TIM3_ExtTRGFilter)
+ {
+   /* Configure the ETR Clock source */
+   TIM3_ETRConfig(TIM3_ExtTRGPrescaler, TIM3_ExtTRGPolarity, TIM3_ExtTRGFilter);
+ 
+   /* Enable the External clock mode2 */
+   TIM3->ETR |= TIM_ETR_ECE ;
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 External Trigger.
+   * @param  TIM3_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ExtTRGPSC_OFF: No External Trigger prescaler
+   *            @arg TIM3_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
+   *            @arg TIM3_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4)
+   *            @arg TIM3_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)    
+   * @param  TIM3_ExtTRGPolarity: Specifies the external Trigger Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
+   *            @arg TIM3_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
+   * @param  ExtTRGFilter: Specifies the External Trigger Filter.
+   *          This parameter must be a value between 0x00 and 0x0F
+   * @retval None
+   */
+ void TIM3_ETRConfig(TIM3_ExtTRGPSC_TypeDef TIM3_ExtTRGPrescaler,
+                     TIM3_ExtTRGPolarity_TypeDef TIM3_ExtTRGPolarity,
+                     uint8_t TIM3_ExtTRGFilter)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_EXT_PRESCALER(TIM3_ExtTRGPrescaler));
+   assert_param(IS_TIM3_EXT_POLARITY(TIM3_ExtTRGPolarity));
+   assert_param(IS_TIM3_EXT_FILTER(TIM3_ExtTRGFilter));
+   /* Set the Prescaler, the Filter value and the Polarity */
+   TIM3->ETR |= (uint8_t)((uint8_t)TIM3_ExtTRGPrescaler | (uint8_t)TIM3_ExtTRGPolarity | (uint8_t)TIM3_ExtTRGFilter);
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 Trigger as External Clock.
+   * @param  TIM3_TIxExternalCLKSource: Specifies Trigger source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_TIxExternalCLK1Source_TI1ED: External Clock mode 1 source = TI1ED
+   *            @arg TIM3_TIxExternalCLK1Source_TI1: External Clock mode 1 source = TI1 
+   *            @arg TIM3_TIxExternalCLK1Source_TI2: External Clock mode 1 source = TI2  
+   * @param  TIM3_ICPolarity: Specifies the TIx Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  ICFilter: Specifies the filter value.
+   *          This parameter must be a value between 0x00 and 0x0F
+   * @retval None
+   */
+ void TIM3_TIxExternalClockConfig(TIM3_TIxExternalCLK1Source_TypeDef TIM3_TIxExternalCLKSource,
+                                  TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                                  uint8_t TIM3_ICFilter)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_TIXCLK_SOURCE(TIM3_TIxExternalCLKSource));
+   assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
+   assert_param(IS_TIM3_IC_FILTER(TIM3_ICFilter));
+ 
+   /* Configure the TIM3 Input Clock Source */
+   if (TIM3_TIxExternalCLKSource == TIM3_TIxExternalCLK1Source_TI2)
+   {
+     TI2_Config(TIM3_ICPolarity, TIM3_ICSelection_DirectTI, TIM3_ICFilter);
+   }
+   else
+   {
+     TI1_Config(TIM3_ICPolarity, TIM3_ICSelection_DirectTI, TIM3_ICFilter);
+   }
+ 
+   /* Select the Trigger source */
+   TIM3_SelectInputTrigger((TIM3_TRGSelection_TypeDef)TIM3_TIxExternalCLKSource);
+ 
+   /* Select the External clock mode1 */
+   TIM3->SMCR |= (uint8_t)(TIM3_SlaveMode_External1);
+ }
+ 
+ /**
+   * @brief  Selects the TIM3 Input Trigger source.
+   * @param  TIM3_InputTriggerSource: Specifies Input Trigger source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_TRGSelection_TIM4: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM3_TRGSelection_TIM1: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM3_TRGSelection_TIM3: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM3_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
+   *            @arg TIM3_TRGSelection_TI1F_ED: TRIG Input source = TI1F_ED (TI1 Edge Detector)
+   *            @arg TIM3_TRGSelection_TI1FP1: TRIG Input source = TI1FP1 (Filtered Timer Input 1)
+   *            @arg TIM3_TRGSelection_TI2FP2: TRIG Input source = TI2FP2 (Filtered Timer Input 2)
+   *            @arg TIM3_TRGSelection_ETRF: TRIG Input source =  ETRF (External Trigger Input )   
+   * @retval None
+   */
+ void TIM3_SelectInputTrigger(TIM3_TRGSelection_TypeDef TIM3_InputTriggerSource)
+ {
+   uint8_t tmpsmcr = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_TRIGGER_SELECTION(TIM3_InputTriggerSource));
+ 
+   tmpsmcr = TIM3->SMCR;
+ 
+   /* Select the Trigger Source */
+   tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
+   tmpsmcr |= (uint8_t)TIM3_InputTriggerSource;
+ 
+   TIM3->SMCR = (uint8_t)tmpsmcr;
+ }
+ 
+ /**
+   * @brief  Enables or Disables the TIM3 Update event.
+   * @param  NewState: The new state of the TIM3 peripheral Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_UpdateDisableConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the UDIS Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CR1 |= TIM_CR1_UDIS;
+   }
+   else
+   {
+     TIM3->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIM3 Update Request Interrupt source.
+   * @param  TIM3_UpdateSource: Specifies the Update source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_UpdateSource_Global: Global Update request source
+   *            @arg TIM3_UpdateSource_Regular: Regular Update request source 
+   * @retval None
+   */
+ void TIM3_UpdateRequestConfig(TIM3_UpdateSource_TypeDef TIM3_UpdateSource)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_UPDATE_SOURCE(TIM3_UpdateSource));
+ 
+   /* Set or Reset the URS Bit */
+   if (TIM3_UpdateSource == TIM3_UpdateSource_Regular)
+   {
+     TIM3->CR1 |= TIM_CR1_URS ;
+   }
+   else
+   {
+     TIM3->CR1 &= (uint8_t)(~TIM_CR1_URS);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or Disables the TIMs Hall sensor interface.
+   * @param  NewState: The new state of the TIM3 Hall sensor interface.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_SelectHallSensor(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the TI1S Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CR2 |= TIM_CR2_TI1S;
+   }
+   else
+   {
+     TIM3->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIMs One Pulse Mode.
+   * @param  TIM3_OPMode: Specifies the OPM Mode to be used.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OPMode_Single: Single one Pulse mode (OPM Active)
+   *            @arg TIM3_OPMode_Repetitive: Single one Pulse mode (OPM Active) 
+   * @retval None
+   */
+ void TIM3_SelectOnePulseMode(TIM3_OPMode_TypeDef TIM3_OPMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_OPM_MODE(TIM3_OPMode));
+ 
+   /* Set or Reset the OPM Bit */
+   if (TIM3_OPMode == TIM3_OPMode_Single)
+   {
+     TIM3->CR1 |= TIM_CR1_OPM ;
+   }
+   else
+   {
+     TIM3->CR1 &= (uint8_t)(~TIM_CR1_OPM);
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIM3 Trigger Output Mode.
+   * @param  TIM3_TRGOSource: Specifies the Trigger Output source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_TRGOSource_Reset: Trigger Output source = Reset 
+   *            @arg TIM3_TRGOSource_Enable: Trigger Output source = TIM3 is enabled 
+   *            @arg TIM3_TRGOSource_Update: Trigger Output source = Update event
+   *            @arg TIM3_TRGOSource_OC1: Trigger Output source = output compare channel1
+   *            @arg TIM3_TRGOSource_OC1REF: Trigger Output source = output compare channel 1 reference
+   *            @arg TIM3_TRGOSource_OC2REF: Trigger Output source = output compare channel 2 reference  
+   * @retval None
+   */
+ void TIM3_SelectOutputTrigger(TIM3_TRGOSource_TypeDef TIM3_TRGOSource)
+ {
+   uint8_t tmpcr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_TRGO_SOURCE(TIM3_TRGOSource));
+ 
+   tmpcr2 = TIM3->CR2;
+ 
+   /* Reset the MMS Bits */
+   tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
+ 
+   /* Select the TRGO source */
+   tmpcr2 |= (uint8_t)TIM3_TRGOSource;
+ 
+   TIM3->CR2 = tmpcr2;
+ }
+ 
+ /**
+   * @brief  Selects the TIM3 Slave Mode.
+   * @param  TIM3_SlaveMode: Specifies the TIM3 Slave Mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_SlaveMode_Reset: Slave Mode Selection  = Reset
+   *            @arg TIM3_SlaveMode_Gated: Slave Mode Selection  = Gated
+   *            @arg TIM3_SlaveMode_Trigger: Slave Mode Selection  = Trigger
+   *            @arg TIM3_SlaveMode_External1: Slave Mode Selection  = External 1  
+   * @retval None
+   */
+ void TIM3_SelectSlaveMode(TIM3_SlaveMode_TypeDef TIM3_SlaveMode)
+ {
+   uint8_t tmpsmcr = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_SLAVE_MODE(TIM3_SlaveMode));
+ 
+   tmpsmcr = TIM3->SMCR;
+ 
+   /* Reset the SMS Bits */
+   tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
+ 
+   /* Select the Slave Mode */
+   tmpsmcr |= (uint8_t)TIM3_SlaveMode;
+ 
+   TIM3->SMCR = tmpsmcr;
+ }
+ 
+ /**
+   * @brief  Sets or Resets the TIM3 Master/Slave Mode.
+   * @param  NewState: The new state of the synchronization between TIM3 and its slaves (through TRGO).
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_SelectMasterSlaveMode(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the MSM Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->SMCR |= TIM_SMCR_MSM;
+   }
+   else
+   {
+     TIM3->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 Encoder Interface.
+   * @param  TIM3_EncoderMode: Specifies the TIM3 Encoder Mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_EncoderMode_TI1: Encoder mode 1
+   *            @arg TIM3_EncoderMode_TI2: Encoder mode 2
+   *            @arg TIM3_EncoderMode_TI12: Encoder mode 3   
+   * @param  TIM3_IC1Polarity: Specifies the IC1 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM3_IC2Polarity: Specifies the IC2 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @retval None
+   */
+ void TIM3_EncoderInterfaceConfig(TIM3_EncoderMode_TypeDef TIM3_EncoderMode,
+                                  TIM3_ICPolarity_TypeDef TIM3_IC1Polarity,
+                                  TIM3_ICPolarity_TypeDef TIM3_IC2Polarity)
+ {
+   uint8_t tmpsmcr = 0;
+   uint8_t tmpccmr1 = 0;
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_ENCODER_MODE(TIM3_EncoderMode));
+   assert_param(IS_TIM3_IC_POLARITY(TIM3_IC1Polarity));
+   assert_param(IS_TIM3_IC_POLARITY(TIM3_IC2Polarity));
+ 
+   tmpsmcr = TIM3->SMCR;
+   tmpccmr1 = TIM3->CCMR1;
+   tmpccmr2 = TIM3->CCMR2;
+ 
+   /* Set the encoder Mode */
+   tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
+   tmpsmcr |= (uint8_t)TIM3_EncoderMode;
+ 
+   /* Select the Capture Compare 1 and the Capture Compare 2 as input */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
+   tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
+   tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
+ 
+   /* Set the TI1 and the TI2 Polarities */
+   if (TIM3_IC1Polarity == TIM3_ICPolarity_Falling)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC1P ;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
+   }
+ 
+   if (TIM3_IC2Polarity == TIM3_ICPolarity_Falling)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC2P ;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
+   }
+ 
+   TIM3->SMCR = tmpsmcr;
+   TIM3->CCMR1 = tmpccmr1;
+   TIM3->CCMR2 = tmpccmr2;
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 Prescaler.
+   * @param  Prescaler: Specifies the Prescaler Register value
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            @arg TIM3_Prescaler_2: Time base Prescaler = 2
+   *            @arg TIM3_Prescaler_4: Time base Prescaler = 4
+   *            @arg TIM3_Prescaler_8: Time base Prescaler = 8
+   *            @arg TIM3_Prescaler_16: Time base Prescaler = 16
+   *            @arg TIM3_Prescaler_32: Time base Prescaler = 32
+   *            @arg TIM3_Prescaler_64: Time base Prescaler = 64
+   *            @arg TIM3_Prescaler_128: Time base Prescaler = 128  
+   * @param  TIM3_PSCReloadMode: Specifies the TIM3 Prescaler Reload mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_PSCReloadMode_Update: Prescaler value is reloaded at every update
+   *            @arg TIM3_PSCReloadMode_Immediate: Prescaler value is reloaded at every update 
+   * @retval None
+   */
+ void TIM3_PrescalerConfig(TIM3_Prescaler_TypeDef TIM3_Prescaler,
+                           TIM3_PSCReloadMode_TypeDef TIM3_PSCReloadMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_PRESCALER(TIM3_Prescaler));
+   assert_param(IS_TIM3_PRESCALER_RELOAD(TIM3_PSCReloadMode));
+ 
+   /* Set the Prescaler value */
+   TIM3->PSCR = (uint8_t)(TIM3_Prescaler);
+ 
+ 
+   /* Set or reset the UG Bit */
+   if (TIM3_PSCReloadMode == TIM3_PSCReloadMode_Immediate)
+   {
+     TIM3->EGR |= TIM_EGR_UG ;
+   }
+   else
+   {
+     TIM3->EGR &= (uint8_t)(~TIM_EGR_UG) ;
+   }
+ }
+ 
+ /**
+   * @brief  Specifies the TIM3 Counter Mode to be used.
+   * @param  TIM3_CounterMode: Specifies the Counter Mode to be used
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_CounterMode_Up: Counter Up Mode
+   *            @arg TIM3_CounterMode_Down: Counter Down Mode
+   *            @arg TIM3_CounterMode_CenterAligned1: Counter Central aligned Mode 1
+   *            @arg TIM3_CounterMode_CenterAligned2: Counter Central aligned Mode 2
+   *            @arg TIM3_CounterMode_CenterAligned3: Counter Central aligned Mode 3   
+   * @retval None
+   */
+ void TIM3_CounterModeConfig(TIM3_CounterMode_TypeDef TIM3_CounterMode)
+ {
+   uint8_t tmpcr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_COUNTER_MODE(TIM3_CounterMode));
+ 
+   tmpcr1 = TIM3->CR1;
+ 
+   /* Reset the CMS and DIR Bits */
+   tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
+ 
+   /* Set the Counter Mode */
+   tmpcr1 |= (uint8_t)TIM3_CounterMode;
+ 
+   TIM3->CR1 = tmpcr1;
+ }
+ 
+ /**
+   * @brief  Forces the TIM3 Channel1 output waveform to active or inactive level.
+   * @param  TIM3_ForcedAction: Specifies the forced Action to be set to the output waveform.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ForcedAction_Active: Output Reference is forced low 
+   *            @arg TIM3_ForcedAction_Inactive: Output Reference is forced high 
+   * @retval None
+   */
+ void TIM3_ForcedOC1Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction)
+ {
+   uint8_t tmpccmr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_FORCED_ACTION(TIM3_ForcedAction));
+ 
+   tmpccmr1 = TIM3->CCMR1;
+ 
+   /* Reset the OCM Bits */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Configure The Forced output Mode */
+   tmpccmr1 |= (uint8_t)TIM3_ForcedAction;
+ 
+   TIM3->CCMR1 = tmpccmr1;
+ }
+ 
+ /**
+   * @brief  Forces the TIM3 Channel2 output waveform to active or inactive level.
+   * @param  TIM3_ForcedAction: Specifies the forced Action to be set to the output waveform.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ForcedAction_Active: Output Reference is forced low 
+   *            @arg TIM3_ForcedAction_Inactive: Output Reference is forced high 
+   * @retval None
+   */
+ void TIM3_ForcedOC2Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction)
+ {
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_FORCED_ACTION(TIM3_ForcedAction));
+ 
+   tmpccmr2 = TIM3->CCMR2;
+ 
+   /* Reset the OCM Bits */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+   /* Configure The Forced output Mode */
+   tmpccmr2 |= (uint8_t)TIM3_ForcedAction;
+ 
+   TIM3->CCMR2 = tmpccmr2;
+ }
+ 
+ /**
+   * @brief  Enables or disables TIM3 peripheral Preload register on ARR.
+   * @param  NewState: The new state of the TIM3 peripheral Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_ARRPreloadConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the ARPE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CR1 |= TIM_CR1_ARPE;
+   }
+   else
+   {
+     TIM3->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR1.
+   * @param  NewState: The new state of the Capture Compare Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_OC1PreloadConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC1PE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CCMR1 |= TIM_CCMR_OCxPE ;
+   }
+   else
+   {
+     TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR2.
+   * @param  NewState: The new state of the Capture Compare Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_OC2PreloadConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC2PE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CCMR2 |= TIM_CCMR_OCxPE ;
+   }
+   else
+   {
+     TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 Capture Compare 1 Fast feature.
+   * @param  NewState: The new state of the Output Compare Fast Enable bit.
+   *          This parameter can be ENABLE or DISABLE.
+   * @retval None
+   */
+ void TIM3_OC1FastCmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC1FE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CCMR1 |= TIM_CCMR_OCxFE ;
+   }
+   else
+   {
+     TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 Capture Compare 2 Fast feature.
+   * @param  NewState: The new state of the Output Compare Fast Enable bit.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_OC2FastCmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the OC2FE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM3->CCMR2 |= TIM_CCMR_OCxFE ;
+   }
+   else
+   {
+     TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 event to be generated by software.
+   * @param  TIM3_EventSource: Specifies the event source.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM3_EventSource_Update: Update
+   *            @arg TIM3_EventSource_CC1: Capture Compare Channel1
+   *            @arg TIM3_EventSource_CC2: Capture Compare Channel2 
+   *            @arg TIM3_EventSource_Trigger: Trigger 
+   *            @arg TIM3_EventSource_Break: Break  
+   * @retval None
+   */
+ void TIM3_GenerateEvent(TIM3_EventSource_TypeDef TIM3_EventSource)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_EVENT_SOURCE((uint8_t)TIM3_EventSource));
+ 
+   /* Set the event sources */
+   TIM3->EGR |= (uint8_t)TIM3_EventSource;
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 Channel 1 polarity.
+   * @param  TIM3_OCPolarity: Specifies the OC1 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
+   * @retval None
+   */
+ void TIM3_OC1PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
+ 
+   /* Set or Reset the CC1P Bit */
+   if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC1P ;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM3 Channel 2 polarity.
+   * @param  TIM3_OCPolarity: Specifies the OC2 Polarity.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
+   *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
+   * @retval None
+   */
+ void TIM3_OC2PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
+ 
+   /* Set or Reset the CC2P Bit */
+   if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC2P ;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM3 Capture Compare Channel x.
+   * @param  TIM3_Channel: Specifies the TIM3 Channel.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_Channel_1: Channel 1
+   *            @arg TIM3_Channel_2: Channel 2  
+   * @param  NewState: Specifies the TIM3 Channel CCxE bit new state.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM3_CCxCmd(TIM3_Channel_TypeDef TIM3_Channel,
+                  FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (TIM3_Channel == TIM3_Channel_1)
+   {
+     /* Set or Reset the CC1E Bit */
+     if (NewState != DISABLE)
+     {
+       TIM3->CCER1 |= TIM_CCER1_CC1E ;
+     }
+     else
+     {
+       TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
+     }
+ 
+   }
+   else /* if (TIM3_Channel == TIM3_Channel_2) */
+   {
+     /* Set or Reset the CC2E Bit */
+     if (NewState != DISABLE)
+     {
+       TIM3->CCER1 |= TIM_CCER1_CC2E;
+     }
+     else
+     {
+       TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
+     }
+   }
+ 
+ }
+ 
+ /**
+   * @brief  Selects the TIM3 Output Compare Mode. This function disables the
+   *         selected channel before changing the Output Compare Mode. User has to
+   *         enable this channel using TIM3_CCxCmd and TIM3_CCxNCmd functions.
+   * @param  TIM3_Channel: Specifies the TIM3 Channel.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_Channel_1: Channel 1
+   *            @arg TIM3_Channel_2: Channel 2  
+   * @param  TIM3_OCMode: Specifies the TIM3 Output Compare Mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_OCMode_Timing: Timing (Frozen) Mode
+   *            @arg TIM3_OCMode_Active: Active Mode
+   *            @arg TIM3_OCMode_Inactive: Inactive Mode
+   *            @arg TIM3_OCMode_Toggle: Toggle Mode
+   *            @arg TIM3_OCMode_PWM1: PWM Mode 1
+   *            @arg TIM3_OCMode_PWM2: PWM Mode 2  
+   */
+ void TIM3_SelectOCxM(TIM3_Channel_TypeDef TIM3_Channel,
+                      TIM3_OCMode_TypeDef TIM3_OCMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
+   assert_param(IS_TIM3_OCM(TIM3_OCMode));
+ 
+   if (TIM3_Channel == TIM3_Channel_1)
+   {
+     /* Disable the Channel 1: Reset the CCE Bit */
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+ 
+     /* Reset the Output Compare Bits */
+     TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+     /* Set the Ouput Compare Mode */
+     TIM3->CCMR1 |= (uint8_t)TIM3_OCMode;
+   }
+   else /* if (TIM3_Channel == TIM3_Channel_2) */
+   {
+     /* Disable the Channel 2: Reset the CCE Bit */
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+ 
+     /* Reset the Output Compare Bits */
+     TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
+ 
+     /* Set the Ouput Compare Mode */
+     TIM3->CCMR2 |= (uint8_t)TIM3_OCMode;
+   }
+ }
+ 
+ /**
+   * @brief  Sets the TIM3 Counter Register value.
+   * @param  Counter: Specifies the Counter register new value.
+   *          This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM3_SetCounter(uint16_t TIM3_Counter)
+ {
+ 
+   /* Set the Counter Register value */
+   TIM3->CNTRH = (uint8_t)(TIM3_Counter >> 8);
+   TIM3->CNTRL = (uint8_t)(TIM3_Counter);
+ }
+ 
+ /**
+   * @brief  Sets the TIM3 Autoreload Register value.
+   * @param  Autoreload: Specifies the Autoreload register new value.
+   *          This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM3_SetAutoreload(uint16_t TIM3_Autoreload)
+ {
+   /* Set the Autoreload Register value */
+   TIM3->ARRH = (uint8_t)(TIM3_Autoreload >> 8);
+   TIM3->ARRL = (uint8_t)(TIM3_Autoreload);
+ }
+ 
+ /**
+   * @brief  Sets the TIM3 Capture Compare1 Register value.
+   * @param  Compare: Specifies the Capture Compare1 register new value.
+   *         This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM3_SetCompare1(uint16_t TIM3_Compare)
+ {
+   /* Set the Capture Compare1 Register value */
+   TIM3->CCR1H = (uint8_t)(TIM3_Compare >> 8);
+   TIM3->CCR1L = (uint8_t)(TIM3_Compare);
+ }
+ 
+ /**
+   * @brief  Sets the TIM3 Capture Compare2 Register value.
+   * @param  Compare: Specifies the Capture Compare2 register new value.
+   *         This parameter is between 0x0000 and 0xFFFF.
+   * @retval None
+   */
+ void TIM3_SetCompare2(uint16_t TIM3_Compare)
+ {
+   /* Set the Capture Compare2 Register value */
+   TIM3->CCR2H = (uint8_t)(TIM3_Compare >> 8);
+   TIM3->CCR2L = (uint8_t)(TIM3_Compare);
+ }
+ 
+ /**
+   * @brief  Sets the TIM3 Input Capture 1 prescaler.
+   * @param  TIM3_IC1Prescaler: Specifies the Input Capture prescaler new value
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
+   * @retval None
+   */
+ void TIM3_SetIC1Prescaler(TIM3_ICPSC_TypeDef TIM3_IC1Prescaler)
+ {
+   uint8_t tmpccmr1 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_IC_PRESCALER(TIM3_IC1Prescaler));
+ 
+   tmpccmr1 = TIM3->CCMR1;
+ 
+   /* Reset the IC1PSC Bits */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
+ 
+   /* Set the IC1PSC value */
+   tmpccmr1 |= (uint8_t)TIM3_IC1Prescaler;
+ 
+   TIM3->CCMR1 = tmpccmr1;
+ }
+ 
+ /**
+   * @brief  Sets the TIM3 Input Capture 2 prescaler.
+   * @param  TIM3_IC2Prescaler: Specifies the Input Capture prescaler new value
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
+   *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
+   *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
+   *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
+   * @retval None
+   */
+ void TIM3_SetIC2Prescaler(TIM3_ICPSC_TypeDef TIM3_IC2Prescaler)
+ {
+   uint8_t tmpccmr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_IC_PRESCALER(TIM3_IC2Prescaler));
+ 
+   tmpccmr2 = TIM3->CCMR2;
+ 
+   /* Reset the IC2PSC Bits */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
+ 
+   /* Set the IC2PSC value */
+   tmpccmr2 |= (uint8_t)TIM3_IC2Prescaler;
+ 
+   TIM3->CCMR2 = tmpccmr2;
+ }
+ 
+ /**
+   * @brief  Gets the TIM3 Input Capture 1 value.
+   * @param  None
+   * @retval Capture Compare 1 Register value.
+   */
+ uint16_t TIM3_GetCapture1(void)
+ {
+   uint16_t tmpccr1 = 0;
+   uint8_t tmpccr1l, tmpccr1h;
+ 
+   tmpccr1h = TIM3->CCR1H;
+   tmpccr1l = TIM3->CCR1L;
+ 
+   tmpccr1 = (uint16_t)(tmpccr1l);
+   tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
+   /* Get the Capture 1 Register value */
+   return ((uint16_t)tmpccr1);
+ }
+ 
+ /**
+   * @brief  Gets the TIM3 Input Capture 2 value.
+   * @param  None
+   * @retval Capture Compare 2 Register value.
+   */
+ uint16_t TIM3_GetCapture2(void)
+ {
+   uint16_t tmpccr2 = 0;
+   uint8_t tmpccr2l, tmpccr2h;
+ 
+   tmpccr2h = TIM3->CCR2H;
+   tmpccr2l = TIM3->CCR2L;
+ 
+   tmpccr2 = (uint16_t)(tmpccr2l);
+   tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
+   /* Get the Capture 2 Register value */
+   return ((uint16_t)tmpccr2);
+ }
+ 
+ /**
+   * @brief  Gets the TIM3 Counter value.
+   * @param  None
+   * @retval Counter Register value.
+   */
+ uint16_t TIM3_GetCounter(void)
+ {
+   uint16_t tmpcnt = 0;
+   uint8_t tmpcntrl, tmpcntrh;
+ 
+   tmpcntrh = TIM3->CNTRH;
+   tmpcntrl = TIM3->CNTRL;
+ 
+   tmpcnt = (uint16_t)(tmpcntrl);
+   tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
+   /* Get the Counter Register value */
+   return ((uint16_t)tmpcnt);
+ }
+ 
+ /**
+   * @brief  Gets the TIM3 Prescaler value.
+   * @param  None
+   * @retval TIM3 Prescaler, it can be one of the following values:
+   *            - TIM3_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            - TIM3_Prescaler_2: Time base Prescaler = 2
+   *            - TIM3_Prescaler_4: Time base Prescaler = 4
+   *            - TIM3_Prescaler_8: Time base Prescaler = 8
+   *            - TIM3_Prescaler_16: Time base Prescaler = 16
+   *            - TIM3_Prescaler_32: Time base Prescaler = 32
+   *            - TIM3_Prescaler_64: Time base Prescaler = 64
+   *            - TIM3_Prescaler_128: Time base Prescaler = 128   
+   */
+ TIM3_Prescaler_TypeDef TIM3_GetPrescaler(void)
+ {
+   /* Get the Prescaler Register value */
+   return ((TIM3_Prescaler_TypeDef)TIM3->PSCR);
+ }
+ 
+ /**
+   * @brief  Checks whether the specified TIM3 flag is set or not.
+   * @param  TIM3_FLAG: Specifies the flag to check.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM3_FLAG_Update: Update
+   *            @arg TIM3_FLAG_CC1: Capture Compare Channel1
+   *            @arg TIM3_FLAG_CC2: Capture Compare Channel2 
+   *            @arg TIM3_FLAG_Trigger: Trigger 
+   *            @arg TIM3_FLAG_Break: Break  
+   *            @arg TIM3_FLAG_CC1OF: Capture compare 1 over capture
+   *            @arg TIM3_FLAG_CC2OF: Capture compare 2 over capture   
+   * @retval FlagStatus: The new state of TIM3_FLAG (SET or RESET)
+   */
+ FlagStatus TIM3_GetFlagStatus(TIM3_FLAG_TypeDef TIM3_FLAG)
+ {
+   FlagStatus bitstatus = RESET;
+   uint8_t tim3_flag_l, tim3_flag_h;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_GET_FLAG(TIM3_FLAG));
+ 
+   tim3_flag_l = (uint8_t)(TIM3->SR1 & (uint8_t)(TIM3_FLAG));
+   tim3_flag_h = (uint8_t)(TIM3->SR2 & (uint8_t)((uint16_t)TIM3_FLAG >> 8));
+   
+   if ((uint8_t)(tim3_flag_l | tim3_flag_h) != 0)
+   {
+     bitstatus = SET;
+   }
+   else
+   {
+     bitstatus = RESET;
+   }
+   return ((FlagStatus)bitstatus);
+ }
+ 
+ /**
+   * @brief  Clears the TIMs pending flags.
+   * @param  TIM3_FLAG: Specifies the flag to clear.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM3_FLAG_Update: Update
+   *            @arg TIM3_FLAG_CC1: Capture Compare Channel1
+   *            @arg TIM3_FLAG_CC2: Capture Compare Channel2 
+   *            @arg TIM3_FLAG_Trigger: Trigger 
+   *            @arg TIM3_FLAG_Break: Break  
+   * @retval None
+   */
+ void TIM3_ClearFlag(TIM3_FLAG_TypeDef TIM3_FLAG)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_CLEAR_FLAG((uint16_t)TIM3_FLAG));
+   /* Clear the flags (rc_w0) clear this bit by writing 0. Writing 1 has no effect*/
+   TIM3->SR1 = (uint8_t)(~(uint8_t)(TIM3_FLAG));
+   TIM3->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM3_FLAG >> 8));
+ }
+ 
+ /**
+   * @brief  Checks whether the TIM3 interrupt has occurred or not.
+   * @param  TIM3_IT: Specifies the TIM3 interrupt source to check.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM3_IT_Update: Update
+   *            @arg TIM3_IT_CC1: Capture Compare Channel1
+   *            @arg TIM3_IT_CC2: Capture Compare Channel2 
+   *            @arg TIM3_IT_Trigger: Trigger 
+   *            @arg TIM3_IT_Break: Break  
+   * @retval ITStatus: The new state of the TIM3_IT (SET or RESET)
+   */
+ ITStatus TIM3_GetITStatus(TIM3_IT_TypeDef TIM3_IT)
+ {
+   __IO ITStatus bitstatus = RESET;
+ 
+   __IO uint8_t TIM3_itStatus = 0x0, TIM3_itEnable = 0x0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_GET_IT(TIM3_IT));
+ 
+   TIM3_itStatus = (uint8_t)(TIM3->SR1 & (uint8_t)TIM3_IT);
+ 
+   TIM3_itEnable = (uint8_t)(TIM3->IER & (uint8_t)TIM3_IT);
+ 
+   if ((TIM3_itStatus != (uint8_t)RESET) && (TIM3_itEnable != (uint8_t)RESET))
+   {
+     bitstatus = (ITStatus)SET;
+   }
+   else
+   {
+     bitstatus = (ITStatus)RESET;
+   }
+   return ((ITStatus)bitstatus);
+ }
+ 
+ /**
+   * @brief  Clears the TIM's interrupt pending bits.
+   * @param  TIM3_IT: Specifies the pending bit to clear.
+   *          This parameter can be any combination of the following values:
+   *            @arg TIM3_IT_Update: Update
+   *            @arg TIM3_IT_CC1: Capture Compare Channel1
+   *            @arg TIM3_IT_CC2: Capture Compare Channel2 
+   *            @arg TIM3_IT_Trigger: Trigger 
+   *            @arg TIM3_IT_Break: Break  
+   * @retval None
+   */
+ void TIM3_ClearITPendingBit(TIM3_IT_TypeDef TIM3_IT)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM3_IT(TIM3_IT));
+ 
+   /* Clear the IT pending Bit */
+   TIM3->SR1 = (uint8_t)(~(uint8_t)TIM3_IT);
+ }
+ 
+ /**
+   * @brief  Configure the TI1 as Input.
+   * @param  TIM3_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM3_ICSelection: Specifies the input to be used.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM3_ICFilter: Specifies the Input Capture Filter.
+   *          This parameter must be a value between 0x00 and 0x0F.
+   * @retval None
+   */
+ static void TI1_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                        TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                        uint8_t TIM3_ICFilter)
+ {
+   uint8_t tmpccmr1 = 0;
+   uint8_t tmpicpolarity = (uint8_t)TIM3_ICPolarity;
+   tmpccmr1 = TIM3->CCMR1;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
+   assert_param(IS_TIM3_IC_SELECTION(TIM3_ICSelection));
+   assert_param(IS_TIM3_IC_FILTER(TIM3_ICFilter));
+ 
+   /* Disable the Channel 1: Reset the CCE Bit */
+   TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+ 
+   /* Select the Input and set the filter */
+   tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
+   tmpccmr1 |= (uint8_t)(((uint8_t)(TIM3_ICSelection)) | ((uint8_t)(TIM3_ICFilter << 4)));
+ 
+   TIM3->CCMR1 = tmpccmr1;
+ 
+   /* Select the Polarity */
+   if (tmpicpolarity == (uint8_t)(TIM3_ICPolarity_Falling))
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC1P;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
+   }
+ 
+   /* Set the CCE Bit */
+   TIM3->CCER1 |=  TIM_CCER1_CC1E;
+ }
+ 
+ /**
+   * @brief  Configure the TI2 as Input.
+   * @param  TIM3_ICPolarity: Input Capture Polarity
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
+   *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
+   * @param  TIM3_ICSelection: Specifies the input to be used.
+   *          This parameter can be one of the following values:
+   *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
+   *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
+   *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
+   * @param  TIM3_ICFilter: Specifies the Input Capture Filter.
+   *          This parameter must be a value between 0x00 and 0x0F.
+   * @retval None
+   */
+ static void TI2_Config(TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
+                        TIM3_ICSelection_TypeDef TIM3_ICSelection,
+                        uint8_t TIM3_ICFilter)
+ {
+   uint8_t tmpccmr2 = 0;
+   uint8_t tmpicpolarity = (uint8_t)TIM3_ICPolarity;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
+   assert_param(IS_TIM3_IC_SELECTION(TIM3_ICSelection));
+   assert_param(IS_TIM3_IC_FILTER(TIM3_ICFilter));
+ 
+   tmpccmr2 = TIM3->CCMR2;
+ 
+   /* Disable the Channel 2: Reset the CCE Bit */
+   TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
+ 
+   /* Select the Input and set the filter */
+   tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
+   tmpccmr2 |= (uint8_t)(((uint8_t)(TIM3_ICSelection)) | ((uint8_t)(TIM3_ICFilter << 4)));
+ 
+   TIM3->CCMR2 = tmpccmr2;
+ 
+   /* Select the Polarity */
+   if (tmpicpolarity == (uint8_t)TIM3_ICPolarity_Falling)
+   {
+     TIM3->CCER1 |= TIM_CCER1_CC2P ;
+   }
+   else
+   {
+     TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
+   }
+ 
+   /* Set the CCE Bit */
+   TIM3->CCER1 |=  TIM_CCER1_CC2E;
+ }
+ 
+ /**
+   * @brief Checks whether the TIM3 device is enabled or not.
+   * @param None
+   * @retval FunctionalState The new state of the TIM3 device.
+   */
+ 
+ FunctionalState TIM3_GetStatus(void)
+ {
+   return ((FunctionalState)(TIM3->CR1 & TIM_CR1_CEN));
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim4.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim4.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim4.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_tim4.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,602 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_tim4.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the TIM4 peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_tim4.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ 
+ /** @defgroup TIM4
+   * @brief TIM4 driver modules
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ 
+ /**
+   * @addtogroup TIM4_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the TIM4 peripheral registers to their default reset values.
+   * @param  None
+   * @retval None
+   */
+ void TIM4_DeInit(void)
+ {
+   TIM4->CR1  = TIM4_CR1_RESET_VALUE;
+   TIM4->CR2  = TIM4_CR2_RESET_VALUE;
+   TIM4->SMCR  = TIM4_SMCR_RESET_VALUE;
+   TIM4->IER  = TIM4_IER_RESET_VALUE;
+   TIM4->CNTR  = TIM4_CNTR_RESET_VALUE;
+   TIM4->PSCR = TIM4_PSCR_RESET_VALUE;
+   TIM4->ARR  = TIM4_ARR_RESET_VALUE;
+   TIM4->SR1  = TIM4_SR1_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Initializes the TIM4 Time Base Unit according to the specified parameters.
+   * @param  TIM4_Prescaler: Prescaler
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            @arg TIM4_Prescaler_2: Time base Prescaler = 2
+   *            @arg TIM4_Prescaler_4: Time base Prescaler = 4
+   *            @arg TIM4_Prescaler_8: Time base Prescaler = 8
+   *            @arg TIM4_Prescaler_16: Time base Prescaler = 16
+   *            @arg TIM4_Prescaler_32: Time base Prescaler = 32
+   *            @arg TIM4_Prescaler_64: Time base Prescaler = 64
+   *            @arg TIM4_Prescaler_128: Time base Prescaler = 128
+   *            @arg TIM4_Prescaler_256: Time base Prescaler = 256
+   *            @arg TIM4_Prescaler_512: Time base Prescaler = 512
+   *            @arg TIM4_Prescaler_1024: Time base Prescaler = 1024
+   *            @arg TIM4_Prescaler_2048: Time base Prescaler = 2048
+   *            @arg TIM4_Prescaler_4096: Time base Prescaler = 4096
+   *            @arg TIM4_Prescaler_8192: Time base Prescaler = 8192
+   *            @arg TIM4_Prescaler_16384: Time base Prescaler = 16384
+   *            @arg TIM4_Prescaler_32768: Time base Prescaler = 32768                              
+   * @param  TIM4_Period: This parameter must be a value between 0x00 and 0xFF.
+   * @retval None
+   */
+ void TIM4_TimeBaseInit(TIM4_Prescaler_TypeDef TIM4_Prescaler,
+                        uint8_t TIM4_Period)
+ {
+   /* Check TIM4 prescaler value */
+   assert_param(IS_TIM4_PRESCALER(TIM4_Prescaler));
+   /* Set the Autoreload value */
+   TIM4->ARR = (uint8_t)(TIM4_Period);
+   /* Set the Prescaler value */
+   TIM4->PSCR = (uint8_t)(TIM4_Prescaler);
+ }
+ 
+ /**
+   * @brief  Enables or disables the TIM4 peripheral.
+   * @param  NewState: The new state of the TIM4 peripheral.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM4_Cmd(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* set or Reset the CEN Bit */
+   if (NewState != DISABLE)
+   {
+     TIM4->CR1 |= TIM4_CR1_CEN ;
+   }
+   else
+   {
+     TIM4->CR1 &= (uint8_t)(~TIM4_CR1_CEN) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables the specified TIM4 interrupts.
+   * @param  TIM4_IT: Specifies the TIM4 interrupts sources to be enabled or disabled.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_IT_Update: Update
+   *            @arg TIM4_IT_Trigger: Trigger
+   * @param  NewState: The new state of the TIM4 peripheral.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM4_ITConfig(TIM4_IT_TypeDef TIM4_IT, FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM4_IT(TIM4_IT));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the Interrupt sources */
+     TIM4->IER |= (uint8_t)TIM4_IT;
+   }
+   else
+   {
+     /* Disable the Interrupt sources */
+     TIM4->IER &= (uint8_t)(~(uint8_t)TIM4_IT);
+   }
+ }
+ 
+ /**
+   * @brief  Enables the TIM4 internal Clock.
+   * @param  None
+   * @retval None
+   */
+ void TIM4_InternalClockConfig(void)
+ {
+   /* Disable slave mode to clock the prescaler directly with the internal clock */
+   TIM4->SMCR &= (uint8_t)(~TIM4_SMCR_SMS);
+ }
+ 
+ /**
+   * @brief  Selects the TIM4 Input Trigger source.
+   * @param  TIM4_InputTriggerSource: Specifies Input Trigger source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_TRGSelection_TIM3: TRIG Input source =  TIM3 TRIG Output
+   *            @arg TIM4_TRGSelection_TIM2: TRIG Input source =  TIM2 TRIG Output
+   * @retval None
+   */
+ void TIM4_SelectInputTrigger(TIM4_TRGSelection_TypeDef TIM4_InputTriggerSource)
+ {
+   uint8_t tmpsmcr = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM4_TRIGGER_SELECTION(TIM4_InputTriggerSource));
+ 
+   tmpsmcr = TIM4->SMCR;
+ 
+   /* Select the Trigger Source */
+   tmpsmcr &= (uint8_t)(~TIM4_SMCR_TS);
+   tmpsmcr |= (uint8_t)TIM4_InputTriggerSource;
+ 
+   TIM4->SMCR = (uint8_t)tmpsmcr;
+ }
+ 
+ /**
+   * @brief  Enables or Disables the TIM4 Update event.
+   * @param  NewState: The new state of the TIM4 peripheral Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM4_UpdateDisableConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the UDIS Bit */
+   if (NewState != DISABLE)
+   {
+     TIM4->CR1 |= TIM4_CR1_UDIS ;
+   }
+   else
+   {
+     TIM4->CR1 &= (uint8_t)(~TIM4_CR1_UDIS) ;
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIM4 Update Request Interrupt source.
+   * @param  TIM4_UpdateSource: Specifies the Update source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_UpdateSource_Global: Global Update request source
+   *            @arg TIM4_UpdateSource_Regular: Regular Update request source
+   * @retval None
+   */
+ void TIM4_UpdateRequestConfig(TIM4_UpdateSource_TypeDef TIM4_UpdateSource)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM4_UPDATE_SOURCE(TIM4_UpdateSource));
+ 
+   /* Set or Reset the URS Bit */
+   if (TIM4_UpdateSource == TIM4_UpdateSource_Regular)
+   {
+     TIM4->CR1 |= TIM4_CR1_URS ;
+   }
+   else
+   {
+     TIM4->CR1 &= (uint8_t)(~TIM4_CR1_URS) ;
+   }
+ }
+ 
+ /**
+   * @brief  Selects the TIM4s One Pulse Mode.
+   * @param  TIM4_OPMode: Specifies the OPM Mode to be used.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_OPMode_Single: Single one Pulse mode (OPM Active)
+   *            @arg TIM4_OPMode_Repetitive: Repetitive Pulse mode (OPM inactive)
+   * @retval None
+   */
+ void TIM4_SelectOnePulseMode(TIM4_OPMode_TypeDef TIM4_OPMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM4_OPM_MODE(TIM4_OPMode));
+ 
+   /* Set or Reset the OPM Bit */
+   if (TIM4_OPMode == TIM4_OPMode_Single)
+   {
+     TIM4->CR1 |= TIM4_CR1_OPM ;
+   }
+   else
+   {
+     TIM4->CR1 &= (uint8_t)(~TIM4_CR1_OPM) ;
+   }
+ 
+ }
+ 
+ /**
+   * @brief  Selects the TIM4 Trigger Output Mode.
+   * @param  TIM4_TRGOSource: Specifies the Trigger Output source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_TRGOSource_Reset: Trigger Output source = Reset
+   *            @arg TIM4_TRGOSource_Enable: Trigger Output source = TIM4 is enabled
+   *            @arg TIM4_TRGOSource_Update: Trigger Output source = Update event
+   * @retval None
+   */
+ void TIM4_SelectOutputTrigger(TIM4_TRGOSource_TypeDef TIM4_TRGOSource)
+ {
+   uint8_t tmpcr2 = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM4_TRGO_SOURCE(TIM4_TRGOSource));
+ 
+   tmpcr2 = TIM4->CR2;
+ 
+   /* Reset the MMS Bits */
+   tmpcr2 &= (uint8_t)(~TIM4_CR2_MMS);
+ 
+   /* Select the TRGO source */
+   tmpcr2 |= (uint8_t)TIM4_TRGOSource;
+ 
+   TIM4->CR2 = tmpcr2;
+ }
+ 
+ /**
+   * @brief  Selects the TIM4 Slave Mode.
+   * @param  TIM4_SlaveMode: Specifies the TIM4 Slave Mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_SlaveMode_Disable: Disable slave mode to clock the prescaler
+                                             directly with the internal clock
+   *            @arg TIM4_SlaveMode_Reset: Slave Mode Selection  = Reset
+   *            @arg TIM4_SlaveMode_Gated: Slave Mode Selection  = Gated
+   *            @arg TIM4_SlaveMode_Trigger: Slave Mode Selection  = Trigger
+   *            @arg TIM4_SlaveMode_External1: Slave Mode Selection  = External 1  
+   * @retval None
+   */
+ void TIM4_SelectSlaveMode(TIM4_SlaveMode_TypeDef TIM4_SlaveMode)
+ {
+   uint8_t tmpsmcr = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM4_SLAVE_MODE(TIM4_SlaveMode));
+ 
+   tmpsmcr = TIM4->SMCR;
+ 
+   /* Reset the SMS Bits */
+   tmpsmcr &= (uint8_t)(~TIM4_SMCR_SMS);
+ 
+   /* Select the Slave Mode */
+   tmpsmcr |= (uint8_t)TIM4_SlaveMode;
+ 
+   TIM4->SMCR = tmpsmcr;
+ }
+ 
+ /**
+   * @brief  Sets or Resets the TIM4 Master/Slave Mode.
+   * @param NewState: The new state of the synchronization between TIM4 and its slaves (through TRGO).
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM4_SelectMasterSlaveMode(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the MSM Bit */
+   if (NewState != DISABLE)
+   {
+     TIM4->SMCR |= TIM4_SMCR_MSM;
+   }
+   else
+   {
+     TIM4->SMCR &= (uint8_t)(~TIM4_SMCR_MSM);
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM4 Prescaler.
+   * @param  Prescaler: Specifies the Prescaler Register value
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            @arg TIM4_Prescaler_2: Time base Prescaler = 2
+   *            @arg TIM4_Prescaler_4: Time base Prescaler = 4
+   *            @arg TIM4_Prescaler_8: Time base Prescaler = 8
+   *            @arg TIM4_Prescaler_16: Time base Prescaler = 16
+   *            @arg TIM4_Prescaler_32: Time base Prescaler = 32
+   *            @arg TIM4_Prescaler_64: Time base Prescaler = 64
+   *            @arg TIM4_Prescaler_128: Time base Prescaler = 128
+   *            @arg TIM4_Prescaler_256: Time base Prescaler = 256
+   *            @arg TIM4_Prescaler_512: Time base Prescaler = 512
+   *            @arg TIM4_Prescaler_1024: Time base Prescaler = 1024
+   *            @arg TIM4_Prescaler_2048: Time base Prescaler = 2048
+   *            @arg TIM4_Prescaler_4096: Time base Prescaler = 4096
+   *            @arg TIM4_Prescaler_8192: Time base Prescaler = 8192
+   *            @arg TIM4_Prescaler_16384: Time base Prescaler = 16384
+   *            @arg TIM4_Prescaler_32768: Time base Prescaler = 32768 
+   * @param  TIM4_PSCReloadMode: Specifies the TIM4 Prescaler Reload mode.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_PSCReloadMode_Update: Prescaler value is reloaded at every update
+   *            @arg TIM4_PSCReloadMode_Immediate: Prescaler value is reloaded immediately
+   * @retval None
+   */
+ void TIM4_PrescalerConfig(TIM4_Prescaler_TypeDef TIM4_Prescaler,
+                           TIM4_PSCReloadMode_TypeDef TIM4_PSCReloadMode)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM4_PRESCALER_RELOAD(TIM4_PSCReloadMode));
+   assert_param(IS_TIM4_PRESCALER(TIM4_Prescaler));
+ 
+   /* Set the Prescaler value */
+   TIM4->PSCR = (uint8_t)TIM4_Prescaler;
+ 
+   /* Set or reset the UG Bit */
+   if (TIM4_PSCReloadMode == TIM4_PSCReloadMode_Immediate)
+   {
+     TIM4->EGR |= TIM4_EGR_UG ;
+   }
+   else
+   {
+     TIM4->EGR &= (uint8_t)(~TIM4_EGR_UG) ;
+   }
+ }
+ 
+ /**
+   * @brief  Enables or disables TIM4 peripheral Preload register on ARR.
+   * @param  NewState: The new state of the TIM4 peripheral Preload register.
+   *          This parameter can be ENABLE or DISABLE
+   * @retval None
+   */
+ void TIM4_ARRPreloadConfig(FunctionalState NewState)
+ {
+   /* Check the parameters */
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Set or Reset the ARPE Bit */
+   if (NewState != DISABLE)
+   {
+     TIM4->CR1 |= TIM4_CR1_ARPE ;
+   }
+   else
+   {
+     TIM4->CR1 &= (uint8_t)(~TIM4_CR1_ARPE) ;
+   }
+ }
+ 
+ /**
+   * @brief  Configures the TIM4 event to be generated by software.
+   * @param  TIM4_EventSource: Specifies the event source.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_EventSource_Update: Update
+   *            @arg TIM4_EventSource_Trigger: Trigger
+   * @retval None
+   */
+ void TIM4_GenerateEvent(TIM4_EventSource_TypeDef TIM4_EventSource)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM4_EVENT_SOURCE((uint8_t)TIM4_EventSource));
+ 
+   /* Set the event sources */
+   TIM4->EGR |= (uint8_t)TIM4_EventSource;
+ }
+ 
+ /**
+   * @brief  Sets the TIM4 Counter Register value.
+   * @param  Counter: Specifies the Counter register new value.
+   *          This parameter is between 0x00 and 0xFF.
+   * @retval None
+   */
+ void TIM4_SetCounter(uint8_t TIM4_Counter)
+ {
+   /* Set the Counter Register value */
+   TIM4->CNTR = (uint8_t)(TIM4_Counter);
+ }
+ 
+ /**
+   * @brief  Sets the TIM4 Autoreload Register value.
+   * @param  Autoreload: Specifies the Autoreload register new value.
+   *          This parameter is between 0x00 and 0xFF.
+   * @retval None
+   */
+ void TIM4_SetAutoreload(uint8_t TIM4_Autoreload)
+ {
+ 
+   /* Set the Autoreload Register value */
+   TIM4->ARR = (uint8_t)(TIM4_Autoreload);
+ }
+ 
+ /**
+   * @brief  Gets the TIM4 Counter value.
+   * @param  None
+   * @retval Counter Register value.
+   */
+ uint8_t TIM4_GetCounter(void)
+ {
+   uint8_t tmpcntr = 0;
+   tmpcntr = TIM4->CNTR;
+   /* Get the Counter Register value */
+   return ((uint8_t)tmpcntr);
+ }
+ 
+ /**
+   * @brief  Gets the TIM4 Prescaler value.
+   * @param  None
+   * @retval TIM4 Prescaler can be one of the following values:
+   *            - TIM4_Prescaler_1: Time base Prescaler = 1 (No effect)
+   *            - TIM4_Prescaler_2: Time base Prescaler = 2
+   *            - TIM4_Prescaler_4: Time base Prescaler = 4
+   *            - TIM4_Prescaler_8: Time base Prescaler = 8
+   *            - TIM4_Prescaler_16: Time base Prescaler = 16
+   *            - TIM4_Prescaler_32: Time base Prescaler = 32
+   *            - TIM4_Prescaler_64: Time base Prescaler = 64
+   *            - TIM4_Prescaler_128: Time base Prescaler = 128
+   *            - TIM4_Prescaler_256: Time base Prescaler = 256
+   *            - TIM4_Prescaler_512: Time base Prescaler = 512
+   *            - TIM4_Prescaler_1024: Time base Prescaler = 1024
+   *            - TIM4_Prescaler_2048: Time base Prescaler = 2048
+   *            - TIM4_Prescaler_4096: Time base Prescaler = 4096
+   *            - TIM4_Prescaler_8192: Time base Prescaler = 8192
+   *            - TIM4_Prescaler_16384: Time base Prescaler = 16384
+   *            - TIM4_Prescaler_32768: Time base Prescaler = 32768  
+   */
+ TIM4_Prescaler_TypeDef TIM4_GetPrescaler(void)
+ {
+   /* Get the Prescaler Register value */
+   return ((TIM4_Prescaler_TypeDef)TIM4->PSCR);
+ }
+ 
+ /**
+   * @brief  Checks whether the TIM4 device is enabled or not.
+   * @param  None
+   * @retval FunctionalState The new state of the TIM4 device.
+   */
+ FunctionalState TIM4_GetStatus(void)
+ {
+   return ((FunctionalState)(TIM4->CR1 & TIM4_CR1_CEN));
+ }
+ 
+ /**
+   * @brief  Checks whether the specified TIM4 flag is set or not.
+   * @param  TIM4_FLAG: Specifies the flag to check.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_FLAG_Update: Update
+   *            @arg TIM4_FLAG_Trigger: Trigger
+   * @retval FlagStatus: The new state of TIM4_FLAG.
+   *          This parameter can be SET or RESET.
+   */
+ FlagStatus TIM4_GetFlagStatus(TIM4_FLAG_TypeDef TIM4_FLAG)
+ {
+   __IO FlagStatus bitstatus = RESET;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM4_GET_FLAG(TIM4_FLAG));
+ 
+   if ((TIM4->SR1 & (uint8_t)TIM4_FLAG)  != 0)
+   {
+     bitstatus = SET;
+   }
+   else
+   {
+     bitstatus = RESET;
+   }
+   return ((FlagStatus)bitstatus);
+ }
+ 
+ /**
+   * @brief  Clears the TIMs pending flags.
+   * @param  TIM4_FLAG: Specifies the flag to clear.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_FLAG_Update: Update
+   *            @arg TIM4_FLAG_Trigger: Trigger
+   * @retval None
+   */
+ void TIM4_ClearFlag(TIM4_FLAG_TypeDef TIM4_FLAG)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM4_CLEAR_FLAG((uint8_t)TIM4_FLAG));
+   /* Clear the flags (rc_w0) clear this bit by writing 0. Writing 1 has no effect*/
+   TIM4->SR1 = (uint8_t)(~((uint8_t)TIM4_FLAG));
+ }
+ 
+ /**
+   * @brief  Checks whether the TIM4 interrupt has occurred or not.
+   * @param  TIM4_IT: Specifies the TIM4 interrupt source to check.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_IT_Update: Update
+   *            @arg TIM4_IT_Trigger: Trigger
+   * @retval ITStatus: The new state of the TIM4_IT.
+   *          This parameter can be SET or RESET
+   */
+ ITStatus TIM4_GetITStatus(TIM4_IT_TypeDef TIM4_IT)
+ {
+   __IO ITStatus bitstatus = RESET;
+ 
+   __IO uint8_t itStatus = 0x0, itEnable = 0x0;
+ 
+   /* Check the parameters */
+   assert_param(IS_TIM4_GET_IT(TIM4_IT));
+ 
+   itStatus = (uint8_t)(TIM4->SR1 & (uint8_t)TIM4_IT);
+ 
+   itEnable = (uint8_t)(TIM4->IER & (uint8_t)TIM4_IT);
+ 
+   if ((itStatus != (uint8_t)RESET) && (itEnable != (uint8_t)RESET))
+   {
+     bitstatus = (ITStatus)SET;
+   }
+   else
+   {
+     bitstatus = (ITStatus)RESET;
+   }
+   return ((ITStatus)bitstatus);
+ }
+ 
+ /**
+   * @brief  Clears the TIM4's interrupt pending bits.
+   * @param  TIM4_IT: Specifies the pending bit to clear.
+   *          This parameter can be one of the following values:
+   *            @arg TIM4_IT_Update: Update
+   *            @arg TIM4_IT_Trigger: Trigger
+   * @retval None
+   */
+ void TIM4_ClearITPendingBit(TIM4_IT_TypeDef TIM4_IT)
+ {
+   /* Check the parameters */
+   assert_param(IS_TIM4_IT(TIM4_IT));
+ 
+   /* Clear the IT pending Bit */
+   TIM4->SR1 = (uint8_t)(~(uint8_t)TIM4_IT);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_usart.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_usart.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_usart.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_usart.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,563 ----
+ /**
+   ********************************************************************************
+   * @file    stm8l10x_usart.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the USART peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_clk.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ 
+ /** @defgroup USART
+   * @brief USART driver modules
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /**
+   * @addtogroup USART_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the USART peripheral.
+   * @param  None
+   * @retval None
+   */
+ void USART_DeInit(void)
+ {
+   /* Clear the Idle Line Detected bit in the status rerister by a read
+      to the USART_SR register followed by a Read to the USART_DR register */
+   (void)USART->SR;
+   (void)USART->DR;
+ 
+   USART->BRR2 = USART_BRR2_RESET_VALUE;  /* Set USART_BRR2 to reset value 0x00 */
+   USART->BRR1 = USART_BRR1_RESET_VALUE;  /* Set USART_BRR1 to reset value 0x00 */
+ 
+   USART->CR1 = USART_CR1_RESET_VALUE;  /* Set USART_CR1 to reset value 0x00 */
+   USART->CR2 = USART_CR2_RESET_VALUE;  /* Set USART_CR2 to reset value 0x00 */
+   USART->CR3 = USART_CR3_RESET_VALUE;  /* Set USART_CR3 to reset value 0x00 */
+   USART->CR4 = USART_CR4_RESET_VALUE;  /* Set USART_CR4 to reset value 0x00 */
+ }
+ 
+ /**
+   * @brief  Initializes the USART according to the specified parameters.
+   * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
+   *         correct I/O Port register according the product package and line
+   *         configuration
+   * @param  USART_WordLength: the word length
+   *           This parameter can be one of the following values:
+   *            @arg USART_WordLength_8D: 8 bits Data
+   *            @arg USART_WordLength_9D: 9 bits Data  
+   * @param  USART_StopBits: Stop Bit
+   *           This parameter can be one of the following values:
+   *            @arg USART_StopBits_1: One stop bit is transmitted at the end of frame
+   *            @arg USART_StopBits_2: Two stop bits are transmitted at the end of frame
+   * @param  USART_Parity: Parity
+   *           This parameter can be one of the following values:
+   *            @arg USART_Parity_No: No Parity
+   *            @arg USART_Parity_Even: Even Parity
+   *            @arg USART_Parity_Odd: Odd Parity   
+   * @param  BaudRate         The baudrate.
+   * @param  USART_Mode: Mode
+   *           This parameter can be one of the following values:
+   *            @arg USART_Mode_Rx: Receive Enable
+   *            @arg USART_Mode_Tx: Transmit Enable 
+   * @retval None
+   */
+ void USART_Init(uint32_t BaudRate, USART_WordLength_TypeDef USART_WordLength,
+                 USART_StopBits_TypeDef USART_StopBits, USART_Parity_TypeDef
+                 USART_Parity, USART_Mode_TypeDef USART_Mode)
+ {
+   uint32_t BaudRate_Mantissa = 0;
+ 
+   /* Check the parameters */
+   assert_param(IS_USART_BAUDRATE(BaudRate));
+ 
+   assert_param(IS_USART_WordLength(USART_WordLength));
+ 
+   assert_param(IS_USART_STOPBITS(USART_StopBits));
+ 
+   assert_param(IS_USART_PARITY(USART_Parity));
+ 
+   assert_param(IS_USART_MODE(USART_Mode));
+ 
+   /* Clear the word length and Parity Control bits */
+   USART->CR1 &= (uint8_t)(~(USART_CR1_PCEN | USART_CR1_PS | USART_CR1_M));
+   /* Set the word length bit according to USART_WordLength value */
+   /* Set the Parity Control bit to USART_Parity value */
+   USART->CR1 |= (uint8_t)((uint8_t)USART_WordLength | (uint8_t)USART_Parity);
+ 
+   /* Clear the STOP bits */
+   USART->CR3 &= (uint8_t)(~USART_CR3_STOP);
+   /* Set the STOP bits number according to USART_StopBits value */
+   USART->CR3 |= (uint8_t)USART_StopBits;
+ 
+   /* Clear the LSB mantissa of USARTDIV */
+   USART->BRR1 &= (uint8_t)(~USART_BRR1_DIVM);
+   /* Clear the MSB mantissa of USARTDIV */
+   USART->BRR2 &= (uint8_t)(~USART_BRR2_DIVM);
+   /* Clear the Fraction bits of USARTDIV */
+   USART->BRR2 &= (uint8_t)(~USART_BRR2_DIVF);
+ 
+   BaudRate_Mantissa  = ((uint32_t)CLK_GetClockFreq() / BaudRate);
+   /* Set the fraction of USARTDIV */
+   USART->BRR2 = (uint8_t)((BaudRate_Mantissa >> (uint8_t)8) & (uint8_t)0xF0);
+   /* Set the MSB mantissa of USARTDIV */
+   USART->BRR2 |= (uint8_t)(BaudRate_Mantissa & (uint8_t)0x0F);
+   /* Set the LSB mantissa of USARTDIV */
+   USART->BRR1 = (uint8_t)(BaudRate_Mantissa >> (uint8_t)4);
+ 
+   /* Disable the Transmitter and Receiver */
+   USART->CR2 &= (uint8_t)~(USART_CR2_TEN | USART_CR2_REN);
+   /* Set TEN and REN bits according to USART_Mode value */
+   USART->CR2 |= (uint8_t)USART_Mode;
+ }
+ 
+ /**
+   * @brief Initializes the USART Clock according to the specified parameters.
+   * @param  USART_Clock: Clock
+   *           This parameter can be one of the following values:
+   *            @arg USART_Clock_Disable: CK pin disabled
+   *            @arg USART_Clock_Enable: CK pin enabled  
+   * @param  USART_CPOL: Clock Polarity
+   *           This parameter can be one of the following values:
+   *            @arg USART_CPOL_Low: CK to 0 when idle
+   *            @arg USART_CPOL_High: CK to 1 when idle
+   * @param  USART_CPHA: Clock Phase
+   *           This parameter can be one of the following values:
+   *            @arg USART_CPHA_1Edge: The first clock transition is the first data capture edge
+   *            @arg USART_CPHA_2Edge: The second clock transition is the first data capture edge
+   * @param  USART_LastBit: Last Bit
+   *           This parameter can be one of the following values:
+   *            @arg USART_LastBit_Disable: The clock pulse of the last data bit is 
+   *               not output to the SCLK pin
+   *            @arg USART_LastBit_Enable: The clock pulse of the last data bit is 
+   *               output to the SCLK pin
+   * @retval None
+   */
+ void USART_ClockInit(USART_Clock_TypeDef USART_Clock, USART_CPOL_TypeDef USART_CPOL,
+                      USART_CPHA_TypeDef USART_CPHA, USART_LastBit_TypeDef USART_LastBit)
+ {
+   /* Check the parameters */
+   assert_param(IS_USART_CLOCK(USART_Clock));
+   assert_param(IS_USART_CPOL(USART_CPOL));
+   assert_param(IS_USART_CPHA(USART_CPHA));
+   assert_param(IS_USART_LASTBIT(USART_LastBit));
+ 
+   /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
+   USART->CR3 &= (uint8_t)~(USART_CR3_CPOL | USART_CR3_CPHA | USART_CR3_LBCL);
+   /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
+   USART->CR3 |= (uint8_t)((uint8_t)USART_CPOL | (uint8_t)USART_CPHA | (uint8_t)USART_LastBit);
+ 
+   if (USART_Clock != USART_Clock_Disable)
+   {
+     USART->CR3 |= (uint8_t)(USART_CR3_CLKEN); /* Set the Clock Enable bit */
+   }
+   else
+   {
+     USART->CR3 &= (uint8_t)(~USART_CR3_CLKEN); /* Clear the Clock Enable bit */
+   }
+ }
+ 
+ /**
+   * @brief  Enable the USART peripheral.
+   * @param  NewState: The new state of the USART Communication.
+     *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void USART_Cmd(FunctionalState NewState)
+ {
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     USART->CR1 &= (uint8_t)(~USART_CR1_USARTD); /**< USART Enable */
+   }
+   else
+   {
+     USART->CR1 |= USART_CR1_USARTD;  /**< USART Disable */
+   }
+ }
+ 
+ /**
+   * @brief Enables or disables the specified USART interrupts.
+   * @param  USART_IT specifies the USART interrupt sources to be enabled or disabled.
+   *         This parameter can be one of the following values:
+   *            @arg USART_IT_TXE: Transmit Data Register empty interrupt
+   *            @arg USART_IT_TC: Transmission complete interrupt
+   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
+   *            @arg USART_IT_OR: Overrun error interrupt
+   *            @arg USART_IT_IDLE: Idle line detection interrupt
+   *            @arg USART_IT_ERR: Error interrupt
+   * @param  NewState new state of the specified USART interrupts.
+     *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void USART_ITConfig(USART_IT_TypeDef USART_IT, FunctionalState NewState)
+ {
+   uint8_t uartreg, itpos = 0x00;
+   assert_param(IS_USART_CONFIG_IT(USART_IT));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* Get the USART register index */
+   uartreg = (uint8_t)((uint16_t)USART_IT >> (uint8_t)0x08);
+   /* Get the USART IT index */
+   itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)USART_IT & (uint8_t)0x0F));
+ 
+   if (NewState != DISABLE)
+   {
+     /**< Enable the Interrupt bits according to USART_IT mask */
+     if (uartreg == 0x01)
+     {
+       USART->CR1 |= itpos;
+     }
+     /*uartreg =0x02*/
+     else
+     {
+       USART->CR2 |= itpos;
+     }
+   }
+   else
+   {
+     /**< Disable the interrupt bits according to USART_IT mask */
+     if (uartreg == 0x01)
+     {
+       USART->CR1 &= (uint8_t)(~itpos);
+     }
+     /*uartreg =0x02*/
+     else
+     {
+       USART->CR2 &= (uint8_t)(~itpos);
+     }
+   }
+ 
+ }
+ 
+ /**
+   * @brief Returns the most recent received data by the USART peripheral.
+   * @note The function USART_Cmd(ENABLE) must be called first.
+   * @param None
+   * @retval The received data.
+   */
+ uint8_t USART_ReceiveData8(void)
+ {
+   return USART->DR;
+ }
+ 
+ 
+ /**
+   * @brief  Returns the most recent received data by the USART peripheral.
+   * @note   The function USART_Cmd(ENABLE) must be called first.
+   * @param  None
+   * @retval The received data.
+   */
+ uint16_t USART_ReceiveData9(void)
+ {
+   uint16_t temp = 0;
+   
+   temp = ((uint16_t)(((uint16_t)((uint16_t)USART->CR1 & (uint16_t)USART_CR1_R8)) << 1));
+   return (uint16_t)( ((uint16_t)((uint16_t)USART->DR) | temp) & ((uint16_t)0x01FF));
+ }
+ 
+ /**
+   * @brief  Determines if the USART is in mute mode or not.
+   * @param  NewState: The new state of the USART mode.
+     *         This parameter can be: ENABLE or DISABLE.
+   * @retval None
+   */
+ void USART_ReceiverWakeUpCmd(FunctionalState NewState)
+ {
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   if (NewState != DISABLE)
+   {
+     /* Enable the mute mode USART by setting the RWU bit in the CR2 register */
+     USART->CR2 |= USART_CR2_RWU;
+   }
+   else
+   {
+     /* Disable the mute mode USART by clearing the RWU bit in the CR1 register */
+     USART->CR2 &= ((uint8_t)~USART_CR2_RWU);
+   }
+ }
+ 
+ /**
+   * @brief  Transmits break characters.
+   * @param  None
+   * @retval None
+   */
+ void USART_SendBreak(void)
+ {
+   USART->CR2 |= USART_CR2_SBK;
+ }
+ 
+ /**
+   * @brief  Transmits 8 bit data through the USART peripheral.
+   * @param  Data The data to transmit.
+   * @retval None
+   */
+ void USART_SendData8(uint8_t Data)
+ {
+   /* Transmit Data */
+   USART->DR = Data;
+ }
+ 
+ /**
+   * @brief  Transmits 9 bit data through the USART peripheral.
+   * @note   The parameter (Data) must be lower than 0x1FF.
+   * @param  Data The data to transmit.
+   * @retval None
+   */
+ void USART_SendData9(uint16_t Data)
+ {
+   assert_param(IS_USART_DATA_9BITS(Data));
+ 
+   USART->CR1 &= ((uint8_t)~USART_CR1_T8);                    /* Clear the transmit data bit 8     */
+   USART->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & USART_CR1_T8); /* Write the transmit data bit [8]   */
+   USART->DR   = (uint8_t)(Data);                             /* Write the transmit data bit [0:7] */
+ 
+ }
+ 
+ /**
+   * @brief  Sets the address of the USART node.
+   * @note   The parameter (Address) must be lower than 16
+   * @param  Address Indicates the address of the USART node.
+   * @retval None
+   */
+ void USART_SetAddress(uint8_t Address)
+ {
+   /* assert_param for USART_Address */
+   assert_param(IS_USART_ADDRESS(Address));
+ 
+   /* Clear the USART address */
+   USART->CR4 &= ((uint8_t)~USART_CR4_ADD);
+   /* Set the USART address node */
+   USART->CR4 |= Address;
+ }
+ 
+ /**
+   * @brief  Selects the USART WakeUp method.
+   * @param  USART_WakeUp: Specifies the USART wakeup method.
+   *           This parameter can be one of the following values:
+   *            @arg USART_WakeUp_IdleLine: 0x01 Idle Line wake up
+   *            @arg USART_WakeUp_AddressMark: 0x02 Address Mark wake up   
+   * @retval None
+   */
+ void USART_WakeUpConfig(USART_WakeUp_TypeDef USART_WakeUp)
+ {
+   assert_param(IS_USART_WAKEUP(USART_WakeUp));
+ 
+   USART->CR1 &= ((uint8_t)~USART_CR1_WAKE);
+   USART->CR1 |= (uint8_t)USART_WakeUp;
+ }
+ 
+ /**
+   * @brief Checks whether the specified USART flag is set or not.
+   * @param  USART_FLAG specifies the flag to check.
+   *         This parameter can be one of the following values:
+   *            @arg USART_FLAG_TXE: Transmit Data Register empty
+   *            @arg USART_FLAG_TC: Transmission Complete 
+   *            @arg USART_FLAG_RXNE: Read Data Register Not Empty
+   *            @arg USART_FLAG_IDLE: Idle line detected
+   *            @arg USART_FLAG_OR: OverRun error
+   *            @arg USART_FLAG_PE: Parity Error
+   *            @arg USART_FLAG_SBK: Send Break characters   
+   * @retval FlagStatus Status of the flag
+   */
+ FlagStatus USART_GetFlagStatus(USART_FLAG_TypeDef USART_FLAG)
+ {
+   FlagStatus status = RESET;
+ 
+   /* Check parameters */
+   assert_param(IS_USART_FLAG(USART_FLAG));
+ 
+   if (USART_FLAG == USART_FLAG_SBK)
+   {
+     if ((USART->CR2 & (uint8_t)USART_FLAG) != (uint8_t)0x00)
+     {
+       /* USART_FLAG is set*/
+       status = SET;
+     }
+     else
+     {
+       /* USART_FLAG is reset*/
+       status = RESET;
+     }
+   }
+   else
+   {
+     if ((USART->SR & (uint8_t)USART_FLAG) != (uint8_t)0x00)
+     {
+       /* USART_FLAG is set*/
+       status = SET;
+     }
+     else
+     {
+       /* USART_FLAG is reset*/
+       status = RESET;
+     }
+   }
+   /* Return the USART_FLAG status*/
+   return status;
+ }
+ 
+ /**
+   * @brief Clears the USART RXNE (read data register not empty) flag.
+   * @param None
+   * @note  PE (Parity error), FE (Framing error), NE (Noise error), OR (OverRun error)
+   *        and IDLE (Idle line detected) flags are cleared by software sequence: a read
+   *        operation to USART_SR register (USART_GetFlagStatus())followed by a read operation
+   *        to USART_DR register(USART_ReceiveData8() or USART_ReceiveData9()).
+   * @note  RXNE flag can be also cleared by a read to the USART_DR register
+   *        (USART_ReceiveData8()or USART_ReceiveData9()).
+   * @note  TC flag can be also cleared by software sequence: a read operation to USART_SR
+   *        register (USART_GetFlagStatus()) followed by a write operation to USART_DR register
+   *        (USART_SendData8() or USART_SendData9()).
+   * @note  TXE flag is cleared only by a write to the USART_DR register (USART_SendData8() or
+   *        USART_SendData9()).
+   * @note  SBK flag is cleared during the stop bit of break.
+   * @retval None
+   */
+ void USART_ClearFlag(void)
+ {
+   /*< Clear the Receive Register Not Empty flag */
+   USART->SR = (uint8_t)~(USART_SR_RXNE);
+ }
+ 
+ /**
+   * @brief Checks whether the specified USART interrupt has occurred or not.
+   * @param  USART_IT: Specifies the USART interrupt pending bit to check.
+   *         This parameter can be one of the following values:
+   *            @arg USART_IT_TXE: Transmit Data Register empty interrupt
+   *            @arg USART_IT_TC: Transmission complete interrupt
+   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
+   *            @arg USART_IT_IDLE: Idle line detection interrupt
+   *            @arg USART_IT_OR: OverRun Error interrupt
+   *            @arg USART_IT_PE: Parity Error interrupt
+   * @retval ITStatus The interruption status
+   */
+ ITStatus USART_GetITStatus(USART_IT_TypeDef USART_IT)
+ {
+   ITStatus pendingbitstatus = RESET;
+   uint8_t itpos = 0;
+   uint8_t itmask1 = 0;
+   uint8_t itmask2 = 0;
+   uint8_t enablestatus = 0;
+ 
+   /* Check parameters */
+   assert_param(IS_USART_GET_IT(USART_IT));
+ 
+   /* Get the USART IT index */
+   itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)USART_IT & (uint8_t)0x0F));
+   /* Get the USART IT index */
+   itmask1 = (uint8_t)((uint8_t)USART_IT >> (uint8_t)4);
+   /* Set the IT mask*/
+   itmask2 = (uint8_t)((uint8_t)1 << itmask1);
+ 
+ 
+   /* Check the status of the specified USART pending bit*/
+   if (USART_IT == USART_IT_PE)
+   {
+     /* Get the USART_IT enable bit status*/
+     enablestatus = (uint8_t)((uint8_t)USART->CR1 & itmask2);
+     /* Check the status of the specified USART interrupt*/
+ 
+     if (((USART->SR & itpos) != (uint8_t)0x00) && enablestatus)
+     {
+       /* Interrupt occurred*/
+       pendingbitstatus = SET;
+     }
+     else
+     {
+       /* Interrupt not occurred*/
+       pendingbitstatus = RESET;
+     }
+   }
+   else
+   {
+     /* Get the USART_IT enable bit status*/
+     enablestatus = (uint8_t)((uint8_t)USART->CR2 & itmask2);
+     /* Check the status of the specified USART interrupt*/
+     if (((USART->SR & itpos) != (uint8_t)0x00) && enablestatus)
+     {
+       /* Interrupt occurred*/
+       pendingbitstatus = SET;
+     }
+     else
+     {
+       /* Interrupt not occurred*/
+       pendingbitstatus = RESET;
+     }
+   }
+ 
+   /* Return the USART_IT status*/
+   return  pendingbitstatus;
+ }
+ 
+ /**
+   * @brief Clears the USART RXNE (read data register not empty) pending bit.
+   * @param None
+   * @note  PE (Parity error), FE (Framing error), NE (Noise error), OR (OverRun error)
+   *        and IDLE (Idle line detected) flags are cleared by software sequence: a read
+   *        operation to USART_SR register (USART_GetFlagStatus())followed by a read operation
+   *        to USART_DR register(USART_ReceiveData8() or USART_ReceiveData9()).
+   * @note  RXNE flag can be also cleared by a read to the USART_DR register
+   *        (USART_ReceiveData8()or USART_ReceiveData9()).
+   * @note  TC flag can be also cleared by software sequence: a read operation to USART_SR
+   *        register (USART_GetFlagStatus()) followed by a write operation to USART_DR register
+   *        (USART_SendData8() or USART_SendData9()).
+   * @note  TXE flag is cleared only by a write to the USART_DR register (USART_SendData8() or
+   *        USART_SendData9()).  
+   * @retval None
+   */
+ void USART_ClearITPendingBit(void)
+ {
+   /*< Clear the Receive Register Not Empty pending bit */
+   USART->SR = (uint8_t)~(USART_SR_RXNE);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_wfe.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_wfe.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_wfe.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Libraries/STM8L10x_StdPeriph_Driver/src/stm8l10x_wfe.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,204 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_wfe.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions for the WFE peripheral.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_wfe.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Driver
+   * @{
+   */
+ 
+ /** @defgroup WFE
+   * @brief WFE driver modules
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ 
+ /** @addtogroup WFE_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Deinitializes the WFE registers to their default reset value.
+   * @param  None
+   * @retval None
+   */
+ void WFE_DeInit(void)
+ {
+   WFE->CR1 = WFE_CR1_RESET_VALUE;
+   WFE->CR2 = WFE_CR2_RESET_VALUE;
+ }
+ 
+ /**
+   * @brief  Set the source that can generate the wake-up event.
+   * @param  WFE_Source The wake-up event source.
+   *          This parameter can be one of the following values:
+   *            @arg WFE_Source_TIM2_EV0: TIM2 Update/Trigger and Break interrupt
+   *            @arg WFE_Source_TIM2_EV0: TIM2 Capture/Compare interrupt
+   *            @arg WFE_Source_EXTI_EV0: I/O port interrupt from Pins 0
+   *            @arg WFE_Source_EXTI_EV1: I/O port interrupt from Pins 1
+   *            @arg WFE_Source_EXTI_EV2: I/O port interrupt from Pins 2
+   *            @arg WFE_Source_EXTI_EV3: I/O port interrupt from Pins 3
+   *            @arg WFE_Source_EXTI_EV4: I/O port interrupt from Pins 4
+   *            @arg WFE_Source_EXTI_EV5: I/O port interrupt from Pins 5
+   *            @arg WFE_Source_EXTI_EV6: I/O port interrupt from Pins 6
+   *            @arg WFE_Source_EXTI_EV7: I/O port interrupt from Pins 7
+   *            @arg WFE_Source_EXTI_EVB: I/O port interrupt from port B
+   *            @arg WFE_Source_EXTI_EVD: I/O port interrupt from port D  
+   * @param  NewState The source wake up new state.
+   * @retval None
+   */
+ void WFE_WakeUpSourceEventCmd(WFE_Source_TypeDef WFE_Source, FunctionalState NewState)
+ {
+   uint8_t register_index = 0;
+   /* Check function parameters */
+   assert_param(IS_WFE_SOURCE_OK(WFE_Source));
+   assert_param(IS_FUNCTIONAL_STATE(NewState));
+ 
+   /* The mask is reversed in order to  */
+   register_index = (uint8_t)((uint16_t)WFE_Source >> (uint8_t)0x08);
+ 
+   if (NewState != DISABLE)
+   {
+     switch (register_index)
+     {
+       case 1:
+         WFE->CR1 |= (uint8_t)WFE_Source;
+         break;
+ 
+       case 2:
+         WFE->CR2 |= (uint8_t)WFE_Source;
+         break;
+ 
+       default:
+         break;
+     }
+   }
+   else
+   {
+     switch (register_index)
+     {
+       case 1:
+         WFE->CR1 &= (uint8_t)(~(uint8_t)WFE_Source);
+         break;
+ 
+       case 2:
+         WFE->CR2 &= (uint8_t)(~(uint8_t)WFE_Source);
+         break;
+ 
+       default:
+         break;
+     }
+   }
+ }
+ 
+ /**
+   * @brief  Get the status of the specified source event.
+   * @param  WFE_Source The wake-up event source.
+   *          This parameter can be one of the following values:
+   *            @arg WFE_Source_TIM2_EV0: TIM2 Update/Trigger and Break interrupt
+   *            @arg WFE_Source_TIM2_EV0: TIM2 Capture/Compare interrupt
+   *            @arg WFE_Source_EXTI_EV0: I/O port interrupt from Pins 0
+   *            @arg WFE_Source_EXTI_EV1: I/O port interrupt from Pins 1
+   *            @arg WFE_Source_EXTI_EV2: I/O port interrupt from Pins 2
+   *            @arg WFE_Source_EXTI_EV3: I/O port interrupt from Pins 3
+   *            @arg WFE_Source_EXTI_EV4: I/O port interrupt from Pins 4
+   *            @arg WFE_Source_EXTI_EV5: I/O port interrupt from Pins 5
+   *            @arg WFE_Source_EXTI_EV6: I/O port interrupt from Pins 6
+   *            @arg WFE_Source_EXTI_EV7: I/O port interrupt from Pins 7
+   *            @arg WFE_Source_EXTI_EVB: I/O port interrupt from port B
+   *            @arg WFE_Source_EXTI_EVD: I/O port interrupt from port D                      
+   * @retval Source Event state.
+   */
+ FunctionalState WFE_GetWakeUpSourceEventStatus(WFE_Source_TypeDef WFE_Source)
+ {
+   FunctionalState status = DISABLE;
+   /* Check function parameters */
+   assert_param(IS_WFE_SOURCE_OK(WFE_Source));
+ 
+   switch (WFE_Source)
+   {
+     case WFE_Source_TIM2_EV0:
+     case WFE_Source_TIM2_EV1:
+     case WFE_Source_EXTI_EV0:
+     case WFE_Source_EXTI_EV1:
+     case WFE_Source_EXTI_EV2:
+     case WFE_Source_EXTI_EV3:
+ 
+       if ((WFE->CR1 & (uint8_t)WFE_Source) != (uint8_t)0x00)
+       {
+         /* The wake-up event source is enabled*/
+         status = ENABLE;
+       }
+       else
+       {
+         /* The wake-up event source is disabled*/
+         status = DISABLE;
+       }
+       break;
+ 
+     case WFE_Source_EXTI_EV4:
+     case WFE_Source_EXTI_EV5:
+     case WFE_Source_EXTI_EV6:
+     case WFE_Source_EXTI_EV7:
+     case WFE_Source_EXTI_EVB:
+     case WFE_Source_EXTI_EVD:
+ 
+       if ((WFE->CR2 & (uint8_t)WFE_Source) != (uint8_t)0x00)
+       {
+         /* The wake-up event source is enabled*/
+         status = ENABLE;
+       }
+       else
+       {
+         /* The wake-up event source is disabled*/
+         status = DISABLE;
+       }
+       break;
+     default:
+       break;
+   }
+   return status;
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
Binrdateien ./STM8L10x_StdPeriph_Lib_V1.2.1/MCD-ST Liberty SW License Agreement V2.pdf und ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/MCD-ST Liberty SW License Agreement V2.pdf sind verschieden.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/main.c	2018-04-05 05:29:56.000000000 +0200
***************
*** 0 ****
--- 1,280 ----
+ /**
+   ******************************************************************************
+   * @file    AWU/AWU_ActiveHaltMode/main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ #include "stm8l_eval_lcd.h"
+ 
+ /**
+   * @addtogroup AWU_ActiveHaltMode
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ 
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void AWU_Config(void);
+ static void CLK_Config(void);
+ void Delay (uint16_t nCount);
+ uint32_t LSIMeasurment(void);
+ /* Private functions ---------------------------------------------------------*/
+ /* Global variables ----------------------------------------------------------*/
+ bool ButtonPressed = FALSE;
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   uint16_t i = 0;
+   uint16_t j = 0;
+ 
+   /* Clock configuration -----------------------------------------*/
+   CLK_Config();
+    
+   /* Initialize LEDs mounted on the EVAL board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+ 
+   /* Initialize KEY pushbutton mounted on the EVAL board */
+   STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+     
+   /* Configure LCD mounted on the EVAL board ----------------*/
+   STM8L_EVAL_LCD_Init();
+     
+   /* Clear LCD */
+   LCD_Clear();
+  
+   /*AWU configuration --------------------------------------------*/
+   AWU_Config();
+     
+   /* Print "Running..." on LCD line1*/
+   LCD_SetCursorPos(LCD_LINE1, 0);
+   LCD_Print("  Running...  ");
+   /* Print "Press Key" on LCD line2*/
+   LCD_SetCursorPos(LCD_LINE2, 0);
+   LCD_Print("  Press Key   ");
+     
+   /* Enable general interrupts */
+   enableInterrupts();    
+     
+   while (1)
+   {
+ 
+     /* Check button status */
+     if (ButtonPressed == TRUE) /* Button is pressed */
+     {
+ 
+       ButtonPressed = FALSE;
+         
+       /* Clear LCD lines */
+      LCD_Clear();
+      LCD_SetCursorPos(LCD_LINE1, 0);
+      LCD_Print(" Preparing to ");
+      LCD_SetCursorPos(LCD_LINE2, 0);
+      LCD_Print("    sleep...  ");
+ 
+       /* LEDs toggle quickly */
+       for (j = 0; j < 20; j++)
+       {
+         STM_EVAL_LEDToggle(LED2);
+         STM_EVAL_LEDToggle(LED3);
+         STM_EVAL_LEDToggle(LED4);
+         for (i = 0; i < 2; i++)
+   {
+           Delay((uint16_t)60000);
+         }
+        }
+ 
+       /* Switch LEDs OFF */
+       STM_EVAL_LEDOff(LED2);
+       STM_EVAL_LEDOff(LED3);
+       STM_EVAL_LEDOff(LED4);
+ 
+       LCD_Clear();
+ 
+       halt(); /* Program halted */
+ 
+       /* Program re-starts here, thanks to AWU */
+       LCD_Clear();
+       LCD_SetCursorPos(LCD_LINE1, 0);
+       LCD_Print("  Running...  ");
+       /* Print "Press Key" on LCD line2*/
+       LCD_SetCursorPos(LCD_LINE2, 0);
+       LCD_Print("  Press Key   ");
+ 
+     }
+     else
+     {
+       /* Toggle LEDs slowly */
+       STM_EVAL_LEDToggle(LED2);
+       STM_EVAL_LEDToggle(LED3);
+       STM_EVAL_LEDToggle(LED4);
+       for (i = 0; i < 15; i++)
+       {
+         Delay((uint16_t)60000);
+       }
+     }
+   }
+ }
+ 
+ /**
+   * @brief  Configure system clock to run at 16Mhz
+   * @param  None
+   * @retval None
+   */
+ static void CLK_Config(void)
+ {
+   /* Initialization of the clock */
+   /* Clock divider to HSI/1 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+     
+   /* Enable SPI clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+   CLK_PeripheralClockConfig(CLK_Peripheral_AWU, ENABLE);
+ }
+ 
+ /**
+   * @brief  Configure the AWU time base to 12s
+   * @param  None
+   * @retval None
+   */
+ static void AWU_Config(void)
+ {
+   /* Initialization of AWU */
+    /* LSI calibration for accurate auto wake up time base*/
+   AWU_LSICalibrationConfig(LSIMeasurment());
+ 
+   /* The delay corresponds to the time we will stay in Halt mode */
+   AWU_Init(AWU_Timebase_12s);
+ }
+ 
+ 
+ /**
+   * @brief Measure the LSI frequency using timer IC1 and update the calibration registers.
+   * @note   It is recommended to use a timer clock frequency of at least 10MHz in order 
+   *         to obtain a better in the LSI frequency measurement.
+   * @param  None
+   * @retval None
+   */
+ uint32_t LSIMeasurment(void)
+ {
+ 
+   uint32_t lsi_freq_hz = 0x0;
+   uint32_t fmaster = 0x0;
+   uint16_t ICValue1 = 0x0;
+   uint16_t ICValue2 = 0x0;
+ 
+   /* Get master frequency */
+   fmaster = CLK_GetClockFreq();
+ 
+   /* Enable the LSI measurement: LSI clock connected to timer Input Capture 1 */
+   AWU->CSR |= AWU_CSR_MSR;
+ 
+   /* Capture only every 8 events!!! */
+   TIM2_ICInit(  TIM2_Channel_1, TIM2_ICPolarity_Rising, TIM2_ICSelection_DirectTI, TIM2_ICPSC_Div8, 0x0);
+ 
+   /* Enable TIM2 */
+   TIM2_Cmd(ENABLE);
+ 
+   /* wait a capture on cc1 */
+   while ((TIM2->SR1 & (uint8_t)TIM2_FLAG_CC1) != TIM2_FLAG_CC1);
+   /* Get CCR1 value*/
+   ICValue1 = TIM2_GetCapture1();
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+ 
+   /* wait a capture on cc1 */
+   while ((TIM2->SR1 & (uint8_t)TIM2_FLAG_CC1) != TIM2_FLAG_CC1);
+   /* Get CCR1 value*/
+   ICValue2 = TIM2_GetCapture1();
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+ 
+   /* Disable IC1 input capture */
+   TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+   /* Disable TIM2 */
+   TIM2_Cmd(DISABLE);
+ 
+   /* Compute LSI clock frequency */
+   lsi_freq_hz = (8 * fmaster) / (ICValue2 - ICValue1);
+ 
+   /* Disable the LSI measurement: LSI clock disconnected from timer Input Capture 1 */
+   AWU->CSR &= (uint8_t)(~AWU_CSR_MSR);
+   
+   return (lsi_freq_hz);
+ 
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,73 ----
+ /** @page AWU_ActiveHaltMode Using the AWU to wake-up the CPU from Active Halt mode
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    AWU/AWU_ActiveHalt/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the AWU example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to use the AWU peripheral:
+   - Initialization of the AWU peripheral
+   - Initialization of GPIO pins in output mode in order to drive LEDs
+   - Initialization of a GPIO in input mode in order to read the Key Button state
+ 
+ 
+   @par Directory content
+ 
+   - AWU\AWU_ActiveHaltMode\main.c                       Main file containing the "main" function
+   - AWU\AWU_ActiveHaltMode\stm8l10x_conf.h              Library Configuration file
+   - AWU\AWU_ActiveHaltMode\stm8l10x_it.c                Interrupt routines source
+   - AWU\AWU_ActiveHaltMode\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - LED2, LED3 and LED4
+      - Key push button.
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - The 3 LEDs (LED2, LED3 and LED4) blink continuously and slowly
+   - If you press the Key button on the board, the LEDs will blink faster for
+     few seconds and then will be switched off.
+   - At this stage, the CPU is in Active Halt mode.
+   - After few seconds (12s), the MCU will exit from halt mode thanks to the AWU.
+   - The 3 LEDs will continue to blink slowly.
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,330 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ extern bool ButtonPressed;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ #ifdef _COSMIC_
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+   /* Clear AWU peripheral pending bit */
+   AWU_GetFlagStatus();
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+ 	ButtonPressed = TRUE;
+ 	EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/AWU/AWU_ActiveHaltMode/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/main.c	2018-04-05 05:30:05.000000000 +0200
***************
*** 0 ****
--- 1,285 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ #include "stm8l_eval_lcd.h"
+ 
+ /**
+   * @addtogroup BEEP_3SignalsGeneration
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ 
+ /* Evalboard I/Os configuration */
+ 
+ #define LEDS_PORT (GPIOD)
+ #define LED2_PIN  (GPIO_Pin_4)
+ #define LED3_PIN  (GPIO_Pin_5)
+ #define LED4_PIN  (GPIO_Pin_6)
+ 
+ #define BUTTON_PORT (GPIOA)
+ #define BUTTON_PIN  (GPIO_Pin_5)
+ 
+ 
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void CLK_Config(void);
+ void Delay (uint16_t nCount);
+ uint32_t LSIMeasurment(void);
+ /* Private functions ---------------------------------------------------------*/
+ /* Global variables ----------------------------------------------------------*/
+ bool ButtonPressed = FALSE;
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+ 
+     uint8_t i = 0;
+ 
+   /* Clock configuration -----------------------------------------*/
+   CLK_Config();
+     
+   /* Initialize LEDs mounted on the EVAL board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+ 
+   /* Initialize KEY pushbutton mounted on the EVAL board */
+   STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+ 
+   /* All LEDs ON */  
+   STM_EVAL_LEDOn(LED2);
+   STM_EVAL_LEDOn(LED3);
+   STM_EVAL_LEDOn(LED4);
+ 
+   /* Configure LCD mounted on the EVAL board ----------------*/
+   STM8L_EVAL_LCD_Init();
+     
+   /* Clear LCD */
+   LCD_Clear();
+     
+   /* Enable general interrupts for Key button reading */
+   enableInterrupts();
+ 
+   /* Print "  BEEPER OFF  " on LCD line1*/
+   LCD_SetCursorPos(LCD_LINE1, 0);
+   LCD_Print("  BEEPER OFF  ");
+   /* Print "Press Key" on LCD line2*/
+   LCD_SetCursorPos(LCD_LINE2, 0);
+   LCD_Print("  Press Key   ");
+     
+   /* BEEP calibration */
+   BEEP_LSICalibrationConfig(LSIMeasurment());
+     
+     while (1)
+     {
+         /* Check button status */
+         if (ButtonPressed == TRUE) /* Button is pressed */
+         {
+             ButtonPressed = FALSE;
+             /* Change BEEP frequency */
+             switch (i)
+             {
+             case 0:
+                 BEEP_Cmd(DISABLE);
+                 Delay(100);
+                 BEEP_Init(BEEP_Frequency_1KHz);
+                 BEEP_Cmd(ENABLE);
+                 /* LED2 ON */
+                 STM_EVAL_LEDOn(LED2);
+                 STM_EVAL_LEDOff(LED3);
+                 STM_EVAL_LEDOff(LED4); 
+                 LCD_SetCursorPos(LCD_LINE1, 0);
+                 LCD_Print("  BEEPER 1kHz ");
+                 i = 1;
+                 break;
+             case 1:
+                 BEEP_Cmd(DISABLE);
+                 Delay(100);
+                 BEEP_Init(BEEP_Frequency_2KHz);
+                 BEEP_Cmd(ENABLE);
+                 /* LED3 ON */
+                 STM_EVAL_LEDOn(LED3);
+                 STM_EVAL_LEDOff(LED2);
+                 STM_EVAL_LEDOff(LED4); 
+                 LCD_SetCursorPos(LCD_LINE1, 0);
+                 LCD_Print("  BEEPER 2kHz ");
+                 i = 2;
+                 break;
+             case 2:
+                 BEEP_Cmd(DISABLE);
+                 Delay(100);
+                 BEEP_Init(BEEP_Frequency_4KHz);
+                 BEEP_Cmd(ENABLE);
+                 /* LED4 ON */
+                 STM_EVAL_LEDOn(LED4);
+                 STM_EVAL_LEDOff(LED2);
+                 STM_EVAL_LEDOff(LED3); 
+                 LCD_SetCursorPos(LCD_LINE1, 0);
+                 LCD_Print("  BEEPER 4kHz ");
+                 i = 3;
+                 break;
+             case 3:
+                 BEEP_Cmd(DISABLE);
+                 /* All LEDs ON */
+                 STM_EVAL_LEDOn(LED4);
+                 STM_EVAL_LEDOn(LED2);
+                 STM_EVAL_LEDOn(LED3); 
+                 LCD_SetCursorPos(LCD_LINE1, 0);
+                 LCD_Print("  BEEPER OFF  ");
+                 i = 0;
+                 break;
+             default:
+                 break;
+             }
+         }
+ 
+     }
+ 
+ }
+ 
+ /**
+   * @brief  Configure system clock to run at 16Mhz
+   * @param  None
+   * @retval None
+   */
+ static void CLK_Config(void)
+ {
+   /* Initialization of the clock */
+   /* Clock divider to HSI/1 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+     
+   /* Enable SPI clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+   CLK_PeripheralClockConfig(CLK_Peripheral_AWU, ENABLE);
+ }
+ 
+ /**
+   * @brief Measure the LSI frequency using timer IC1 and update the calibration registers.
+   * @note   It is recommended to use a timer clock frequency of at least 10MHz in order 
+   *         to obtain a better in the LSI frequency measurement.
+   * @param  None
+   * @retval None
+   */
+ uint32_t LSIMeasurment(void)
+ {
+ 
+   uint32_t lsi_freq_hz = 0x0;
+   uint32_t fmaster = 0x0;
+   uint16_t ICValue1 = 0x0;
+   uint16_t ICValue2 = 0x0;
+ 
+   /* Get master frequency */
+   fmaster = CLK_GetClockFreq();
+ 
+   /* Enable the LSI measurement: LSI clock connected to timer Input Capture 1 */
+   AWU->CSR |= AWU_CSR_MSR;
+ 
+   /* Capture only every 8 events!!! */
+   TIM2_ICInit(  TIM2_Channel_1, TIM2_ICPolarity_Rising, TIM2_ICSelection_DirectTI, TIM2_ICPSC_Div8, 0x0);
+ 
+   /* Enable TIM2 */
+   TIM2_Cmd(ENABLE);
+ 
+   /* wait a capture on cc1 */
+   while ((TIM2->SR1 & (uint8_t)TIM2_FLAG_CC1) != TIM2_FLAG_CC1);
+   /* Get CCR1 value*/
+   ICValue1 = TIM2_GetCapture1();
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+ 
+   /* wait a capture on cc1 */
+   while ((TIM2->SR1 & (uint8_t)TIM2_FLAG_CC1) != TIM2_FLAG_CC1);
+   /* Get CCR1 value*/
+   ICValue2 = TIM2_GetCapture1();
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+ 
+   /* Disable IC1 input capture */
+   TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
+   /* Disable TIM2 */
+   TIM2_Cmd(DISABLE);
+ 
+   /* Compute LSI clock frequency */
+   lsi_freq_hz = (8 * fmaster) / (ICValue2 - ICValue1);
+ 
+   /* Disable the LSI measurement: LSI clock disconnected from timer Input Capture 1 */
+   AWU->CSR &= (uint8_t)(~AWU_CSR_MSR);
+   
+   return (lsi_freq_hz);
+ 
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,78 ----
+ /** @page BEEP_3SignalsGeneration Generation of the 3 beep signals
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    BEEP/BEEP_3SignalsGeneration/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the BEEP example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example provides a short description of how to use the BEEP peripheral:
+   - Initialization of the BEEP peripheral
+   - Initialization of a GPIO in input mode in order to read the Key Button state
+   - Initialization of GPIO in output mode to drive LEDs
+   - Each action on the Key button toggles between the 3 beep frequencies
+ 
+ 
+   @par Directory content
+ 
+   - BEEP\BEEP_3SignalsGeneration\main.c                       Main file containing the "main" function
+   - BEEP\BEEP_3SignalsGeneration\stm8l10x_conf.h              Library Configuration file
+   - BEEP\BEEP_3SignalsGeneration\stm8l10x_it.c                Interrupt routines source
+   - BEEP\BEEP_3SignalsGeneration\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - Make sure that the JP9 is on the Beep position (to enable the beeper)
+      - Make sure that the JP10 is installed (to enable the speaker)
+      - Adjust the speaker volume by the mean of the RV2 potentiometer
+      - Three leds (LD2, LD3 and LD4)
+      - Key push button.
+      - PA0 used to drive the buzzer
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Per default, the BEEP signal is OFF and the 3 LEDs are ON.
+   - Everytime you press the Key button on the board, you will toggle the
+     buzzer frequency in this way: 1kHz -> 2kHz -> 4kHz -> OFF -> 1kHz -> etc...
+   - The 3 LEDs will toggle respectively.
+   
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ extern bool ButtonPressed;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+   ButtonPressed = TRUE;
+ 	EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/BEEP/BEEP_3SignalsGeneration/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/main.c	2018-04-05 05:30:14.000000000 +0200
***************
*** 0 ****
--- 1,122 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /**
+   * @addtogroup CLK_MasterClock
+   * @{
+   */
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ void Delay (uint16_t nCount);
+ 
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /*configure the CCO GPIO PIN (PC4)*/
+   GPIO_ExternalPullUpConfig(GPIOC,GPIO_Pin_4,ENABLE);
+ 
+   /* Initialize LEDs mounted on the EVAL board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+ 
+   /* Initialize Joystick pushbutton mounted on the EVAL board */
+   STM_EVAL_PBInit(BUTTON_RIGHT, BUTTON_MODE_EXTI);
+   STM_EVAL_PBInit(BUTTON_LEFT, BUTTON_MODE_EXTI);
+   STM_EVAL_PBInit(BUTTON_UP, BUTTON_MODE_EXTI);
+   STM_EVAL_PBInit(BUTTON_DOWN, BUTTON_MODE_EXTI);
+   
+   enableInterrupts();
+ 
+   /* Select and enable Master clock output on CCO pin */
+   CLK_CCOConfig(CLK_Output_ClockMaster);
+   
+   while (1)
+   {
+     /* LEDs Toggle */
+     STM_EVAL_LEDToggle(LED2);
+     STM_EVAL_LEDToggle(LED3);
+     STM_EVAL_LEDToggle(LED4);
+     
+     Delay((uint16_t)60000);
+   }
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+   /* Decrement nCount value */
+   while (nCount != 0)
+   {
+     nCount--;
+   }
+ }
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,72 ----
+ /** @page CLK_MasterClock  Master Clock Prescaler Configuration example
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    CLK/CLK_MasterClock/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the Master Clock configuration example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example is demonstrating the different Master Prescaler configuartions,
+   using the joystick available on the evaluation board.
+   - Each time a clock is selected LEDs from 2 to 4 start blinking for a while
+     according to the selected clock frequency.
+ 
+ @par Directory contents
+ 
+   - CLK\CLK_MasterClock\main.c             Main file containing the "main" function
+   - CLK\CLK_MasterClock\stm8l10x_conf.h    Library Configuration file
+   - CLK\CLK_MasterClock\stm8l10x_it.c      Interrupt routines source
+   - CLK\CLK_MasterClock\stm8l10x_it.h      Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+ 
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   -  Connect PC4 pin (CCO) to an Oscilloscope
+ 
+   - STM8L1x-EVAL Set-up
+      - Three leds LD2, LD3 and LD4 
+      - Joystick button.
+      
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Using the joystick choose the desired Master clock:
+     UP = HSI/4, DOWN = HSI/8, RIGHT = HSI, LEFT = HSI/2
+   - Observe the LEDs frequency blinking according to the selected clock. 
+   - The clock output can be monitored by putting a scope on PC4 (CCO).
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,347 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+   /* In order to detect unexpected events during development,
+     it is recommended to set a breakpoint on the following instruction.
+   */
+   /* Clock divider to HSI/2 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv2);
+   
+   EXTI_ClearITPendingBit(EXTI_IT_Pin1);            
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   /* Clock divider to HSI/1 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+ 
+   EXTI_ClearITPendingBit(EXTI_IT_Pin2);    
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   /* Clock divider to HSI/4 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv4);
+ 
+   EXTI_ClearITPendingBit(EXTI_IT_Pin3);    
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   /* Clock divider to HSI/8 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv8);
+ 
+   EXTI_ClearITPendingBit(EXTI_IT_Pin4);    
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/CLK/CLK_MasterClock/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/main.c	2018-04-05 05:30:00.000000000 +0200
***************
*** 0 ****
--- 1,141 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /* Private defines -----------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void CLK_Config(void);
+ static void COMP_Config(void);
+ static void TIM_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* CLK configuration -------------------------------------------*/
+   CLK_Config(); 
+   
+   /* Initialize Leds mounted on evaluation board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+   
+   /* COMP configuration-------------------------------------------*/
+   COMP_Config();
+   
+   /* Timer configuration -----------------------------------------*/
+   TIM_Config();
+   
+   /*Enable general interrupts */
+   enableInterrupts();
+   
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ 
+ /**
+   * @brief  Configure peripheral clock 
+   * @param  None
+   * @retval None
+   */
+ static void CLK_Config(void)
+ {
+   /* Configure system clock*/
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+   
+   /* Enable TIM3 Clock input */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE);
+ }
+ 
+ /**
+   * @brief  Configure Comparator peripheral 
+   * @param  None
+   * @retval None
+   */
+ static void COMP_Config(void)
+ {
+   /*Configure COMP2 */
+   COMP_DeInit();
+   /*Enable Comparator interface */
+   COMP_Cmd(ENABLE);
+   /*Configure COMP2 channel3 with external reference source and polarity high*/
+   COMP_Init(COMP_Selection_COMP2, COMP_Reference_External, COMP_Polarity_High);
+   COMP_SwitchConfig(COMP_Switch_COMP2Ch3, ENABLE);
+   /*Enable COMP2 interrupt */
+   COMP_ITConfig(COMP_IT_ITEN2, ENABLE);
+ }
+ 
+ /**
+   * @brief  Configure peripheral timer 
+   * @param  None
+   * @retval None
+   */
+ static void TIM_Config(void)
+ {
+   /*Configure Timer3*/
+   TIM3_DeInit();
+   /*Configure Timer3 to generate time base interrupt each 2ms*/
+   TIM3_TimeBaseInit(TIM3_Prescaler_128, TIM3_CounterMode_Up, 0xFA);
+   /*Enable Timer3 interrupt */
+   TIM3_ITConfig(TIM3_IT_Update, ENABLE);
+   /*Enable Timer3 */
+   TIM3_Cmd(ENABLE);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,71 ----
+ /** @page COMP_Interrupt  Comparator Interrupt Mode example
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    COMP/COMP_Interrupt/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the Comparator in interrupt mode example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example is demonstrating the comparator interrupt capability on the detection
+   of an input voltage applied to the COMP2 Channel 3,  higher than its reference.
+   - Using the potentiometer RV1, the input voltage is changed. 
+   Each time it's higher than the external comparator reference, an interrupt is 
+   generated and accordingly leds from 2 to 4 light up.
+ 
+ @par Directory contents
+ 
+   - COMP\COMP_Interrupt\main.c             Main file containing the "main" function
+   - COMP\COMP_Interrupt\stm8l10x_conf.h    Library Configuration file
+   - COMP\COMP_Interrupt\stm8l10x_it.c      Interrupt routines source
+   - COMP\COMP_Interrupt\stm8l10x_it.h      Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+     
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - Three leds LD2, LD3 and LD4
+      - RV1 the potentiometer
+      
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Using the potentiometer RV1 change the input voltage on COMP2 channel 3
+   - An interrupt is generated each time the input voltage is higher than the 
+   reference.
+   - LEDs from 2 to 4 will light up consecuently. 
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,409 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "stm8l101_eval.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ /* Public functions ----------------------------------------------------------*/
+ 
+ #ifdef _COSMIC_
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval None
+   * None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ 
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   uint8_t conval = 0;
+   
+   COMP_ClearITPendingBit(COMP_IT_CEF2);
+   
+   conval = TIM3_GetCounter();
+   
+    if (conval == 0x0)
+     {
+         STM_EVAL_LEDOn(LED2);
+         STM_EVAL_LEDOn(LED3);
+         STM_EVAL_LEDOn(LED4);
+     }
+     else if ((conval <= 0xC0) && (conval > 0xA7))
+     {
+         STM_EVAL_LEDOff(LED2);
+         STM_EVAL_LEDOff(LED3);
+         STM_EVAL_LEDOff(LED4);
+     }
+     else if ((conval >= 0xC1) && (conval <= 0xE0))
+     {
+         STM_EVAL_LEDOff(LED2);
+         STM_EVAL_LEDOff(LED4);
+         STM_EVAL_LEDOn(LED3);
+ 
+     }
+     else
+     {
+         STM_EVAL_LEDOff(LED2);
+         STM_EVAL_LEDOn(LED4);
+         STM_EVAL_LEDOn(LED3);
+     }
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   GPIO_ToggleBits(GPIOC, GPIO_Pin_4);
+   
+   TIM3_ClearITPendingBit(TIM3_IT_Update);
+ 
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @par Parameters:
+   * None
+   * @retval
+   * None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/COMP/COMP_Interrupt/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/main.c	2018-04-05 05:31:13.000000000 +0200
***************
*** 0 ****
--- 1,116 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */ 
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ 
+ /**
+   * @addtogroup EXTI_IOControl
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ #define JOYSTICK_PORT       (GPIOB)
+ #define JOYSTICK_LEFT_PIN   (GPIO_Pin_1)
+ #define JOYSTICK_RIGHT_PIN  (GPIO_Pin_2)
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ void Delay(uint16_t nCount);
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* Initialize I/Os in Output Mode for LEDs */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+   
+   /* Initialize I/O in Input Mode with Interrupt for Joystick */
+   GPIO_Init(JOYSTICK_PORT, JOYSTICK_LEFT_PIN | JOYSTICK_RIGHT_PIN, GPIO_Mode_In_FL_IT);
+ 
+   /* Initialize the Interrupt sensitivity joystick */
+   EXTI_SetPinSensitivity(EXTI_Pin_1, EXTI_Trigger_Falling_Low);
+   EXTI_SetPinSensitivity(EXTI_Pin_2, EXTI_Trigger_Falling_Low);
+   
+   enableInterrupts();
+ 
+   while (1)
+   {
+     /* The LED toggles in the interrupt routines */
+   }
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,73 ----
+ /** @page EXTI_IOControl Reading buttons state using external interrupts
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    EXTI/EXTI_IOControl/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the EXTI IO Control Example.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This basic firwmare example shows how to use the EXTI peripheral.
+   It does the following:
+   - Configures three I/Os in output push-pull for driving three LEDs
+   - Configures two I/Os in input with interrupt for reading two buttons
+   - Configures the two External Interrupt lines in Falling edge + Low level (GPIOB Pin1 and Pin2)
+ 
+ 
+   @par Directory content
+ 
+   - EXTI\EXTI_IOControl\main.c                       Main file containing the "main" function
+   - EXTI\EXTI_IOControl\stm8l10x_conf.h              Library Configuration file
+   - EXTI\EXTI_IOControl\stm8l10x_it.c                Interrupt routines source
+   - EXTI\EXTI_IOControl\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   -   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - Three leds LD2 to LD4.
+      - Joystick LEFT and RIGHT buttons.
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example  
+   - The LED2, LED3 and LED4 are OFF per default
+   - When the Joystick LEFT button is kept pressed, the Leds blink
+   - When the Joystick RIGHT button is kept pressed, the Leds scroll
+ 
+  
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,349 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "stm8l101_eval.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ extern void Delay(uint16_t nCount);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+   /* LED2, LED3 & LED4 toggle */
+   STM_EVAL_LEDToggle(LED2);
+   STM_EVAL_LEDToggle(LED3);
+   STM_EVAL_LEDToggle(LED4);
+   Delay((uint16_t)60000);
+   EXTI_ClearITPendingBit(EXTI_IT_Pin1);
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+     /* Scroll leds */
+   STM_EVAL_LEDToggle(LED2);
+   Delay((uint16_t)20000);  
+   STM_EVAL_LEDToggle(LED3);
+   Delay((uint16_t)20000);
+   STM_EVAL_LEDToggle(LED4);
+   Delay((uint16_t)20000);
+ 
+   EXTI_ClearITPendingBit(EXTI_IT_Pin2);
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/EXTI/EXTI_IOControl/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/main.c	2018-04-05 05:30:43.000000000 +0200
***************
*** 0 ****
--- 1,138 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup FLASH_ByteReadWriteOperation
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ 
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ typedef enum { FAILED = 0, PASSED = !FAILED} TestStatus;
+ __IO TestStatus OperationStatus = FAILED;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+ 
+   uint8_t val = 0x0, val_comp = 0x0;
+   uint32_t add = 0;
+ 
+   /* Define FLASH programming time */
+   FLASH_SetProgrammingTime(FLASH_ProgramTime_Standard);
+ 
+   /* Unlock Data memory */
+   FLASH_Unlock(FLASH_MemType_Program);
+ 
+   /* Read a byte at a specified address */
+   add = 0x9000;
+   val = FLASH_ReadByte(add);
+ 
+   /* Program complement value (of previous read byte) at previous address + 1 */
+   val_comp = (uint8_t)(~val);
+   FLASH_ProgramByte((add + 1), val_comp);
+ 
+   /* Check program action */
+   val = FLASH_ReadByte((add + 1));
+   if (val != val_comp)
+   {
+      /* Error */
+       OperationStatus = FAILED;
+      /* OperationStatus = PASSED, if the data written/read to/from FLASH program memory is correct */
+      /* OperationStatus = FAILED, if the data written/read to/from FLASH program memory is corrupted */
+       while (1)
+       {
+      }
+   }
+ 
+     /* Erase byte at a specified address & address + 1 */
+   FLASH_EraseByte(add);
+   FLASH_EraseByte((add + 1));
+   /* Erase action */
+   val = FLASH_ReadByte(add);
+   val_comp = FLASH_ReadByte((add + 1));
+   if ((val != 0x00) & (val_comp != 0x00))
+   {
+     /* Error */
+     OperationStatus = FAILED;
+     /* OperationStatus = PASSED, if the data written/read to/from FLASH program memory is correct */
+     /* OperationStatus = FAILED, if the data written/read to/from FLASH program memory is corrupted */
+     while (1)
+     {
+     }
+   }
+ 
+   /* Pass */
+   OperationStatus = PASSED;
+   /* OperationStatus = PASSED, if the data written/read to/from FLASH program memory is correct */
+   /* OperationStatus = FAILED, if the data written/read to/from FLASH program memory is corrupted */
+   while (1)
+   {
+   }
+ 
+ }
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,69 ----
+ /** @page FLASH_ByteReadWriteOperation Read, Write, Erase byte
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    FLASH/FLASH_ByteReadWriteOperation/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the Byte read, write operation from/to FLASH
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example provides a short description on how to use FLASH Read/Write/Erase byte modes:
+   - Read a byte at a specified address (0x9000).
+   - Write complement value (of previous byte value) at address +1 (0x9001).
+   - Check programmed byte (using read function)
+   - Erase 2 bytes at address & address+1
+   - Check 2 bytes are erased (value must be equal to 0x00).
+ 
+ 
+   @par Directory content
+ 
+   - FLASH\FLASH_ByteReadWriteOperation\main.c                    Main file containing the "main" function
+   - FLASH\FLASH_ByteReadWriteOperation\stm8l10x_conf.h           Library Configuration file
+   - FLASH\FLASH_ByteReadWriteOperation\stm8l10x_it.c             Interrupt routines source (not used in this example)
+   - FLASH\FLASH_ByteReadWriteOperation\stm8l10x_it.h             Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+  
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example  
+   - You can check the value of the bytes at the specified addresses by using the memory window in STVD.
+   - The data read from the data memory is compared with the expected values.
+     The result of this comparison is stored in the "OperationStatus" variable.
+    
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,329 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_ByteReadWriteOperation/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/main.c	2018-04-05 05:30:39.000000000 +0200
***************
*** 0 ****
--- 1,226 ----
+ /**
+   ******************************************************************************
+   * @file    FLASH/FLASH_DataProgram/main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Examples
+   * @{
+   */
+ 
+ /**
+   * @addtogroup FLASH_DataProgram
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ typedef enum { FAILED = 0, PASSED = !FAILED} TestStatus;
+ /* Private define ------------------------------------------------------------*/
+ #define BLOCK_OPERATION    0    /* block 0 in data eeprom memory: address is 0x1000 */
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ uint8_t GBuffer[FLASH_BLOCK_SIZE];
+ TestStatus OperationStatus = FAILED;
+ 
+ #ifdef _RAISONANCE_
+ /* needed by memcpy for raisonance */
+  #include <string.h>
+  extern int __address__FLASH_EraseBlock;
+  extern int __size__FLASH_EraseBlock;
+  extern int __address__FLASH_ProgramBlock;
+  extern int __size__FLASH_ProgramBlock;
+ #endif /*_RAISONANCE_*/
+ 
+ /* Private function prototypes -----------------------------------------------*/
+ /* Declare _fctcpy function prototype as it is packaged by default in the Cosmic
+    machine library */
+ #ifdef _COSMIC_
+  int _fctcpy(char name);
+ #endif /*_COSMIC_*/
+ void Delay(uint32_t nCount);
+ 
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   uint32_t add = 0, startadd = 0, stopadd = 0;
+   uint8_t newval = 0xAA;
+   uint8_t i = 0;
+ 
+ #ifdef _COSMIC_
+ /* Call the _fctcpy() function with the first segment character as parameter 
+    "_fctcpy('F');"  for a manual copy of the declared moveable code segment
+    (FLASH_CODE) in RAM before execution*/
+   _fctcpy('F');
+ #endif /*_COSMIC_*/
+ 
+ #ifdef _RAISONANCE_
+ /* Call the standard C library: memcpy() or fmemcpy() functions available through 
+    the <string.h> to copy the inram function to the RAM destination address */
+   MEMCPY(FLASH_EraseBlock,
+          (void PointerAttr*)&__address__FLASH_EraseBlock,
+          (int)&__size__FLASH_EraseBlock);
+   MEMCPY(FLASH_ProgramBlock,
+          (void PointerAttr*)&__address__FLASH_ProgramBlock,
+          (int)&__size__FLASH_ProgramBlock);
+ #endif /*_RAISONANCE_*/
+ 
+ /* SDCC patch: code execution from RAM not yet implemented for SDCC */
+ #ifdef _SDCC_
+   #error code execution from RAM not yet implemented for SDCC
+ #endif /*_SDCC_*/
+ 
+   /* Initialize I/Os in Output Mode */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+ 
+   /* High speed internal clock prescaler */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+ 
+   /* Define flash programming Time*/
+   FLASH_SetProgrammingTime(FLASH_ProgramTime_Standard);
+ 
+   FLASH_Unlock(FLASH_MemType_Program);
+   /* Wait until Flash Program area unlocked flag is set*/
+   while (FLASH_GetFlagStatus(FLASH_FLAG_PUL) == RESET)
+   {}
+ 
+   /* Unlock flash data eeprom memory */
+   FLASH_Unlock(FLASH_MemType_Data);
+   /* Wait until Data EEPROM area unlocked flag is set*/
+   while (FLASH_GetFlagStatus(FLASH_FLAG_DUL) == RESET)
+   {}
+ 
+   /* Fill the buffer in RAM */
+   for (i = 0; i < FLASH_BLOCK_SIZE; i++)
+   {
+     GBuffer[i] = newval;
+   }
+   /* This function is executed from RAM */
+   FLASH_ProgramBlock(BLOCK_OPERATION, FLASH_ProgramMode_Standard, GBuffer);
+ 	  
+   /* Check the programmed block */
+   startadd = FLASH_START_PHYSICAL_ADDRESS + ((uint16_t)BLOCK_OPERATION * (uint16_t)FLASH_BLOCK_SIZE);
+   stopadd = startadd + (uint16_t)FLASH_BLOCK_SIZE;
+   for (add = startadd; add < stopadd; add++)
+       {
+         if (FLASH_ReadByte(add) != newval)
+         {
+           /* Error */
+           OperationStatus = FAILED;
+           /* OperationStatus = PASSED, if the data written/read to/from Flash program memory is correct */
+           /* OperationStatus = FAILED, if the data written/read to/from Flash program memory is corrupted */
+           while (1)
+           {
+             STM_EVAL_LEDToggle(LED1); /*FAIL: write error */
+             
+             Delay(0xFFFF);
+           }
+         }
+       }
+   /* Erase block 0 and verify it */
+   /* This function is executed from RAM */
+   FLASH_EraseBlock(BLOCK_OPERATION);
+ 
+   for (add = startadd; add < stopadd; add++)
+       {
+         if (FLASH_ReadByte(add) != 0x00)
+         {
+           /* Error */
+           OperationStatus = FAILED;
+           /* OperationStatus = PASSED, if the data written/read to/from Flash program memory is correct */
+           /* OperationStatus = FAILED, if the data written/read to/from Flash program memory is corrupted */
+           while (1)
+           {
+             STM_EVAL_LEDToggle(LED2); /* FAIL: Erase error */
+             
+            Delay(0xFFFF);
+           }
+         }
+       }
+ 
+   /* Pass */
+   OperationStatus = PASSED;
+   /* OperationStatus = PASSED, if the data written/read to/from Flash program memory is correct */
+   /* OperationStatus = FAILED, if the data written/read to/from Flash program memory is corrupted */
+   while (1)
+   {
+     STM_EVAL_LEDToggle(LED3); /* PASS: without errors*/
+     
+     Delay(0xFFFF);
+   }
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint32_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param  file: pointer to the source file name
+   * @param  line: assert_param error line source number
+   * @retval None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ {
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {}
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,96 ----
+ /** @page FLASH_DataProgram How to use the block operations to Write/Erase the Data Memory
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    FLASH/FLASH_DataProgram/readme.txt
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of how to program the STM8L10x FLASH Data Memory using 
+   *          the Write/erase block operations.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a description of how to use FLASH Write/Erase Block mode 
+   on data eeprom memory.
+   After Reset, the Flash memory Program/Erase Controller is locked. 
+   To unlock it, the FLASH_Unlock function is used. Once done, the following 
+   operations on the  data memory will be performed:
+    - Program a block at a specified address (0x1000) by using FLASH_ProgramBlock()
+      function.
+    - Check program block (Read byte) if the program block operation failed LED1 
+      will toggle.
+    - Erase block using FLASH_EraseBlock() function.
+    - Check erase (using Read byte) if the program block operation failed LED2 
+      will toggle.
+   - If Write/Erase operations passed LED3 will toggle. 
+   
+   @note Within the main.c file, you will find details on the procedures to follow 
+         to execute FLASH_ProgramBlock() and FLASH_EraseBlock() functions from RAM. 
+ 
+ 
+   @par Directory content
+ 
+   - FLASH/FLASH_DataProgram/main.c               Main file
+   - FLASH/FLASH_DataProgram/stm8l10x_conf.h      Library Configuration file
+   - FLASH/FLASH_DataProgram/stm8l10x_it.c        Interrupt routines source 
+   - FLASH/FLASH_DataProgram/stm8l10x_it.h        Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - Three leds LD2, LD3 and LD4
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - For Cosmic Compiler
+        - In STVD Select Project\Settings\Linker\Category "input" and in the 
+          RAM section add the FLASH_CODE segment with "-ic" options.
+        - Uncomment the line "#define RAM_EXECUTION (1)" in the stm8l10x.h 
+          file to enable the FLASH functions execution from RAM.
+ 
+   - For Raisonance Compiler
+        - Uncomment the line "#define RAM_EXECUTION (1)" in the 
+          stm8l10x.h file to enable the FLASH functions execution from RAM through the 
+          specific inram directive.
+ 
+   - For IAR Compiler
+        - Uncomment the line "#define RAM_EXECUTION (1)" in the 
+          stm8l10x.h file to enable the FLASH functions execution from RAM through 
+          the specific __ramfunc keyword.
+        
+   - Rebuild all files and load your image into target memory
+   - Run the example
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,329 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_DataProgram/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/main.c	2018-04-05 05:30:36.000000000 +0200
***************
*** 0 ****
--- 1,179 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup FLASH_WriteWordOperation
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ typedef enum { FAILED = 0, PASSED = !FAILED} TestStatus;
+ __IO TestStatus OperationStatus = FAILED;
+ /* Private function prototypes -----------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+     uint32_t start_add = 0x9000;
+     uint32_t add = 0x0;
+     uint32_t new_val = 0x01234567;
+     uint8_t sub_test_count = 0x0 , val = 0x0;
+ 
+     /*Define FLASH programming time*/
+     FLASH_SetProgrammingTime(FLASH_ProgramTime_Standard);
+     /* Unlock flash program memory */
+     FLASH_Unlock(FLASH_MemType_Program);
+ 
+     /* Program word at addres 0x9000*/
+     FLASH_ProgramWord(start_add, new_val);
+ 
+     /* Check program word action */
+     val = FLASH_ReadByte(start_add);
+     add = start_add;
+     if (val != BYTE_3(new_val))
+     {
+         /* Error */
+         OperationStatus = FAILED;
+         /* OperationStatus = PASSED, if the data written/read to/from FLASH Program memory is correct */
+         /* OperationStatus = FAILED, if the data written/read to/from FLASH Program memory is corrupted */
+         while (1)
+         {
+         }
+     }
+ 
+     add += 1;
+     val = FLASH_ReadByte(add);
+     if (val != BYTE_2(new_val))
+     {
+         /* Error */
+         OperationStatus = FAILED;
+         /* OperationStatus = PASSED, if the data written/read to/from FLASH Program memory is correct */
+         /* OperationStatus = FAILED, if the data written/read to/from FLASH Program memory is corrupted */
+         while (1)
+         {
+         }
+     }
+ 
+     add += 1;
+     val = FLASH_ReadByte(add);
+     if (val != BYTE_1(new_val))
+     {
+         /* Error */
+         OperationStatus = FAILED;
+         /* OperationStatus = PASSED, if the data written/read to/from FLASH Program memory is correct */
+         /* OperationStatus = FAILED, if the data written/read to/from FLASH Program memory is corrupted */
+         while (1)
+         {
+         }
+     }
+ 
+     add += 1;
+     val = FLASH_ReadByte(add);
+     if (val != BYTE_0(new_val))
+     {
+         /* Error */
+         OperationStatus = FAILED;
+         /* OperationStatus = PASSED, if the data written/read to/from FLASH Program memory is correct */
+         /* OperationStatus = FAILED, if the data written/read to/from FLASH Program memory is corrupted */
+         while (1)
+         {
+         }
+     }
+ 
+     /* Erase word using Erase byte */
+     add = start_add;
+     for (sub_test_count = 0; sub_test_count < 4; sub_test_count++)
+     {
+         FLASH_EraseByte(add);
+         add += 1;
+     }
+ 
+     /* Verify Erase action */
+     add = start_add;
+     for (sub_test_count = 0; sub_test_count < 4; sub_test_count++)
+     {
+         val = FLASH_ReadByte(add);
+         if (val != 0x00)
+         {
+             /* Error */
+             OperationStatus = FAILED;
+             /* OperationStatus = PASSED, if the data written/read to/from FLASH Program memory is correct */
+             /* OperationStatus = FAILED, if the data written/read to/from FLASH Program memory is corrupted */
+             while (1)
+             {
+             }
+         }
+         add += 1;
+     }
+ 
+     /* Pass */
+     OperationStatus = PASSED;
+     /* OperationStatus = PASSED, if the data written/read to/from FLASH Program memory is correct */
+     /* OperationStatus = FAILED, if the data written/read to/from FLASH Program memory is corrupted */
+     while (1)
+     {
+     }
+ 
+ }
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,69 ----
+ /** @page FLASH_WriteWordOperation FLASH Write word, Erase byte
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    FLASH/FLASH_WriteWordOperation/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the Write word to FLASH operation example 
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description on how to use FLASH Program word mode
+   and Erase byte modes:
+   - Program a word at a specified address (0x9000).
+   - Check program word (Read byte).
+   - Erase word using Erase byte.
+   - Check erase.
+ 
+ 
+   @par Directory content
+ 
+   - FLASH\FLASH_WriteWordOperation\main.c                    Main file containing the "main" function
+   - FLASH\FLASH_WriteWordOperation\stm8l10x_conf.h           Library Configuration file
+   - FLASH\FLASH_WriteWordOperation\stm8l10x_it.c             Interrupt routines source (not used in this example)
+   - FLASH\FLASH_WriteWordOperation\stm8l10x_it.h             Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example  
+   - You can check the value of the bytes at the specified addresses by using the
+     memory window of the used toolchain
+   - The data read from the data memory is compared with the expected values.
+     The result of this comparison is stored in the "OperationStatus" variable.
+  
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,329 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/FLASH/FLASH_WriteWordOperation/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/main.c	2018-04-05 05:29:26.000000000 +0200
***************
*** 0 ****
--- 1,111 ----
+ /**
+   ******************************************************************************
+   * @file    GPIO/GPIO_IOToggle/main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Examples
+   * @{
+   */
+ 
+ /** @addtogroup GPIO_IOToggle
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* define the GPIO port and pins connected to Leds mounted on STM8L101-EVAL board */
+ #define LED_GPIO_PORT  GPIOD
+ #define LED_GPIO_PINS  GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6
+ 
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ void Delay (uint16_t nCount);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* Initialize LEDs mounted on STM8L101-EVAL board */
+   GPIO_Init(LED_GPIO_PORT, LED_GPIO_PINS, GPIO_Mode_Out_PP_Low_Fast);
+ 
+   while (1)
+   {
+     /* Toggle LEDs LD1..LD4 */
+     GPIO_ToggleBits(LED_GPIO_PORT, LED_GPIO_PINS);
+     Delay(0xFFFF);
+   }
+ }
+ 
+ /**
+   * @brief  Inserts a delay time.
+   * @param  nCount: specifies the delay time length.
+   * @retval None
+   */
+ void Delay(__IO uint16_t nCount)
+ {
+   /* Decrement nCount value */
+   while (nCount != 0)
+   {
+     nCount--;
+   }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param  file: pointer to the source file name
+   * @param  line: assert_param error line source number
+   * @retval None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ {
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+   /* Infinite loop */
+   while (1)
+   {}
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,65 ----
+ /** @page GPIO_IOToggle LEDs toggling, Button reading in polling mode
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    AWU/GPIO_IOToggle/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the AWU example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to use the GPIO peripheral to
+   toggle Ports Pins infinitely.
+ 
+ 
+   @par Directory content
+ 
+   - GPIO\GPIO_IOToggle\main.c                   Main file containing the "main" function
+   - GPIO\GPIO_IOToggle\stm8l10x_conf.h          Library Configuration file
+   - GPIO\GPIO_IOToggle\stm8l10x_it.c            Interrupt routines source (not used in this example)
+   - GPIO\GPIO_IOToggle\stm8l10x_it.h            Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - Three leds LD2, LD3 and LD4.
+ 
+      
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example  
+  
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/GPIO/GPIO_IOToggle/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.c	2018-04-05 05:31:32.000000000 +0200
***************
*** 0 ****
--- 1,326 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Master/main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ #include "main.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Examples
+   * @{
+   */
+ 
+ /** @addtogroup I2C_DataExchange
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ extern uint8_t HEADER_ADDRESS_Read = (((SLAVE_ADDRESS & 0xFF00) >> 7) | 0xF1);
+ extern uint8_t HEADER_ADDRESS_Write;
+ /* Private variables ---------------------------------------------------------*/
+ __IO uint8_t Rx_Idx = 0, Tx_Idx = 0;
+ __IO uint8_t NumByteToRead = BUFFERSIZE;
+ __IO uint8_t NumOfBytes = BUFFERSIZE;
+ uint8_t i = 0;
+ __IO uint8_t RxBuffer[BUFFERSIZE];
+ TestStatus TransferStatus1 = FAILED;
+ extern __IO uint8_t TxBuffer[BUFFERSIZE];
+ /* Private function prototypes -----------------------------------------------*/
+ TestStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength);
+ void Delay(__IO uint32_t nCount);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main()
+ {
+ 
+   /* I2C  clock Enable*/
+   CLK_PeripheralClockConfig(CLK_Peripheral_I2C, ENABLE);
+ 
+ #ifdef FAST_I2C_MODE
+   /* system_clock / 1 */
+     CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+ #else
+   /* system_clock / 2 */
+     CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv2);
+ #endif
+ 
+   /* Initialize LEDs mounted on the EVAL board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+ 
+   /* Initialize I2C peripheral */
+   I2C_Init(I2C_SPEED, 0xA0,
+            I2C_DutyCycle_2, I2C_Ack_Enable, I2C_AcknowledgedAddress_7bit);
+ 
+   /* Enable Buffer and Event Interrupt*/
+   I2C_ITConfig((I2C_IT_TypeDef)(I2C_IT_EVT | I2C_IT_BUF) , ENABLE);
+ 
+   enableInterrupts();
+ 
+   /* TXBuffer initialization */
+   for (i = 0; i < BUFFERSIZE; i++)
+     TxBuffer[i] = i;
+ 
+   /* Send START condition */
+   I2C_GenerateSTART(ENABLE);
+   while (NumOfBytes);
+   while (I2C_GetFlagStatus(I2C_FLAG_BUSY));
+ 
+   /* Add a delay to be sure that communication is finished */
+   Delay(0xFFFF);
+ 
+   /*****  reception phase ***/
+   /*  Wait while the bus is busy */
+   while (I2C_GetFlagStatus(I2C_FLAG_BUSY));
+ 
+   /* Send START condition */
+   I2C_GenerateSTART(ENABLE);
+ 
+   /* Test on EV5 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT));
+ 
+ #ifdef TEN_BITS_ADDRESS
+   /* Send Header to Slave for write */
+   I2C_SendData(HEADER_ADDRESS_Write);
+ 
+   /* Test on EV9 and clear it*/
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_ADDRESS10));
+ 
+   /* Send slave Address */
+   I2C_Send7bitAddress((uint8_t)SLAVE_ADDRESS, I2C_Direction_Transmitter);
+ 
+   /* Test on EV6 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
+ 
+   /* Repeated Start */
+   I2C_GenerateSTART(ENABLE);
+ 
+   /* Test on EV5 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT));
+ 
+   /* Send Header to Slave for Read */
+   I2C_SendData(HEADER_ADDRESS_Read);
+ 
+   /* Test on EV6 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
+ 
+ #else
+   /* Send slave Address for write */
+   I2C_Send7bitAddress(SLAVE_ADDRESS, I2C_Direction_Receiver);
+ 
+   /* Test on EV6 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
+ #endif /* TEN_BITS_ADDRESS */
+ 
+   /* While there is data to be read */
+   while (NumByteToRead)
+   {
+ #ifdef SAFE_PROCEDURE
+     if (NumByteToRead != 3) /* Receive bytes from first byte until byte N-3 */
+     {
+       while ((I2C_GetLastEvent() & 0x04) != 0x04); /* Poll on BTF */
+ 
+       /* Read a byte from the Slave */
+       RxBuffer[Rx_Idx] = I2C_ReceiveData();
+ 
+       /* Point to the next location where the byte read will be saved */
+       Rx_Idx++;
+ 
+       /* Decrement the read bytes counter */
+       NumByteToRead--;
+     }
+ 
+     if (NumByteToRead == 3)  /* it remains to read three data: data N-2, data N-1, Data N */
+     {
+       /* Data N-2 in DR and data N -1 in shift register */
+       while ((I2C_GetLastEvent() & 0x04) != 0x04); /* Poll on BTF */
+ 
+       /* Clear ACK */
+       I2C_AcknowledgeConfig(DISABLE);
+ 
+       /* Disable general interrupts */
+       disableInterrupts();
+ 
+       /* Read Data N-2 */
+       RxBuffer[Rx_Idx] = I2C_ReceiveData();
+ 
+       /* Point to the next location where the byte read will be saved */
+       Rx_Idx++;
+ 
+       /* Program the STOP */
+       I2C_GenerateSTOP(ENABLE);
+ 
+       /* Read DataN-1 */
+       RxBuffer[Rx_Idx] = I2C_ReceiveData();
+ 
+       /* Enable General interrupts */
+       enableInterrupts();
+ 
+       /* Point to the next location where the byte read will be saved */
+       Rx_Idx++;
+ 
+       while ((I2C_GetLastEvent() & 0x40) != 0x40); /* Poll on RxNE */
+ 
+       /* Read DataN */
+       RxBuffer[Rx_Idx] = I2C_ReceiveData();
+ 
+       /* Reset the number of bytes to be read by master */
+       NumByteToRead = 0;
+ 
+     }
+ #else
+     if (NumByteToRead == 1)
+     {
+       /* Disable Acknowledgement */
+       I2C_AcknowledgeConfig(DISABLE);
+ 
+       /* Send STOP Condition */
+       I2C_GenerateSTOP(ENABLE);
+ 
+       /* Poll on RxNE Flag */
+       while ((I2C_GetFlagStatus(I2C_FLAG_RXNE) == RESET));
+       /* Read a byte from the Slave */
+       RxBuffer[Rx_Idx] = I2C_ReceiveData();
+ 
+       /* Point to the next location where the byte read will be saved */
+       Rx_Idx++;
+ 
+       /* Decrement the read bytes counter */
+       NumByteToRead--;
+     }
+ 
+     /* Test on EV7 and clear it */
+     if (I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_RECEIVED) )
+     {
+       /* Read a byte */
+       RxBuffer[Rx_Idx] = I2C_ReceiveData();
+ 
+       /* Point to the next location where the byte read will be saved */
+       Rx_Idx++;
+ 
+       /* Decrement the read bytes counter */
+       NumByteToRead--;
+     }
+ #endif /* SAFE_PROCEDURE */
+   }
+ 
+   /* check if sent and received data are not corrupted */
+   TransferStatus1 = Buffercmp((uint8_t*)TxBuffer, (uint8_t*) RxBuffer, BUFFERSIZE);
+ 
+   if (TransferStatus1 != FAILED)
+   {
+     while (1)
+     {
+       /* Toggle LED2*/
+       STM_EVAL_LEDToggle(LED2);
+       /* Insert delay */
+       Delay(0x7FFF);
+     }
+   }
+   else
+   {
+     while (1)
+     {
+       /* Toggle LED4*/
+       STM_EVAL_LEDToggle(LED4);
+       /* Insert delay */
+       Delay(0x7FFF);
+     }
+   }
+ }
+ 
+ /**
+   * @brief  Compares two buffers.
+   * @param  pBuffer1, pBuffer2: buffers to be compared.
+   * @param  BufferLength: buffer's length
+   * @retval PASSED: pBuffer1 identical to pBuffer2
+   *   FAILED: pBuffer1 differs from pBuffer2
+   */
+ TestStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
+ {
+   while (BufferLength--)
+   {
+     if (*pBuffer1 != *pBuffer2)
+     {
+       return FAILED;
+     }
+ 
+     pBuffer1++;
+     pBuffer2++;
+   }
+ 
+   return PASSED;
+ }
+ 
+ /**
+   * @brief  Inserts a delay time.
+   * @param  nCount: specifies the delay time length.
+   * @retval None
+   */
+ void Delay(__IO uint32_t nCount)
+ {
+   for (; nCount != 0; nCount--);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param  file: pointer to the source file name
+   * @param  line: assert_param error line source number
+   * @retval None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ {
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {}
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/main.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,63 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Master/main.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __MAIN_H
+ #define __MAIN_H
+ 
+ /* definition of fast or default standard mode (bus speed up to 400 or 100 kHz) */
+ /* #define FAST_I2C_MODE */
+ 
+ #ifdef FAST_I2C_MODE
+ #define I2C_SPEED 300000
+ #else
+ #define I2C_SPEED 100000
+ #endif
+ 
+ /* definition of 10-bit or default 7-bit slave address */
+ /* #define TEN_BITS_ADDRESS */
+ 
+ #ifdef TEN_BITS_ADDRESS
+ #define SLAVE_ADDRESS  0x330
+ #else
+ #define SLAVE_ADDRESS  0x30
+ #endif
+ 
+ /* This define is used in master receiver */
+ /* Uncomment the line below if you want to use the safe procedure */
+ /* #define SAFE_PROCEDURE */
+ 
+ 
+ #define BUFFERSIZE  3
+ 
+ 
+ typedef enum {FAILED = 0, PASSED = !FAILED} TestStatus;
+ 
+ 
+ #endif /* __MAIN_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Master/stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,411 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Master/stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "main.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Examples
+   * @{
+   */
+ 
+ /** @addtogroup I2C_DataExchange
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ extern uint8_t HEADER_ADDRESS_Write = (((SLAVE_ADDRESS & 0xFF00) >> 7) | 0xF0);
+ extern uint8_t HEADER_ADDRESS_Read;
+ /* Private variables ---------------------------------------------------------*/
+ __IO uint8_t TxBuffer[BUFFERSIZE];
+ extern __IO uint8_t NumOfBytes;
+ extern __IO uint8_t Tx_Idx;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   switch (I2C_GetLastEvent())
+   {
+       /* EV5 */
+     case I2C_EVENT_MASTER_MODE_SELECT :
+ 
+ #ifdef TEN_BITS_ADDRESS
+       /* Send Header to Slave for write */
+       I2C_SendData(HEADER_ADDRESS_Write);
+       break;
+ 
+       /* EV9 */
+     case I2C_EVENT_MASTER_MODE_ADDRESS10:
+       /* Send slave Address for write */
+       I2C_Send7bitAddress((uint8_t)SLAVE_ADDRESS, I2C_Direction_Transmitter);
+       break;
+ #else
+       /* Send slave Address for write */
+       I2C_Send7bitAddress(SLAVE_ADDRESS, I2C_Direction_Transmitter);
+       break;
+ #endif
+       /* EV6 */
+     case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED:
+       if (NumOfBytes != 0)
+       {
+         /* Send the first Data */
+         I2C_SendData(TxBuffer[Tx_Idx++]);
+ 
+         /* Decrement number of bytes */
+         NumOfBytes--;
+       }
+       if (NumOfBytes == 0)
+       {
+         I2C_ITConfig(I2C_IT_BUF, DISABLE);
+       }
+       break;
+ 
+       /* EV8 */
+     case I2C_EVENT_MASTER_BYTE_TRANSMITTING:
+       /* Transmit Data */
+       I2C_SendData(TxBuffer[Tx_Idx++]);
+ 
+       /* Decrement number of bytes */
+       NumOfBytes--;
+ 
+       if (NumOfBytes == 0)
+       {
+         I2C_ITConfig(I2C_IT_BUF, DISABLE);
+       }
+       break;
+ 
+       /* EV8_2 */
+     case I2C_EVENT_MASTER_BYTE_TRANSMITTED:
+       /* Send STOP condition */
+       I2C_GenerateSTOP(ENABLE);
+ 
+       I2C_ITConfig(I2C_IT_EVT, DISABLE);
+       break;
+ 
+     default:
+       break;
+   }
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Master/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,105 ----
+ /** @page I2C_DataExchange I2C1 Master and Slave data exchange   
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    I2C/I2C_TwoBoards/I2C_DataExchange/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the Comparator in interrupt mode example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+ 
+   @par Example description
+ 
+   This is a typical example of how to use the I2C software library to ensure the
+   steps of an I2C communication between slave and master.
+ 
+    This is a two phase example that requires two boards(Master an Slave)  
+    - Phase 1:
+    In master board I2C peripheral is configured in Master Transmitter with Interrupt,
+    where in Slave board I2C peripheral is configured in Slave Receiver with Interrupt.
+    The master will send Data to Slave according to the defined buffer size.
+    
+    - Phase 2: 
+    In master board I2C peripheral is configured in Master Receiver with Polling,
+    where in Slave board I2C peripheral is configured in Slave Transmitter with 
+    Interrupt. 
+    Once the master has initiated the communication (Start condition), the slave
+    will send back the previously received data to the master
+    
+    At the end of the data transfer, a data consistency check will be performed 
+    in master side and in case of mismatch between sent and received data, LED4 
+    will toggle infinitely. Otherwise LED1 will toggle. 
+ 
+   Communication error are handled in Slave side, their occurrence will be signaled
+   by puting On LED2.
+   
+   The "main.h" file allows different possibilities of configuration of this example:
+   - Addressing mode : 7-bit or 10-bit
+   - Safe procedure for master receiver
+   - I2C speed: Fast mode or Standard mode
+   - Buffer size also can be configured
+   and though by choosing the desired configuration within main.h file.
+ 
+ 
+   @par Directory contents
+ 
+   - I2C/I2C_TwoBoards/I2C_DataExchange/X/main.c              Main file
+   - I2C/I2C_TwoBoards/I2C_DataExchange/X/main.h              Header for Main file
+   - I2C/I2C_TwoBoards/I2C_DataExchange/X/stm8l10x_conf.h     Library Configuration file
+   - I2C/I2C_TwoBoards/I2C_DataExchange/X/stm8l10x_it.c       Interrupt routines source
+   - I2C/I2C_TwoBoards/I2C_DataExchange/X/stm8l10x_it.h       Interrupt routines declaration
+   
+   where X stands for Master or Slave directories.
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+     
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+     - Connect I2C1 Master SCL pin (PC.01) to I2C1 Slave SCL (PC.01)  
+     - Connect I2C1 Master SDA pin (PC.00) to I2C1 Slave SDA (PC.00) 
+     - Connect the two-boards grounds together
+ 
+   - Other platform Set-up
+     - Connect I2C1 Master SCL pin (PC.01) to I2C1 Slave SCL (PC.01)  
+     - Connect I2C1 Master SDA pin (PC.00) to I2C1 Slave SDA (PC.00) 
+     - Check that a pull-up resistor (4.7K) is connected on one I2C SDA pin
+     - Check that a pull-up resistor (4.7K) is connected on one I2C SCL pin
+     - Connect the two-boards grounds together
+     @note The pull-up resitors are already implemented on the STM8L1x-EVAL evaluation boards. 
+     
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.c	2018-04-05 05:31:36.000000000 +0200
***************
*** 0 ****
--- 1,120 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Slave/main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ #include "main.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Examples
+   * @{
+   */
+ 
+ /** @addtogroup I2C_DataExchange
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* I2C  clock Enable*/
+   CLK_PeripheralClockConfig(CLK_Peripheral_I2C, ENABLE);
+ 
+   /* system_clock / 1 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+ 
+   /* Initialize LEDs mounted on the EVAL board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+ 
+   I2C_DeInit();
+   /* Initialize I2C peripheral */
+ 
+ #ifdef I2C_slave_7Bits_Address
+   I2C_Init(100000, SLAVE_ADDRESS, I2C_DutyCycle_2, I2C_Ack_Enable, 
+            I2C_AcknowledgedAddress_7bit);
+ #else
+   I2C_Init(100000, SLAVE_ADDRESS, I2C_DutyCycle_2, I2C_Ack_Enable, 
+            I2C_AcknowledgedAddress_10bit);
+ #endif
+ 
+   /* Enable Error Interrupt*/
+   I2C_ITConfig((I2C_IT_TypeDef)(I2C_IT_ERR | I2C_IT_EVT | I2C_IT_BUF), ENABLE);
+ 
+   /* Enable general interrupts */
+   enableInterrupts();
+ 
+   /*Main Loop */
+   while (1)
+   {
+     /* infinite loop */
+   }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param  file: pointer to the source file name
+   * @param  line: assert_param error line source number
+   * @retval None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ {
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {}
+ }
+ #endif
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/main.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,46 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Slave/main.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __MAIN_H
+ #define __MAIN_H
+ 
+ 
+ /* Define I2C Address mode ---------------------------------------------------*/
+ /* Comment the line below if you want to use the 10-bit addressing mode */
+ /* #define I2C_slave_7Bits_Address */
+ 
+ /* Define Slave Address  ---------------------------------------------------*/
+ #ifdef I2C_slave_7Bits_Address
+ #define SLAVE_ADDRESS 0x30
+ #else
+ #define SLAVE_ADDRESS 0x330
+ #endif
+ 
+ #endif /* __MAIN_H*/
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Slave/stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,396 ----
+ /**
+   ******************************************************************************
+   * @file    I2C/I2C_DataExchange/Slave/stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "stm8l101_eval.h"
+ #include "main.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Examples
+   * @{
+   */
+ 
+ /** @addtogroup I2C_DataExchange
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ __IO uint8_t Slave_Buffer_Rx[100];
+ __IO uint8_t Tx_Idx = 0, Rx_Idx = 0;
+ __IO uint16_t Event = 0x00;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+       STM_EVAL_LEDToggle(LED2);
+ 
+       EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+   }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+     /* Read SR2 register to get I2C error */
+   if ((I2C->SR2) != 0)
+   {
+     /* Clears SR2 register */
+     I2C->SR2 = 0;
+ 
+     /* Set LED2 */
+     STM_EVAL_LEDOn(LED2);
+   }
+ 
+   Event = I2C_GetLastEvent();
+   switch (Event)
+   {
+       /******* Slave transmitter ******/
+       /* check on EV1 */
+     case I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED:
+       Tx_Idx = 0;
+       break;
+ 
+       /* check on EV3 */
+     case I2C_EVENT_SLAVE_BYTE_TRANSMITTING:
+       /* Transmit data */
+       I2C_SendData(Slave_Buffer_Rx[Tx_Idx++]);
+       break;
+ 			
+       /******* Slave receiver **********/
+       /* check on EV1*/
+     case I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED:
+       break;
+ 
+       /* Check on EV2*/
+     case I2C_EVENT_SLAVE_BYTE_RECEIVED:
+       Slave_Buffer_Rx[Rx_Idx++] = I2C_ReceiveData();
+       break;
+ 
+       /* Check on EV4 */
+     case (I2C_EVENT_SLAVE_STOP_DETECTED):
+             /* write to CR2 to clear STOPF flag */
+             I2C->CR2 |= I2C_CR2_ACK;
+       break;
+ 
+     default:
+       break;
+   }
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_DataExchange/Slave/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/main.c	2018-04-05 05:31:40.000000000 +0200
***************
*** 0 ****
--- 1,176 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l_eval_i2c_ee.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup I2C_EEPROM
+   * @{
+   */
+ 
+ /* Private define ------------------------------------------------------------*/
+ #define sEE_WRITE_ADDRESS1        0x50
+ #define sEE_READ_ADDRESS1         0x50
+ #define BUFFER_SIZE1             (countof(Tx1_Buffer)-1)
+ #define BUFFER_SIZE2             (countof(Tx2_Buffer)-1)
+ #define sEE_WRITE_ADDRESS2       (sEE_WRITE_ADDRESS1 + BUFFER_SIZE1)
+ #define sEE_READ_ADDRESS2        (sEE_READ_ADDRESS1 + BUFFER_SIZE1)
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ typedef enum {FAILED = 0, PASSED = !FAILED} TestStatus;
+ /* Private macro -------------------------------------------------------------*/
+ #define countof(a) (sizeof(a) / sizeof(*(a)))
+ 
+ /* Private variables ---------------------------------------------------------*/
+ uint8_t Tx1_Buffer[] = " STM8L I2C Firmware Library EEPROM driver example";
+ uint8_t Tx2_Buffer[] = "/* buffer transfer into address sEE_WRITE_ADDRESS2 */";
+ uint8_t Rx1_Buffer[BUFFER_SIZE1], Rx2_Buffer[BUFFER_SIZE2];
+ __IO  TestStatus TransferStatus1 = FAILED, TransferStatus2 = FAILED;
+ __IO  uint16_t NumDataRead = 0;
+ /* Private function prototypes -----------------------------------------------*/
+ TestStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength);
+ /* Private functions ---------------------------------------------------------*/
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main()
+ {
+   /* Initialization of the clock */
+   /* Clock divider to HSI/1 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+   
+ 
+   /* Initialize the I2C EEPROM driver ---------------------------------------*/
+   sEE_Init();
+ 
+   /* First write in the memory followed by a read of the written data --------*/
+   /* Write on I2C EEPROM from EEPROM_WRITE_ADDRESS1 */
+   sEE_WriteBuffer(Rx1_Buffer, sEE_WRITE_ADDRESS1, BUFFER_SIZE1);
+ 
+   /* Set the Number of data to be read */
+   NumDataRead = BUFFER_SIZE1;
+ 
+   /* Read from I2C EEPROM from EEPROM_READ_ADDRESS1 */
+   sEE_ReadBuffer(Rx1_Buffer, sEE_READ_ADDRESS1, (uint16_t*)&NumDataRead);
+   
+   /* Wait till transfer is complete */
+   while (NumDataRead > 0)
+   {}
+   
+   /* Check if the data written to the memory is read correctly */
+   TransferStatus1 = Buffercmp(Tx1_Buffer, Rx1_Buffer, BUFFER_SIZE1);
+   /* TransferStatus1 = PASSED, if the transmitted and received data 
+      to/from the EEPROM are the same */
+   /* TransferStatus1 = FAILED, if the transmitted and received data 
+      to/from the EEPROM are different */
+   
+ 
+   /* Second write in the memory followed by a read of the written data -------*/
+   /* Write on I2C EEPROM from sEE_WRITE_ADDRESS2 */
+   sEE_WriteBuffer(Tx2_Buffer, sEE_WRITE_ADDRESS2, BUFFER_SIZE2); 
+ 
+   /* Wait for EEPROM standby state */
+   sEE_WaitEepromStandbyState();  
+   
+   /* Set the Number of data to be read */
+   NumDataRead = BUFFER_SIZE2;  
+   
+   /* Read from I2C EEPROM from sEE_READ_ADDRESS2 */
+   sEE_ReadBuffer(Rx2_Buffer, sEE_READ_ADDRESS2, (uint16_t *)(&NumDataRead));
+ 
+   /* Wait till transfer is complete */
+   while (NumDataRead > 0)
+   {}
+   
+   /* Check if the data written to the memory is read correctly */
+   TransferStatus2 = Buffercmp(Tx2_Buffer, Rx2_Buffer, BUFFER_SIZE2);
+   /* TransferStatus2 = PASSED, if the transmitted and received data 
+      to/from the EEPROM are the same */
+   /* TransferStatus2 = FAILED, if the transmitted and received data 
+      to/from the EEPROM are different */
+   
+   /* Free all used resources */
+   sEE_DeInit();
+ 
+   while (1)
+   {}
+ }
+ 
+ /**
+   * @brief  Compares two buffers.
+   * @param  pBuffer1, pBuffer2: buffers to be compared.
+   * @param  BufferLength: buffer's length
+   * @retval PASSED: pBuffer1 identical to pBuffer2
+   *         FAILED: pBuffer1 differs from pBuffer2
+   */
+ TestStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
+ {
+   while(BufferLength--)
+   {
+     if(*pBuffer1 != *pBuffer2)
+     {
+       return FAILED;
+     }
+     
+     pBuffer1++;
+     pBuffer2++;
+   }
+ 
+   return PASSED;  
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,92 ----
+ /** @page I2C_EEPROM Write & Read data in an I2C EEPROM memory
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    I2C/I2C_EEPROM/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the I2C and M24C64 EEPROM communication example.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+ This firmware provides a basic example of how to use the I2C firmware library and
+ an associate I2C EEPROM driver to communicate with an I2C EEPROM device (here the
+ example is interfacing with M24C64 EEPROM)
+ 
+ I2C peripheral is configured in Master transmitter during write operation and in
+ Master receiver during read operation from I2C EEPROM. 
+ 
+ The speed is set to 200kHz and can be configured by modifying the related define
+ in stm8l_eval_i2c_ee.h file.
+ 
+ For M24C64 devices all the memory is accessible through the two-bytes 
+ addressing mode and need to define block addresses. In this case, only the physical 
+ address has to be defined (according to the address pins (E0,E1 and E2) connection).
+ This address is defined in stm8l_eval_i2c_ee.h (default is 0xA0: E0, E1 and E2 
+ tied to ground). 
+ The EEPROM addresses where the program start the write and the read operations 
+ is defined in the main.c file. 
+ 
+ First, the content of Tx1_Buffer is written to the EEPROM_WriteAddress1 and the
+ written data is read. The written and the read buffers data are then compared.
+ Following the read operation, the program waits that the EEPROM reverts to its 
+ Standby state. A second write operation is, then, performed and this time, Tx2_Buffer
+ is written to EEPROM_WriteAddress2, which represents the address just after the last 
+ written one in the first write. After completion of the second write operation, the 
+ written data is read. The contents of the written and the read buffers are compared.
+ 
+ 
+   @par Directory content
+ 
+   - I2C\I2C_EEPROM\main.c                    Main file containing the "main" function
+   - I2C\I2C_EEPROM\stm8l10x_conf.h           Library Configuration file
+   - I2C\I2C_EEPROM\stm8l10x_it.c             Interrupt routines source (not used in this example)
+   - I2C\I2C_EEPROM\stm8l10x_it.h             Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - This example uses the I2C EEPROM already available on STM8L1x-EVAL board.
+      - Before Running the example make sure that JP8 is fitted.
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Add the required file:
+     - stm8l_eval_i2c_ee.c  (under Utilities\STM8L101_EVAL\Common)  
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - The test will compare the sent buffer & received buffer data.
+ 
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,332 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/I2C/I2C_EEPROM/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/main.c	2018-04-05 05:29:44.000000000 +0200
***************
*** 0 ****
--- 1,152 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup IRTIM_SignalGeneration
+   * @{
+   */
+ 
+ /* Private defines -----------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void TIM2_Config(void);
+ static void TIM3_Config(void);
+ static void IRTIM_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+ 
+   /* ----------------TIM2 configuration--------------- */
+   TIM2_Config();
+   
+   /* ----------------TIM3 configuration--------------- */
+   TIM3_Config();  
+   
+   /* ----------------IRTIM configuration--------------- */
+ 
+   IRTIM_Config();
+   
+   while(1)
+   {}
+ }
+ 
+ /**
+   * @brief  Configure timer2 peripheral  
+   * @param  None
+   * @retval None
+   */
+ static void TIM2_Config(void)
+ {  
+   /* Enable TIM2 clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+   
+   /* DeInit TIM2 */
+   TIM2_DeInit();
+   
+   /* TIM2 Time base configuration */
+   TIM2_TimeBaseInit(TIM2_Prescaler_1, TIM2_CounterMode_Up, 0xFFFF);
+   
+   /* TIM2 channel 1 configuration */
+   TIM2_OC1Init(TIM2_OCMode_PWM1, TIM2_OutputState_Enable, 0x7FFF, TIM2_OCPolarity_High, TIM2_OCIdleState_Reset);
+   
+   /* TIM2 Counter Enable */
+   TIM2_Cmd(ENABLE);
+   TIM2_CtrlPWMOutputs(ENABLE);
+ }
+ 
+ /**
+   * @brief  Configure timer3 peripheral  
+   * @param  None
+   * @retval None
+   */
+ static void TIM3_Config(void)
+ {
+   /* Enable TIM3 clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE);
+   
+   /* DeInit TIM3 */
+   TIM3_DeInit();
+   
+   /* TIM3 Time base configuration */
+   TIM3_TimeBaseInit(TIM3_Prescaler_16, TIM3_CounterMode_Up, 0xFFFF);
+   
+   /* TIM3 channel 1 configuration */
+   TIM3_OC1Init(TIM3_OCMode_PWM1, TIM3_OutputState_Enable, 0x7FFF, TIM3_OCPolarity_High, TIM3_OCIdleState_Reset);
+   
+   /* TIM3 Counter Enable */
+   TIM3_Cmd(ENABLE);
+   TIM3_CtrlPWMOutputs(ENABLE);
+ }
+ 
+ /**
+   * @brief  Configure IRTIM peripheral  
+   * @param  None
+   * @retval None
+   */
+ static void IRTIM_Config(void)
+ {
+   /* DeInit IRTIM */
+   IRTIM_DeInit();
+   
+   /* Enable IRTIM */
+   IRTIM_Cmd(ENABLE);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,64 ----
+ /** @page IRTIM_SignalGeneration generating a Infra Red signal
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    IRTIM/IRTIM_SignalGeneration/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the IRTIM example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example provides a short description of how to use the IRTIM peripheral:
+   - Initialization and configuration of the TIM2 and TIM3 
+   - Enabling IRTIM
+  
+ 
+   @par Directory content
+ 
+   - IRTIM\IRTIM_SignalGeneration\main.c                  Main file containing the "main" function
+   - IRTIM\IRTIM_SignalGeneration\stm8l10x_conf.h         Library Configuration file
+   - IRTIM\IRTIM_SignalGeneration\stm8l10x_it.c           Interrupt routines source (not used in this example)
+   - IRTIM\IRTIM_SignalGeneration\stm8l10x_it.h           Interrupt routines declaration
+ 
+   
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example  
+   - Connect PA0 to the osciloscope, an IRTIM signal is generated
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IRTIM/IR_SignalGeneration/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/main.c	2018-04-05 05:29:52.000000000 +0200
***************
*** 0 ****
--- 1,150 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /**
+   * @addtogroup ITC_SoftwarePriority
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void EXTI_Config(void);
+ static void ITC_Config(void);
+ void Delay (uint16_t nCount);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* Initialize Leds mounted on evaluation board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   
+   /* Initialize key button and joystick on evaluation board */
+   /* Key button */
+   STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+   /* Joystick */
+   STM_EVAL_PBInit(BUTTON_DOWN, BUTTON_MODE_EXTI);
+ 
+   /* ----------------EXTI configuration--------------- */
+   EXTI_Config();  
+   
+   /* ----------------ITC configuration--------------- */
+   /*
+     Change the software priority between button and joystick:
+     - By hardware the Pin_4 (joystick_down) has a higher priority than Pin_5 (key button)
+     - We configure the Pin_5 (key) to have a higher sw priority than Pin_4 (joystick_down)
+   */
+   ITC_Config();
+   
+   enableInterrupts();
+ 
+   /* LEDs are ON together */
+   STM_EVAL_LEDOn(LED2);
+   STM_EVAL_LEDOn(LED3);
+  
+   while (1)
+   {}
+ }
+ 
+ /**
+   * @brief  Configure EXTI to define key and joystick interrupt sensitivity  
+   * @param  None
+   * @retval None
+   */
+ static void EXTI_Config(void)
+ {
+   /* Initialize the Interrupt sensitivity for key and joystick */
+   EXTI_SetPinSensitivity(EXTI_Pin_4, EXTI_Trigger_Falling_Low);
+   EXTI_SetPinSensitivity(EXTI_Pin_5, EXTI_Trigger_Falling_Low);
+ }
+ 
+ /**
+   * @brief  Configure ITC to change the software priority between button and joystick  
+   * @param  None
+   * @retval None
+   */
+ static void ITC_Config(void)
+ {
+   /*
+     Change the software priority between button and joystick:
+     - By hardware the Pin_4 (joystick_down) has a higher priority than Pin_5 (key button)
+     - We configure the Pin_5 (key) to have a higher sw priority than Pin_4 (joystick_down)
+   */
+   ITC_SetSoftwarePriority(EXTI4_IRQn, ITC_PriorityLevel_1); /* joystick */
+   ITC_SetSoftwarePriority(EXTI5_IRQn, ITC_PriorityLevel_2); /* key = higher sw priority */
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/readme.txt	2014-10-21 14:13:22.000000000 +0200
***************
*** 0 ****
--- 1,81 ----
+ /** @page ITC_SoftwarePriority Changing software priority on two external interrupt lines
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    ITC/ITC_SoftwarePriority/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the ITC software priority example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example shows how to use the ITC peripheral.
+   It does the following:
+   - Configures two I/Os in output push-pull for driving two LEDs
+   - Configures two I/Os in input with interrupt for reading two buttons
+   - Configures the two External Interrupt lines in Falling edge + Low level (GPIOA Pin4 and Pin5)
+   - Changes software priority between GPIOA Pin4 and Pin5 (GPIOA Pin5 has a higher sw priority)
+ 
+ 
+   @par Directory content
+ 
+   - ITC\ITC_SoftwarePriority\main.c                       Main file containing the "main" function
+   - ITC\ITC_SoftwarePriority\stm8l10x_conf.h              Library Configuration file
+   - ITC\ITC_SoftwarePriority\stm8l10x_it.c                Interrupt routines source
+   - ITC\ITC_SoftwarePriority\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - Two leds LED2 and LED3,
+      - Key push button
+      - Joystick Down button.
+  
+   
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - The LED2 and LED3 are ON per default
+   - When the Joystick Down button is pressed, the LED2 toggles and LED3 is OFF
+   - When the Key button is pressed, the LED3 toggles and LED2 is OFF
+   - Play with the Button and the Joystick Down in order to see which one has
+     the highest priority:
+      - press and maintain the Joystick Down Button -> LED2 toggles, LED3 OFF
+      - Continue pressing the Joystick Down Button and press the Key button -> 
+         LED3 toggles instead, LED2 OFF (Key has the priority)
+         If you do the reverse, you can see that the KEY button is not interrupted by
+         the Joystick button as configured by hardware.
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_conf.h	2014-10-21 14:13:22.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.c	2014-10-21 14:13:22.000000000 +0200
***************
*** 0 ****
--- 1,345 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "stm8l101_eval.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ extern void Delay (uint16_t nCount);
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+   /* LED3 off */
+   STM_EVAL_LEDOff(LED3);
+   
+   /* LED2 toggles */
+   STM_EVAL_LEDToggle(LED2);
+   Delay((uint16_t)0xFFFF);
+   
+   /* Clear interrupt pending bit */
+   EXTI_ClearITPendingBit(EXTI_IT_Pin4);
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+   /* LED2 off */
+   STM_EVAL_LEDOff(LED2);
+   
+   /* LED3 toggles */
+   STM_EVAL_LEDToggle(LED3);
+   Delay((uint16_t)0xFFFF);
+   
+   /* Clear interrupt pending bit */  
+   EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/ITC/ITC_SoftwarePriority/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/main.c	2018-04-05 05:29:18.000000000 +0200
***************
*** 0 ****
--- 1,250 ----
+ /**
+   ******************************************************************************
+   * @file    IWDG/IWDG_Example/main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /**
+   * @addtogroup IWDG_Example
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ 
+ /* Private define ------------------------------------------------------------*/
+ #define RELOAD_VALUE   254
+ #define LSI_PERIOD_NUMBERS         10
+ 
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ __IO uint32_t LsiFreq = 0;
+ extern __IO uint32_t Capture;
+ extern __IO uint16_t CaptureState;
+ /* Private function prototypes -----------------------------------------------*/
+ static void CLK_Config(void);
+ static void GPIO_Config(void);
+ static void IWDG_Config(void);
+ uint32_t LSIMeasurment(void);
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* Clock Configuration */
+   CLK_Config(); 
+   
+   /* GPIO Configuration */
+   GPIO_Config();
+ 
+   /* Check if the system has resumed from IWDG reset */
+   if(RST_GetFlagStatus(RST_FLAG_IWDGF) != RESET)
+   {
+     /* IWDGF flag set */
+     /* Turn on LED2 */
+     STM_EVAL_LEDOn(LED2);
+ 
+     /* Clear IWDGF Flag */
+     RST_ClearFlag(RST_FLAG_IWDGF);
+   }
+   else
+   {
+     /* IWDGF flag is not set */
+     /* Turn off LED2 */
+     STM_EVAL_LEDOff(LED2);
+   }
+ 
+   /* get measured LSI frequency */
+   LsiFreq = LSIMeasurment();  
+   
+    /* IWDG Configuration */
+   IWDG_Config();
+   
+   while(1)
+   {
+     /* Reload IWDG counter */
+     IWDG_ReloadCounter();  
+   }
+ }
+ 
+ /**
+   * @brief  Configure system clock to run at 16Mhz
+   * @param  None
+   * @retval None
+   */
+ static void CLK_Config(void)
+ {
+   /* High Speed Internal clock divider: 1 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+ 
+   /* Enable TIM2 clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+   
+   /* Enable AWU clock to get write access for AWU registers */
+   CLK_PeripheralClockConfig(CLK_Peripheral_AWU, ENABLE);
+ }
+ 
+ /**
+   * @brief  Initialize LED1 and Key Button mounted on the evaluation board
+   * @param  None
+   * @retval None
+   */
+ static void GPIO_Config(void) 
+ {
+   /* Configure LED2 */
+   STM_EVAL_LEDInit(LED2);
+ 
+   /* Configure Key button */
+   STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+   
+   /* enable interrupts */
+   enableInterrupts();
+ }
+ 
+ /**
+   * @brief  Configures the IWDG to generate a Reset if it is not refreshed at the
+   *         correct time. 
+   * @param  None
+   * @retval None
+   */
+ static void IWDG_Config(void)
+ {
+   /* Enable IWDG (the LSI oscillator will be enabled by hardware) */
+   IWDG_Enable();
+   
+   /* IWDG timeout equal to 214 ms (the timeout may varies due to LSI frequency
+      dispersion) */
+   /* Enable write access to IWDG_PR and IWDG_RLR registers */
+   IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
+   
+   /* IWDG configuration: IWDG is clocked by LSI = 38KHz */
+   IWDG_SetPrescaler(IWDG_Prescaler_32);
+   
+   /* IWDG timeout equal to 214.7 ms (the timeout may varies due to LSI frequency dispersion) */
+   /* IWDG timeout = (RELOAD_VALUE + 1) * Prescaler / LSI 
+                   = (254 + 1) * 32 / 38 000 
+                   = 214.7 ms */
+   IWDG_SetReload((uint8_t)RELOAD_VALUE);
+   
+   /* Reload IWDG counter */
+   IWDG_ReloadCounter();
+ }
+ 
+ /**
+   * @brief Measure the LSI frequency using timer IC1 and update the calibration registers.
+   * @note   It is recommended to use a timer clock frequency of at least 10MHz in order 
+   *         to obtain a better in the LSI frequency measurement.
+   * @param  None
+   * @retval None
+   */
+ uint32_t LSIMeasurment(void)
+ {
+   uint8_t icfilter = 0;
+   uint32_t LSICurrentPeriod = 0;
+   uint32_t LSIMeasuredFrequencyCumul = 0;
+   uint16_t LSIMeasuredFrequency = 0;
+   uint8_t LSIPeriodCounter = 0;
+ 
+   /* Enable the LSI measurement: LSI clock connected to timer Input Capture 1 */
+   AWU->CSR |= AWU_CSR_MSR;
+ 
+   /* TIM2 configuration: Input Capture mode */
+   /* Configure TIM2 channel 1 in input capture mode */
+   /* The signal in input is divided and not filtered */
+   /* The capture occurs when a rising edge is detected on TIM2 channel 1 */
+   TIM2_ICInit(TIM2_Channel_1, TIM2_ICPolarity_Rising, TIM2_ICSelection_DirectTI,
+               TIM2_ICPSC_Div8, icfilter);
+ 
+   LSIPeriodCounter = 0;
+   /**************************** START of LSI Measurement **********************/
+   while(LSIPeriodCounter <= LSI_PERIOD_NUMBERS)
+   {
+     CaptureState = 1;
+     /* Clear all TM2 flags */
+     TIM2_GenerateEvent(TIM2_EventSource_Update);
+     TIM2->SR1 = 0;
+     TIM2->SR2 = 0;
+     /* Enable capture 1 interrupt */
+     TIM2_ITConfig(TIM2_IT_CC1, ENABLE);
+     /* Enable TIM2 */
+     TIM2_Cmd(ENABLE);
+ 
+     while (CaptureState != 255);
+ 
+     if(LSIPeriodCounter != 0)
+     {
+       /* Compute the frequency value */
+       LSICurrentPeriod = (uint32_t) 8 * (HSI_VALUE / Capture);
+       /* Add the current frequency to previous cumulation */
+       LSIMeasuredFrequencyCumul = LSIMeasuredFrequencyCumul + LSICurrentPeriod;
+     }
+     LSIPeriodCounter++;
+   }
+   /**************************** END of LSI Measurement ************************/
+ 
+   /* Compute the average of LSI frequency value */
+   LSIMeasuredFrequency = (uint16_t) (LSIMeasuredFrequencyCumul / LSI_PERIOD_NUMBERS);
+ 
+   /* Disable the LSI measurement: LSI clock disconnected from timer Input Capture 1 */
+   AWU->CSR &= (uint8_t)(~AWU_CSR_MSR);
+   
+   /* Return the LSI frequency */
+   return (uint16_t)(LSIMeasuredFrequency);
+ 
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param  file: pointer to the source file name
+   * @param  line: assert_param error line source number
+   * @retval None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ {
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+   /* Infinite loop */
+   while (1)
+   {}
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,87 ----
+ /** @page IWDG_Example IWDG refreshing, IWDG Reset
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    IWDG/IWDG_Example/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the IWDG example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+   
+  This example shows how to update at regular period the IWDG reload counter and 
+  how to simulate a software fault generating an MCU IWDG reset on expiry of a 
+  programmed time period.
+ 
+  The IWDG timeout is set to 214 ms (the timeout may varies due to LSI frequency 
+  dispersion).
+ 
+  First, the TIM2 timer is configured to measure the LSI frequency as the 
+  LSI is internally connected to it, in order to adjust the IWDG clock.
+  The IWDG reload counter is configured to obtain 214ms according to the 
+  measured LSI frequency.
+ 
+ 
+  The Key button is used to generate an interrupt that will simulate a software 
+  failure by pressing it.
+  In the ISR, a trap instruction is executed generating a TRAP interrupt containing
+  an infinite loop and preventing to return to main program (the IWDG reload counter 
+  is no more refreshed).
+  As a result, when the IWDG counter reaches 00h, the IWDG reset occurs.
+  If the IWDG reset is generated, after the system resumes from reset, LED2 turns on.
+ 
+  If the Key button is not pressed, the IWDG counter is refreshed in an infinite loop
+  and there is no IWDG reset.
+ 
+   @par Directory content
+ 
+   - IWDG\IWDG_Example\main.c                       Main file containing the "main" function
+   - IWDG\IWDG_Example\stm8l10x_conf.h              Library Configuration file
+   - IWDG\IWDG_Example\stm8l10x_it.c                Interrupt routines source 
+   - IWDG\IWDG_Example\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1-EVAL Set-up
+      - LD2
+      - Key push button.
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - If you press the key button, a Reset occurs and LED2 turn on.
+     
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,375 ----
+ /**
+   ******************************************************************************
+   * @file    IWDG/IWDG_Example/stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main Interrupt Service Routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "stm8l101_eval.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Examples
+   * @{
+   */
+ 
+ /** @addtogroup IWDG_Example
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ uint16_t IC1ReadValue1 = 0, IC1ReadValue2 = 0;
+ __IO uint16_t CaptureState = 0;
+ __IO uint32_t Capture = 0;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ #ifdef _COSMIC_
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(NonHandledInterrupt, 0)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+     /* Go to infinite loop when the trap occurs */
+   while(1)
+   {}
+ }
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler, 1)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ /**
+   * @brief  Auto Wake Up Interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler, 4)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+   /* Clear Interrupt pending bit */
+   EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+   
+   trap();
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+   /* In order to detect unexpected events during development,
+      it is recommended to set a breakpoint on the following instruction.
+   */
+ }
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   /* If the Input capture 1 interrupt has been occured: new period occured */
+   if(TIM2_GetITStatus(TIM2_IT_CC1) != RESET)
+   {
+     /* Clear TIM2 Capture Compare 1 interrupt pending bit */
+     TIM2_ClearITPendingBit(TIM2_IT_CC1);
+     if (CaptureState == 1)
+     {
+       /* Get the Input Capture value */
+       IC1ReadValue1 = TIM2_GetCapture1();
+       CaptureState = 2;
+     }
+     else if (CaptureState == 2)
+     {
+       /* Get the Input Capture value */
+       IC1ReadValue2 = TIM2_GetCapture1();
+       /* Disable TIM2 */
+       TIM2_Cmd(DISABLE);
+       TIM2_ITConfig(TIM2_IT_CC1, DISABLE);
+ 
+       /* Capture computation */
+       if (IC1ReadValue2 > IC1ReadValue1)
+       {
+         Capture = (IC1ReadValue2 - IC1ReadValue1);
+       }
+       else
+       {
+         Capture = ((0xFFFF - IC1ReadValue1) + IC1ReadValue2);
+       }
+       /* capture of two values is done */
+       CaptureState = 255;
+     }
+   }  
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/IWDG/IWDG_Example/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/Library_Examples.html ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/Library_Examples.html
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/Library_Examples.html	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/Library_Examples.html	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,1238 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+ <html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+   
+   <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+ 
+   
+   <link rel="File-List" href="Library_Examples_files/filelist.xml">
+ 
+   
+   <link rel="Edit-Time-Data" href="Library_Examples_files/editdata.mso"><!--[if !mso]>
+ 
+ </style>
+ 
+ <![endif]--><title>STM8L10x Standard Peripherals Library: Peripheral&#8217;s examples</title><!--[if gte mso 9]><xml>
+ 
+  <o:DocumentProperties>
+ 
+   <o:Author>STMicroelectronics</o:Author>
+ 
+   <o:LastAuthor>Youssef GHANNOUCHI</o:LastAuthor>
+ 
+   <o:Revision>11</o:Revision>
+ 
+   <o:TotalTime>17</o:TotalTime>
+ 
+   <o:Created>2010-04-21T19:58:00Z</o:Created>
+ 
+   <o:LastSaved>2010-12-31T12:23:00Z</o:LastSaved>
+ 
+   <o:Pages>5</o:Pages>
+ 
+   <o:Words>3074</o:Words>
+ 
+   <o:Characters>17524</o:Characters>
+ 
+   <o:Company>STMicroelectronics</o:Company>
+ 
+   <o:Lines>146</o:Lines>
+ 
+   <o:Paragraphs>41</o:Paragraphs>
+ 
+   <o:CharactersWithSpaces>20557</o:CharactersWithSpaces>
+ 
+   <o:Version>12.00</o:Version>
+ 
+  </o:DocumentProperties>
+ 
+ </xml><![endif]-->
+ 
+ 
+   
+ 
+   
+ 
+   
+   <link rel="themeData" href="Library_Examples_files/themedata.thmx">
+ 
+   
+   <link rel="colorSchemeMapping" href="Library_Examples_files/colorschememapping.xml"><!--[if gte mso 9]><xml>
+ 
+  <w:WordDocument>
+ 
+   <w:Zoom>90</w:Zoom>
+ 
+   <w:SpellingState>Clean</w:SpellingState>
+ 
+   <w:GrammarState>Clean</w:GrammarState>
+ 
+   <w:TrackMoves>false</w:TrackMoves>
+ 
+   <w:TrackFormatting/>
+ 
+   <w:ValidateAgainstSchemas/>
+ 
+   <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
+ 
+   <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
+ 
+   <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
+ 
+   <w:DoNotPromoteQF/>
+ 
+   <w:LidThemeOther>EN-US</w:LidThemeOther>
+ 
+   <w:LidThemeAsian>X-NONE</w:LidThemeAsian>
+ 
+   <w:LidThemeComplexScript>X-NONE</w:LidThemeComplexScript>
+ 
+   <w:Compatibility>
+ 
+    <w:BreakWrappedTables/>
+ 
+    <w:SnapToGridInCell/>
+ 
+    <w:WrapTextWithPunct/>
+ 
+    <w:UseAsianBreakRules/>
+ 
+    <w:DontGrowAutofit/>
+ 
+    <w:SplitPgBreakAndParaMark/>
+ 
+    <w:DontVertAlignCellWithSp/>
+ 
+    <w:DontBreakConstrainedForcedTables/>
+ 
+    <w:DontVertAlignInTxbx/>
+ 
+    <w:Word11KerningPairs/>
+ 
+    <w:CachedColBalance/>
+ 
+   </w:Compatibility>
+ 
+   <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
+ 
+   <m:mathPr>
+ 
+    <m:mathFont m:val="Cambria Math"/>
+ 
+    <m:brkBin m:val="before"/>
+ 
+    <m:brkBinSub m:val="&#45;-"/>
+ 
+    <m:smallFrac m:val="off"/>
+ 
+    <m:dispDef/>
+ 
+    <m:lMargin m:val="0"/>
+ 
+    <m:rMargin m:val="0"/>
+ 
+    <m:defJc m:val="centerGroup"/>
+ 
+    <m:wrapIndent m:val="1440"/>
+ 
+    <m:intLim m:val="subSup"/>
+ 
+    <m:naryLim m:val="undOvr"/>
+ 
+   </m:mathPr></w:WordDocument>
+ 
+ </xml><![endif]--><!--[if gte mso 9]><xml>
+ 
+  <w:LatentStyles DefLockedState="false" DefUnhideWhenUsed="false"
+ 
+   DefSemiHidden="false" DefQFormat="false" LatentStyleCount="267">
+ 
+   <w:LsdException Locked="false" QFormat="true" Name="Normal"/>
+ 
+   <w:LsdException Locked="false" QFormat="true" Name="heading 1"/>
+ 
+   <w:LsdException Locked="false" QFormat="true" Name="heading 2"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="heading 3"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="heading 4"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="heading 5"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="heading 6"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="heading 7"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="heading 8"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="heading 9"/>
+ 
+   <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
+ 
+    QFormat="true" Name="caption"/>
+ 
+   <w:LsdException Locked="false" QFormat="true" Name="Title"/>
+ 
+   <w:LsdException Locked="false" Priority="1" Name="Default Paragraph Font"/>
+ 
+   <w:LsdException Locked="false" QFormat="true" Name="Subtitle"/>
+ 
+   <w:LsdException Locked="false" QFormat="true" Name="Strong"/>
+ 
+   <w:LsdException Locked="false" QFormat="true" Name="Emphasis"/>
+ 
+   <w:LsdException Locked="false" Priority="99" Name="No List"/>
+ 
+   <w:LsdException Locked="false" Priority="99" SemiHidden="true"
+ 
+    Name="Placeholder Text"/>
+ 
+   <w:LsdException Locked="false" Priority="1" QFormat="true" Name="No Spacing"/>
+ 
+   <w:LsdException Locked="false" Priority="60" Name="Light Shading"/>
+ 
+   <w:LsdException Locked="false" Priority="61" Name="Light List"/>
+ 
+   <w:LsdException Locked="false" Priority="62" Name="Light Grid"/>
+ 
+   <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1"/>
+ 
+   <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2"/>
+ 
+   <w:LsdException Locked="false" Priority="65" Name="Medium List 1"/>
+ 
+   <w:LsdException Locked="false" Priority="66" Name="Medium List 2"/>
+ 
+   <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1"/>
+ 
+   <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2"/>
+ 
+   <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3"/>
+ 
+   <w:LsdException Locked="false" Priority="70" Name="Dark List"/>
+ 
+   <w:LsdException Locked="false" Priority="71" Name="Colorful Shading"/>
+ 
+   <w:LsdException Locked="false" Priority="72" Name="Colorful List"/>
+ 
+   <w:LsdException Locked="false" Priority="73" Name="Colorful Grid"/>
+ 
+   <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="61" Name="Light List Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="99" SemiHidden="true" Name="Revision"/>
+ 
+   <w:LsdException Locked="false" Priority="34" QFormat="true"
+ 
+    Name="List Paragraph"/>
+ 
+   <w:LsdException Locked="false" Priority="29" QFormat="true" Name="Quote"/>
+ 
+   <w:LsdException Locked="false" Priority="30" QFormat="true"
+ 
+    Name="Intense Quote"/>
+ 
+   <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 1"/>
+ 
+   <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="61" Name="Light List Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 2"/>
+ 
+   <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="61" Name="Light List Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 3"/>
+ 
+   <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="61" Name="Light List Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 4"/>
+ 
+   <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="61" Name="Light List Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 5"/>
+ 
+   <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="61" Name="Light List Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 6"/>
+ 
+   <w:LsdException Locked="false" Priority="19" QFormat="true"
+ 
+    Name="Subtle Emphasis"/>
+ 
+   <w:LsdException Locked="false" Priority="21" QFormat="true"
+ 
+    Name="Intense Emphasis"/>
+ 
+   <w:LsdException Locked="false" Priority="31" QFormat="true"
+ 
+    Name="Subtle Reference"/>
+ 
+   <w:LsdException Locked="false" Priority="32" QFormat="true"
+ 
+    Name="Intense Reference"/>
+ 
+   <w:LsdException Locked="false" Priority="33" QFormat="true" Name="Book Title"/>
+ 
+   <w:LsdException Locked="false" Priority="37" SemiHidden="true"
+ 
+    UnhideWhenUsed="true" Name="Bibliography"/>
+ 
+   <w:LsdException Locked="false" Priority="39" SemiHidden="true"
+ 
+    UnhideWhenUsed="true" QFormat="true" Name="TOC Heading"/>
+ 
+  </w:LatentStyles>
+ 
+ </xml><![endif]-->
+ 
+ 
+   
+   <style>
+ <!--
+  /* Font Definitions */
+  @font-face
+ 	{font-family:"Cambria Math";
+ 	panose-1:2 4 5 3 5 4 6 3 2 4;
+ 	mso-font-charset:1;
+ 	mso-generic-font-family:roman;
+ 	mso-font-format:other;
+ 	mso-font-pitch:variable;
+ 	mso-font-signature:0 0 0 0 0 0;}
+ @font-face
+ 	{font-family:Calibri;
+ 	panose-1:2 15 5 2 2 2 4 3 2 4;
+ 	mso-font-charset:0;
+ 	mso-generic-font-family:swiss;
+ 	mso-font-pitch:variable;
+ 	mso-font-signature:-1610611985 1073750139 0 0 159 0;}
+ @font-face
+ 	{font-family:Tahoma;
+ 	panose-1:2 11 6 4 3 5 4 4 2 4;
+ 	mso-font-charset:0;
+ 	mso-generic-font-family:swiss;
+ 	mso-font-pitch:variable;
+ 	mso-font-signature:1627400839 -2147483648 8 0 66047 0;}
+ @font-face
+ 	{font-family:Verdana;
+ 	panose-1:2 11 6 4 3 5 4 4 2 4;
+ 	mso-font-charset:0;
+ 	mso-generic-font-family:swiss;
+ 	mso-font-pitch:variable;
+ 	mso-font-signature:536871559 0 0 0 415 0;}
+  /* Style Definitions */
+  p.MsoNormal, li.MsoNormal, div.MsoNormal
+ 	{mso-style-unhide:no;
+ 	mso-style-qformat:yes;
+ 	mso-style-parent:"";
+ 	margin:0in;
+ 	margin-bottom:.0001pt;
+ 	mso-pagination:widow-orphan;
+ 	font-size:12.0pt;
+ 	font-family:"Times New Roman","serif";
+ 	mso-fareast-font-family:"Times New Roman";}
+ h2
+ 	{mso-style-unhide:no;
+ 	mso-style-qformat:yes;
+ 	mso-style-link:"Heading 2 Char";
+ 	mso-style-next:Normal;
+ 	margin-top:12.0pt;
+ 	margin-right:0in;
+ 	margin-bottom:3.0pt;
+ 	margin-left:0in;
+ 	mso-pagination:widow-orphan;
+ 	page-break-after:avoid;
+ 	mso-outline-level:2;
+ 	font-size:14.0pt;
+ 	font-family:"Arial","sans-serif";
+ 	mso-fareast-font-family:"Times New Roman";
+ 	mso-fareast-theme-font:minor-fareast;
+ 	font-weight:bold;
+ 	font-style:italic;}
+ a:link, span.MsoHyperlink
+ 	{mso-style-unhide:no;
+ 	color:blue;
+ 	text-decoration:underline;
+ 	text-underline:single;}
+ a:visited, span.MsoHyperlinkFollowed
+ 	{mso-style-unhide:no;
+ 	color:blue;
+ 	text-decoration:underline;
+ 	text-underline:single;}
+ p
+ 	{mso-style-unhide:no;
+ 	mso-margin-top-alt:auto;
+ 	margin-right:0in;
+ 	mso-margin-bottom-alt:auto;
+ 	margin-left:0in;
+ 	mso-pagination:widow-orphan;
+ 	font-size:12.0pt;
+ 	font-family:"Times New Roman","serif";
+ 	mso-fareast-font-family:"Times New Roman";}
+ p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
+ 	{mso-style-unhide:no;
+ 	mso-style-link:"Balloon Text Char";
+ 	margin:0in;
+ 	margin-bottom:.0001pt;
+ 	mso-pagination:widow-orphan;
+ 	font-size:8.0pt;
+ 	font-family:"Tahoma","sans-serif";
+ 	mso-fareast-font-family:"Times New Roman";}
+ span.Heading2Char
+ 	{mso-style-name:"Heading 2 Char";
+ 	mso-style-unhide:no;
+ 	mso-style-locked:yes;
+ 	mso-style-link:"Heading 2";
+ 	mso-ansi-font-size:13.0pt;
+ 	mso-bidi-font-size:13.0pt;
+ 	font-family:"Cambria","serif";
+ 	mso-ascii-font-family:Cambria;
+ 	mso-ascii-theme-font:major-latin;
+ 	mso-fareast-font-family:"Times New Roman";
+ 	mso-fareast-theme-font:major-fareast;
+ 	mso-hansi-font-family:Cambria;
+ 	mso-hansi-theme-font:major-latin;
+ 	mso-bidi-font-family:"Times New Roman";
+ 	mso-bidi-theme-font:major-bidi;
+ 	color:#4F81BD;
+ 	mso-themecolor:accent1;
+ 	font-weight:bold;}
+ span.BalloonTextChar
+ 	{mso-style-name:"Balloon Text Char";
+ 	mso-style-unhide:no;
+ 	mso-style-locked:yes;
+ 	mso-style-link:"Balloon Text";
+ 	mso-ansi-font-size:8.0pt;
+ 	mso-bidi-font-size:8.0pt;
+ 	font-family:"Tahoma","sans-serif";
+ 	mso-ascii-font-family:Tahoma;
+ 	mso-hansi-font-family:Tahoma;
+ 	mso-bidi-font-family:Tahoma;}
+ span.SpellE
+ 	{mso-style-name:"";
+ 	mso-spl-e:yes;}
+ span.GramE
+ 	{mso-style-name:"";
+ 	mso-gram-e:yes;}
+ .MsoChpDefault
+ 	{mso-style-type:export-only;
+ 	mso-default-props:yes;
+ 	font-size:10.0pt;
+ 	mso-ansi-font-size:10.0pt;
+ 	mso-bidi-font-size:10.0pt;}
+ @page WordSection1
+ 	{size:8.5in 11.0in;
+ 	margin:1.0in 1.25in 1.0in 1.25in;
+ 	mso-header-margin:.5in;
+ 	mso-footer-margin:.5in;
+ 	border:solid windowtext 1.0pt;
+ 	padding:24.0pt 24.0pt 24.0pt 24.0pt;
+ 	mso-border-shadow:yes;
+ 	mso-paper-source:0;}
+ div.WordSection1
+ 	{page:WordSection1;}
+  /* List Definitions */
+  @list l0
+ 	{mso-list-id:258562952;
+ 	mso-list-template-ids:2064838472;}
+ @list l0:level1
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0B7;
+ 	mso-level-tab-stop:.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Symbol;}
+ @list l0:level2
+ 	{mso-level-tab-stop:1.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l0:level3
+ 	{mso-level-tab-stop:1.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l0:level4
+ 	{mso-level-tab-stop:2.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l0:level5
+ 	{mso-level-tab-stop:2.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l0:level6
+ 	{mso-level-tab-stop:3.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l0:level7
+ 	{mso-level-tab-stop:3.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l0:level8
+ 	{mso-level-tab-stop:4.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l0:level9
+ 	{mso-level-tab-stop:4.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l1
+ 	{mso-list-id:270430823;
+ 	mso-list-template-ids:1098384336;}
+ @list l1:level1
+ 	{mso-level-number-format:bullet;
+ 	mso-level-text:\F0B7;
+ 	mso-level-tab-stop:.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;
+ 	mso-ansi-font-size:10.0pt;
+ 	font-family:Symbol;}
+ @list l2
+ 	{mso-list-id:1594822952;
+ 	mso-list-template-ids:-1474416604;}
+ @list l2:level1
+ 	{mso-level-tab-stop:.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level2
+ 	{mso-level-tab-stop:1.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level3
+ 	{mso-level-tab-stop:1.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level4
+ 	{mso-level-tab-stop:2.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level5
+ 	{mso-level-tab-stop:2.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level6
+ 	{mso-level-tab-stop:3.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level7
+ 	{mso-level-tab-stop:3.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level8
+ 	{mso-level-tab-stop:4.0in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l2:level9
+ 	{mso-level-tab-stop:4.5in;
+ 	mso-level-number-position:left;
+ 	text-indent:-.25in;}
+ @list l3
+ 	{mso-list-id:1918007674;
+ 	mso-list-template-ids:414992870;}
+ ol
+ 	{margin-bottom:0in;}
+ ul
+ 	{margin-bottom:0in;}
+ -->
+   </style><!--[if gte mso 10]>
+ 
+ <style>
+ 
+  /* Style Definitions */
+ 
+  table.MsoNormalTable
+ 
+ 	{mso-style-name:"Table Normal";
+ 
+ 	mso-tstyle-rowband-size:0;
+ 
+ 	mso-tstyle-colband-size:0;
+ 
+ 	mso-style-noshow:yes;
+ 
+ 	mso-style-priority:99;
+ 
+ 	mso-style-qformat:yes;
+ 
+ 	mso-style-parent:"";
+ 
+ 	mso-padding-alt:0in 5.4pt 0in 5.4pt;
+ 
+ 	mso-para-margin:0in;
+ 
+ 	mso-para-margin-bottom:.0001pt;
+ 
+ 	mso-pagination:widow-orphan;
+ 
+ 	font-size:10.0pt;
+ 
+ 	font-family:"Times New Roman","serif";}
+ 
+ </style>
+ 
+ <![endif]--><!--[if gte mso 9]><xml>
+ 
+  <o:shapedefaults v:ext="edit" spidmax="32770"/>
+ 
+ </xml><![endif]--><!--[if gte mso 9]><xml>
+ 
+  <o:shapelayout v:ext="edit">
+ 
+   <o:idmap v:ext="edit" data="1"/>
+ 
+  </o:shapelayout></xml><![endif]-->
+   <meta content="MCD Application Team" name="author"></head>
+ <body link="blue" vlink="blue">
+ <div class="WordSection1">
+ <p class="MsoNormal"><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><o:p>&nbsp;</o:p></span></p>
+ <div align="center">
+ <table class="MsoNormalTable" style="width: 796.5pt;" border="0" cellpadding="0" cellspacing="0" width="1062">
+   <tbody>
+     <tr style="">
+       <td style="padding: 0in; width: 715.5pt;" valign="top" width="954">
+       
+       <table class="MsoNormalTable" style="width: 631.5pt;" border="0" cellpadding="0" cellspacing="0" width="842">
+         <tbody>
+           <tr style="">
+             <td style="padding: 1.5pt;">
+             <p class="MsoNormal" style="text-align: center;" align="center"><strong><span style="font-size: 18pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;; color: rgb(51, 102, 255);">STM8L10x
+ Standard Peripherals&nbsp;Library: <i>Peripheral&#8217;s examples</i></span></strong><strong><span style="font-size: 18pt; color: rgb(51, 102, 255);"><o:p></o:p></span></strong></p>
+             <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><o:p>&nbsp;</o:p></span></p>
+             <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;">Copyright
+ 2014 STMicroelectronics<o:p></o:p></span></p>
+             <p style="text-align: center;" class="MsoNormal" align="center"><span style="font-size: 10pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><img style="border: 0px solid ; width: 86px; height: 65px;" alt="" id="_x0000_i1033" src="../../_htmresc/st_logo.png"></span><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><o:p></o:p></span></p>
+             </td>
+           </tr>
+         </tbody>
+       </table>
+       <p class="MsoNormal"><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;; display: none;"><o:p>&nbsp;</o:p></span></p>
+       <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+         <tbody>
+           <tr>
+             <td style="padding: 0in;" valign="top">
+             <table class="MsoNormalTable" style="width: 790.5pt;" border="0" cellpadding="0" cellspacing="5" width="1054">
+               <tbody>
+                 <tr style="height: 31.5pt;">
+                   <td style="padding: 0in; width: 842pt; height: 31.5pt;" valign="top" width="1123">
+                   <table style="width: 620.25pt;" class="MsoNormalTable" border="0" cellpadding="0" cellspacing="0" width="827">
+                     <tbody>
+                       <tr style="">
+                         <td style="padding: 1.5pt; width: 827.7pt;" width="1104">
+                         <p><span style="font-size: 10pt; font-family: Arial;">The STM8L10x Standard Peripherals&nbsp;library provides a rich set of examples
+         covering the main features of each peripheral.&nbsp;<br>Almost
+ exmaples run on all supported STM8L10x devices.<br>All the examples are
+         independent from the software toolchain.&nbsp;These examples run on
+         STMicroelectronics STM8L101-EVAL&nbsp;evaluation board and can be
+         easily tailored to any other supported device and development board.&nbsp;</span></p><span style="font-size: 10pt; font-family: Arial;">Only source files are provided for each example and user can tailor the
+         provided&nbsp;project template to run the selected example with his
+         preferred toolchain.</span>
+                         <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;">How to
+ proceed?</span><span style=""><o:p></o:p></span></h2>
+ 
+                         
+                         
+                         <ul>
+ </ul>
+                         
+                         <ul>
+ 
+                           
+                           </ul>
+                         <ul>
+                           <li>
+                             <p><small><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;">Copy the files <span style="font-weight: bold;">main.c</span>, <span style="font-weight: bold;">main.h</span> (if exists), <span style="font-weight: bold;">stm8l10x_it.c</span>, <span style="font-weight: bold;">s</span>, <span style="font-weight: bold;">stm8l10x_it.h</span>, <span style="font-weight: bold;">stm8l10_conf.h</span> and any other source files from the specified example to your toolchain folder under <span style="font-weight: bold;">Project\STM8L10x_StdPeriph_Templates</span>. This project folder contains already all toolchain files needed for creating projects for STM8L10x microcontrollers.</span></small></p>
+                           </li>
+                         </ul>
+                         <ul>
+                           <li>
+                             <p><small><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;">Open your preferred toolchain<br>
+                             </span></small></p>
+                           </li>
+                         </ul>
+                         <ul>
+                           <li>
+                             <p><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><small>If needed, add in the project list the additional files required to run the example (refer to your example readme file)<br>
+                             </small></span></p>
+                           </li>
+                           <li>
+                             <p><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><small>Rebuild all files and load your image into the target memory</small></span></p>
+                           </li>
+                           <li>
+                             <p><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><small>Run the example</small></span></p>
+                           </li>
+                         </ul>
+ <ul>
+ 
+                         
+                         </ul>
+ 
+                         <span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"></span>
+ 
+                         <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span class="GramE"><span style="font-size: 12pt; color: white;">STM8L10x&nbsp; StdPeriph</span></span><span style="font-size: 12pt; color: white;">_Lib Examples</span><span style=""><o:p></o:p></span></h2>
+                         <p><span style="font-size: 10pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;">The
+ package contains the following examples:</span></p>
+                         <p class="MsoNormal" style="text-align: center;" align="center"><font size="+2"><font size="+3"><a href="#ADC"><span style="font-size: 7.5pt;"></span><span style="font-size: 7.5pt;"></span></a></font><span style="font-size: 7.5pt;"> <a href="#AWU"><span style="text-decoration: underline;">AWU</span> </a>- <a href="#BEEP"><span style="text-decoration: underline;">BEEP</span> </a>- <a href="#COMP">COMP</a> - <a href="#CLK"><span style="text-decoration: underline;">CLK</span></a> - <a href="#EXTI">EXTI</a> - <a href="#FLASH">FLASH</a>
+ -&nbsp;<a href="#GPIO">GPIO</a> - <a href="#I2C">I2C</a> - <a href="#ITC"><span style="text-decoration: underline;">ITC</span>&nbsp;</a> - <a href="#IWDG">IWDG</a> -<a href="#RST"> <span style="text-decoration: underline;">RST</span></a>
+ -<a href="#Lib_DEBUG"><span class="SpellE"></span></a> <a href="#SPI">SPI</a> - <a href="#TIM">TIM</a> - <a href="#USART">USART</a> - <a href="#WFE">WFE</a></span></font><font style="color: rgb(51, 51, 255);" size="+2"><span style="font-size: 7.5pt;"> -&nbsp;</span></font><a href="#IRTIM"><font style="color: rgb(51, 51, 255);" size="+2"><span style="font-size: 7.5pt;">IRTIM</span></font></a></p><p class="MsoNormal" style="text-align: center;" align="center"><big><big><big><br>
+                         </big></big></big>
+                         
+                         </p><div align="center">
+ 
+ <table style="border-collapse: collapse; background-color: transparent; width: 751px;" class="MsoNormalTable" border="0" cellpadding="0" cellspacing="0">
+  <tbody><tr style="height: 16.5pt;">
+   <td rowspan="2" style="border-style: solid; border-color: blue windowtext black blue; border-width: 1.5pt 1pt 1pt 1.5pt; padding: 0in 5.4pt; background: rgb(102, 102, 153) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 16.5pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-align: center; line-height: normal;" align="center"><b><span style="font-size: 14pt; color: white;">IP/Module<o:p></o:p></span></b></p>
+   </td>
+   <td colspan="2" style="border-style: solid solid solid none; border-color: blue blue windowtext -moz-use-text-color; border-width: 1.5pt 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(102, 102, 153) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 674.55pt; height: 16.5pt;" nowrap="nowrap" width="899">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-align: center; line-height: normal;" align="center"><b><span style="font-size: 14pt; color: white;">Example<o:p></o:p></span></b></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 16.5pt;">
+   <td style="border-style: none solid none none; border-color: -moz-use-text-color windowtext -moz-use-text-color -moz-use-text-color; border-width: medium 1pt medium medium; padding: 0in 5.4pt; background: rgb(102, 102, 153) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 16.5pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-align: center; line-height: normal;" align="center"><b><span style="font-size: 12pt; color: white;">Name<o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid none none; border-color: -moz-use-text-color blue -moz-use-text-color -moz-use-text-color; border-width: medium 1.5pt medium medium; padding: 0in 5.4pt; background: rgb(102, 102, 153) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 16.5pt;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-align: center; line-height: normal;" align="center"><b><span style="font-size: 12pt; color: white;">Brief Description<o:p></o:p></span></b></p>
+   </td><td></td>
+  </tr>
+  
+  <tr style="height: 62pt;">
+   <td style="border-style: solid solid none; border-color: white white white blue; border-width: 1pt 1pt medium 1.5pt; width: 76.45pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 62pt; background-color: rgb(0, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style="">&nbsp;<span style="font-family: Calibri;">AWU</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: white; border-width: medium 1pt 1pt medium; width: 248.55pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 62pt; background-color: rgb(0, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">AWU_ActiveHaltMode</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 62pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal; font-family: Calibri;"><span style=""><a name="AWU"></a>This example provides a short description of how
+   to use the AWU peripheral:<o:p></o:p></span></p>
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">&nbsp;Pressing
+   Key button will enter MCU in Halt mode.</span><br style="font-family: Calibri;">
+   <span style="font-family: Calibri;">&nbsp;The MCU will then exit from halt mode
+   thanks to the AWU. The wake up time depends&nbsp;
+   on the AWU peripheral configuration.</span> <o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 48.5pt;">
+   <td style="border-style: solid; border-color: white white white blue; border-width: 1pt 1pt 1pt 1.5pt; width: 76.45pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 48.5pt; background-color: rgb(153, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">&nbsp;BEEP</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 48.5pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">BEEP_3SignalsGeneration</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 48.5pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="BEEP"></a>This example provides a short description of how
+   to use the BEEP peripheral: </span><br style="font-family: Calibri;"><span style="font-family: Calibri;">
+   Each time the key button is pressed the Beeper frequency changes and a
+   corresponding </span><span style="font-family: Calibri;">led will be switched on.</span> <o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 45.75pt;">
+   <td style="border-style: none solid; border-color: white white white blue; border-width: medium 1pt medium 1.5pt; width: 76.45pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 45.75pt; background-color: rgb(0, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">&nbsp;</span><b style="font-family: Calibri;">COMP</b><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 45.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">COMP_Interrupt</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 45.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="COMP"></a>This
+ example is demonstrating the comparator interrupt capability on the
+ detection of an input voltage applied to the COMP2 Channel 3,&nbsp;
+ higher than its reference .</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 15.75pt;">
+   <td style="border-style: solid; border-color: white white white blue; border-width: 1pt 1pt 1pt 1.5pt; width: 76.45pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 15.75pt; background-color: rgb(153, 204, 255);" rowspan="1">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">&nbsp;CLK</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: white white white -moz-use-text-color; border-width: medium 1pt 1pt medium; width: 248.55pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 15.75pt; background-color: rgb(153, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">&nbsp; CLK_MasterClock</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 15.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="CLK"></a>This example demonstrates the different Master Prescaler configuartions, using the joystick available on the evaluation board.</span> <o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  
+  
+  <tr style="height: 45.75pt;">
+   <td style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext blue; border-width: medium 1pt 1pt 1.5pt; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 45.75pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">EXTI</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 45.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">EXTI_IOControl</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 45.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="EXTI"></a>&nbsp;This
+   example provides a short description of how to use the EXTI peripheral</span><span style="font-family: Calibri;"></span><span style="font-family: Calibri;"></span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 29.6pt;">
+   <td rowspan="3" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext blue; border-width: medium 1pt 1pt 1.5pt; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 29.6pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">FLASH</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 29.6pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">FLASH_ByteReadWriteOperation</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 29.6pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="FLASH"></a>This example provides a short description on how
+   to use FLASH &nbsp;Read/Write/Erase operations on byte</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 15.75pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 15.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">FLASH_WriteWordOperation</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 15.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example provides a short description on how
+   to use FLASH Program word mode</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30.75pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">FLASH_DataProgram</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example provides a description of how to use
+   FLASH Write/Erase Block mode </span><span style="font-family: Calibri;">on data eeprom memory.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30.75pt;">
+   <td style="border-style: none solid; border-color: -moz-use-text-color windowtext -moz-use-text-color blue; border-width: medium 1pt medium 1.5pt; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 30.75pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">GPIO</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">GPIO_IOToggle</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="GPIO"></a>This example provides a short description of how
+   to use the GPIO peripheral to toggle Ports Pins infinitely</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30pt;">
+   <td rowspan="2" style="border-style: solid; border-color: white white white blue; border-width: 1pt 1pt 1pt 1.5pt; width: 76.45pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 30pt; background-color: rgb(153, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">&nbsp;I2C</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid none none; border-color: -moz-use-text-color windowtext -moz-use-text-color -moz-use-text-color; border-width: medium 1pt medium medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">I2C_EEPROM</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid none none; border-color: -moz-use-text-color blue -moz-use-text-color -moz-use-text-color; border-width: medium 1.5pt medium medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="I2C"></a>This firmware provides a basic example of how to
+   use the I2C firmware library and an associate I2C EEPROM driver to
+   communicate with an I2C EEPROM device</span> <o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 45.75pt;">
+   <td style="border-style: solid solid solid none; border-color: white white white -moz-use-text-color; border-width: 1pt 1pt 1pt medium; width: 248.55pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 45.75pt; background-color: rgb(153, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">&nbsp; I2C_DataExchange</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: solid solid solid none; border-color: white; border-width: 1pt 1.5pt 1pt medium; width: 426pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 45.75pt; font-family: Calibri; background-color: rgb(153, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This is a typical example of how to use the I2C
+   software library to ensure the steps of an I2C communication between slave
+   Receiver/transmitter and master transmitter/receiver using interrupts.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30.75pt;">
+   <td style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext blue; border-width: medium 1pt 1pt 1.5pt; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 30.75pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">ITC</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">ITC_SoftwarePriority</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="ITC"></a>This example shows how to change the software
+   priority of two external &nbsp;interrupt
+   lines to allow nested interrupt management.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 45.75pt;">
+   <td style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext blue; border-width: medium 1pt 1pt 1.5pt; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 45.75pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">IWDG</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 45.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">IWDG_Example</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 45.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="IWDG"></a>This example shows how to update at regular period
+   the IWDG reload counter and how to simulate a software fault generating an
+   MCU IWDG reset on expiry of a programmed time period.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30.75pt;">
+   <td style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext blue; border-width: medium 1pt 1pt 1.5pt; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 30.75pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">RST</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">RST_IllegalOpcode</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="RST"></a>This example provides a short description of how
+   to generate detect and manage an illegal opcode reset.</span> <o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 60pt;">
+   <td rowspan="3" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext blue; border-width: medium 1pt 1pt 1.5pt; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 60pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><b><span style=""><span style="font-family: Calibri;">SPI</span><o:p></o:p></span></b></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 60pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">SPI_MSD</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 60pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="SPI"></a>This example provides a short description of how
+   to make a communication (Write &amp; Read data) between the SPI and a MicroSD
+   memory card like the one present on the STM8L101-EVAL evaluation board.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 45pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 45pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">SPI_FullDuplexUART</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 45pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example provides a short description of how
+   to make a master/slave full duplex communication between the SPI and the
+   UART1, the last is configured in master synchronous mode.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 45.75pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 45.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">SPI_SimplexLCD</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 45.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example provides a short description of how
+   to use the SPI firmware library in order to communicate with a monochrome LCD
+   like the one present on the STM8L101-EVAL eval-board by the mean of the
+   associated eval LCD driver.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  
+  
+  
+  <tr style="height: 30pt;">
+   <td style="background-color: rgb(0, 204, 255);" rowspan="7"><span style=""><span style="font-family: Calibri;">&nbsp;<span style="font-weight: bold;">TIM</span></span></span></td><td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">TIM2_InputCapture</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="TIM"></a>This example shows how to configure the TIM1 peripheral
+   to capture the internal clock source (LSI).</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">TIM2_SinewaveGeneration</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example shows how to use TIM1 to get the
+   variation in sine wave frequency from 65Hz to 45Hz.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">TIM2_OCActiveMode</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example shows how to configure the TIM2
+   peripheral to generate three different&nbsp;</span><span style="font-family: Calibri;">signals with three different delays</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 37.25pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 37.25pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">TIM2_OCInactiveMode</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 37.25pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example shows how to configure the TIM2 peripheral
+   to generate 3 different signals with 3 different delays.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">TIM2_PWM_DutyCycleConfiguration</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example shows how to configure the TIM2
+   peripheral in Pulse Width Modulation mode (PWM).</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 45pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 45pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">TIM4_TimeBase</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 45pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">&nbsp;This
+   example provides a short description of how to use the TIM4 peripheral to
+   generate time base equal to 1 ms. In this example a "Delay"
+   function is implemented based on the TIM4 time base.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 30.75pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">TIM3_SynchronisationwithTIM4</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example provides a short description of how
+   to use the TIM3 peripheral synchronized by TIM4. TIM3 is configured as a
+   slave of TIM4.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  
+  <tr style="height: 30pt;">
+   <td style="background-color: rgb(153, 204, 255);" rowspan="4"><span style=""><span style="font-family: Calibri;">&nbsp;<span style="font-weight: bold;">USART</span></span></span></td><td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">USART_HyperTerminalInterrupt</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="USART"></a>This example provides a description of how to use
+   the UART1 Transmit and Receive </span><span style="font-family: Calibri;">interrupts to communicate with the hyperterminal.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  
+  
+  
+  <tr style="height: 30pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">USART_MultiProcessor</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example provides a description of how to use
+   the UART1 in&nbsp;multi-processor mode.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 40pt;">
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color windowtext windowtext -moz-use-text-color; border-width: medium 1pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 40pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">USART_Printf</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid solid none; border-color: -moz-use-text-color blue windowtext -moz-use-text-color; border-width: medium 1.5pt 1pt medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 40pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;" class="MsoNormal">This example shows how to retarget the C library
+   printf function to the UART. </span><br style="font-family: Calibri;" class="MsoNormal"><span style="font-family: Calibri;" class="MsoNormal">
+   This implementation output the printf message on the Hyperterminal using UART.</span><o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  
+  <tr style="height: 30.75pt;">
+   <td style="border-style: none solid none none; border-color: -moz-use-text-color windowtext -moz-use-text-color -moz-use-text-color; border-width: medium 1pt medium medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 248.55pt; height: 30.75pt;" width="331">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">USART_Synchronous</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: none solid none none; border-color: -moz-use-text-color blue -moz-use-text-color -moz-use-text-color; border-width: medium 1.5pt medium medium; padding: 0in 5.4pt; background: rgb(153, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 426pt; height: 30.75pt; font-family: Calibri;" width="568">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">This example provides a basic communication
+   between UART1 (Synchronous mode) </span><span style="font-family: Calibri;">and SPI using flags.</span> <o:p></o:p></span></p>
+   </td><td></td>
+  </tr>
+  <tr style="height: 16.5pt;">
+   <td style="border-style: none solid solid; border-color: -moz-use-text-color windowtext blue blue; border-width: medium 1pt 1.5pt 1.5pt; padding: 0in 5.4pt; background: rgb(0, 204, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 76.45pt; height: 16.5pt;" width="102">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">&nbsp;</span><b style="font-family: Calibri;">WFE</b><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: solid solid solid none; border-color: white white blue; border-width: 1pt 1pt 1.5pt medium; width: 248.55pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 16.5pt; background-color: rgb(0, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; text-indent: 11pt; line-height: normal;"><span style=""><span style="font-family: Calibri;">&nbsp;WFE_WakeUp</span><o:p></o:p></span></p>
+   </td>
+   <td style="border-style: solid solid solid none; border-color: white white blue; border-width: 1pt 1.5pt 1.5pt medium; width: 426pt; background-image: none; background-repeat: repeat; background-attachment: scroll; padding-top: 0in; padding-bottom: 0in; height: 16.5pt; font-family: Calibri; background-color: rgb(0, 204, 255);">
+   <p class="MsoNormal" style="margin-bottom: 0.0001pt; line-height: normal;"><span style=""><span style="font-family: Calibri;"><a name="WFE"></a>How the CPU operates when entering &nbsp;in wait for event mode.</span> <o:p></o:p></span></p>
+   </td><td></td>
+  </tr><tr><td style="background-color: rgb(153, 204, 255);"><span style=""><span style="font-family: Calibri;">&nbsp; <span style="font-weight: bold;">&nbsp;IRTIM</span></span></span></td><td style="background-color: rgb(153, 204, 255);"><span style=""><span style="font-family: Calibri;">&nbsp; &nbsp; &nbsp;IR_SignalGeneration</span></span></td><td style="background-color: rgb(153, 204, 255);"><span style=""><span style="font-family: Calibri;"><a name="IRTIM"></a>How to use the IRTIM peripheral.</span></span></td><td></td></tr>
+ </tbody></table>
+ </div>
+                         <span style="font-size: 7.5pt;"></span><p class="MsoNormal" style="text-align: right;" align="right"><span style="font-size: 7.5pt;"><a href="Library_Examples.html">Back to Top</a></span><span style="font-size: 10pt;"><o:p></o:p></span></p>
+ 
+ 
+                         
+                         
+                         
+                         
+                         
+                         
+                         
+                         
+                         </td>
+                       </tr>
+                     </tbody>
+                   </table>
+                   <p class="MsoNormal"><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;; display: none;"><o:p>&nbsp;</o:p></span></p>
+                   <table class="MsoNormalTable" style="width: 96.22%; top: 1547px;" border="0" cellpadding="0" cellspacing="5" width="96%">
+                     <tbody>
+                       <tr style="">
+                         <td style="border-style: solid none none; border-color: -moz-use-text-color; border-width: 1pt medium medium; padding: 0in; width: 98.84%;" width="98%">
+                         <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><o:p>&nbsp;</o:p></span></p>
+                         <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;">For
+ complete documentation on STM8 8-bit Microcontrollers
+ platform visit&nbsp;<span style="color: blue;"><a href="http://www.st.com/internet/mcu/class/1738.jsp" target="_blank">www.st.com</a></span><o:p></o:p></span></p>
+                         </td>
+                       </tr>
+                     </tbody>
+                   </table>
+                   <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><o:p></o:p></span></p>
+                   </td>
+                 </tr>
+               </tbody>
+             </table>
+             </td>
+           </tr>
+         </tbody>
+       </table>
+       <p class="MsoNormal"><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><o:p></o:p></span></p>
+       </td>
+     </tr>
+   </tbody>
+ </table>
+ </div>
+ <p class="MsoNormal"><span style="font-family: &quot;Arial&quot;,&quot;sans-serif&quot;;"><o:p>&nbsp;</o:p></span></p>
+ </div>
+ 
+ </body></html>
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/Release_Notes.html ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/Release_Notes.html
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/Release_Notes.html	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/Release_Notes.html	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,349 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+ <html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+ 
+ 
+ 
+ <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+ <link rel="File-List" href="Release_Notes%20%28package%29_files/filelist.xml">
+ <link rel="Edit-Time-Data" href="Release_Notes%20%28package%29_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>STM8L10x Standard Peripherals Library Examples Release Notes</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>tguilhot</o:LastAuthor> <o:Revision>145</o:Revision> <o:TotalTime>461</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2010-12-13T14:14:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>358</o:Words> <o:Characters>2045</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>17</o:Lines> <o:Paragraphs>4</o:Paragraphs> <o:CharactersWithSpaces>2399</o:CharactersWithSpaces> <o:Version>11.9999</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:View>Normal</w:View> <w:SpellingState>Clean</w:SpellingState> <w:GrammarState>Clean</w:GrammarState> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:Compatibility> <w:UseFELayout/> </w:Compatibility> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->
+ 
+ 
+ 
+ <style>
+ <!--
+ /* Font Definitions */
+ @font-face
+ {font-family:Wingdings;
+ panose-1:5 0 0 0 0 0 0 0 0 0;
+ mso-font-charset:2;
+ mso-generic-font-family:auto;
+ mso-font-pitch:variable;
+ mso-font-signature:0 268435456 0 0 -2147483648 0;}
+ @font-face
+ {font-family:"MS Mincho";
+ panose-1:2 2 6 9 4 2 5 8 3 4;
+ mso-font-alt:"Arial Unicode MS";
+ mso-font-charset:128;
+ mso-generic-font-family:roman;
+ mso-font-format:other;
+ mso-font-pitch:fixed;
+ mso-font-signature:1 134676480 16 0 131072 0;}
+ @font-face
+ {font-family:Verdana;
+ panose-1:2 11 6 4 3 5 4 4 2 4;
+ mso-font-charset:0;
+ mso-generic-font-family:swiss;
+ mso-font-pitch:variable;
+ mso-font-signature:536871559 0 0 0 415 0;}
+ @font-face
+ {font-family:"\@MS Mincho";
+ panose-1:0 0 0 0 0 0 0 0 0 0;
+ mso-font-charset:128;
+ mso-generic-font-family:roman;
+ mso-font-format:other;
+ mso-font-pitch:fixed;
+ mso-font-signature:1 134676480 16 0 131072 0;}
+ /* Style Definitions */
+ p.MsoNormal, li.MsoNormal, div.MsoNormal
+ {mso-style-parent:"";
+ margin:0cm;
+ margin-bottom:.0001pt;
+ mso-pagination:widow-orphan;
+ font-size:12.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"Times New Roman";}
+ h1
+ {mso-margin-top-alt:auto;
+ margin-right:0cm;
+ mso-margin-bottom-alt:auto;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ mso-outline-level:1;
+ font-size:24.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"MS Mincho";
+ font-weight:bold;}
+ h2
+ {mso-style-next:Normal;
+ margin-top:12.0pt;
+ margin-right:0cm;
+ margin-bottom:3.0pt;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ page-break-after:avoid;
+ mso-outline-level:2;
+ font-size:14.0pt;
+ font-family:Arial;
+ mso-fareast-font-family:"MS Mincho";
+ font-weight:bold;
+ font-style:italic;}
+ h3
+ {mso-margin-top-alt:auto;
+ margin-right:0cm;
+ mso-margin-bottom-alt:auto;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ mso-outline-level:3;
+ font-size:13.5pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"MS Mincho";
+ font-weight:bold;}
+ a:link, span.MsoHyperlink
+ {color:blue;
+ text-decoration:underline;
+ text-underline:single;}
+ a:visited, span.MsoHyperlinkFollowed
+ {color:blue;
+ text-decoration:underline;
+ text-underline:single;}
+ p
+ {mso-margin-top-alt:auto;
+ margin-right:0cm;
+ mso-margin-bottom-alt:auto;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ font-size:12.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"Times New Roman";}
+ @page Section1
+ {size:612.0pt 792.0pt;
+ margin:72.0pt 90.0pt 72.0pt 90.0pt;
+ mso-header-margin:36.0pt;
+ mso-footer-margin:36.0pt;
+ mso-paper-source:0;}
+ div.Section1
+ {page:Section1;}
+ /* List Definitions */
+ @list l0
+ {mso-list-id:1315182333;
+ mso-list-template-ids:555131286;}
+ @list l0:level1
+ {mso-level-tab-stop:36.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level2
+ {mso-level-tab-stop:72.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level3
+ {mso-level-tab-stop:108.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level4
+ {mso-level-tab-stop:144.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level5
+ {mso-level-tab-stop:180.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level6
+ {mso-level-tab-stop:216.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level7
+ {mso-level-tab-stop:252.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level8
+ {mso-level-tab-stop:288.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level9
+ {mso-level-tab-stop:324.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1
+ {mso-list-id:2024673066;
+ mso-list-template-ids:154433278;}
+ @list l1:level1
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0A7;
+ mso-level-tab-stop:36.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ mso-ansi-font-size:10.0pt;
+ font-family:Wingdings;}
+ @list l1:level2
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0B7;
+ mso-level-tab-stop:72.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ mso-ansi-font-size:10.0pt;
+ font-family:Symbol;}
+ @list l1:level3
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0B0;
+ mso-level-tab-stop:108.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ font-family:Symbol;}
+ @list l1:level4
+ {mso-level-tab-stop:144.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level5
+ {mso-level-tab-stop:180.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level6
+ {mso-level-tab-stop:216.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level7
+ {mso-level-tab-stop:252.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level8
+ {mso-level-tab-stop:288.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level9
+ {mso-level-tab-stop:324.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2
+ {mso-list-id:2095200852;
+ mso-list-type:hybrid;
+ mso-list-template-ids:-391638944 67698693 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
+ @list l2:level1
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0A7;
+ mso-level-tab-stop:36.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ font-family:Wingdings;}
+ @list l2:level2
+ {mso-level-tab-stop:72.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level3
+ {mso-level-tab-stop:108.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level4
+ {mso-level-tab-stop:144.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level5
+ {mso-level-tab-stop:180.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level6
+ {mso-level-tab-stop:216.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level7
+ {mso-level-tab-stop:252.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level8
+ {mso-level-tab-stop:288.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level9
+ {mso-level-tab-stop:324.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ ol
+ {margin-bottom:0cm;}
+ ul
+ {margin-bottom:0cm;}
+ -->
+ </style><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Table Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0cm 5.4pt 0cm 5.4pt; mso-para-margin:0cm; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-fareast-font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]-->
+ <style type="disc">
+ </style><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="45058"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]--><meta content="MCD Application Team" name="author"></head>
+ <body link="blue" vlink="blue">
+ <div class="Section1">
+ <p class="MsoNormal"><span style="font-family: Arial;"><br>
+ </span><span style="font-family: Arial;"><o:p></o:p></span></p>
+ <div align="center">
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+ <tbody>
+ <tr style="">
+ <td style="padding: 0cm;" valign="top">
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+ <tbody>
+ <tr style="">
+ <td style="padding: 1.5pt;">
+ 
+ <h1 style="margin-bottom: 18pt; text-align: center;" align="center"><span style="font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);">Release
+ Notes for<o:p></o:p> </span><span style="font-size: 20pt; color: rgb(51, 102, 255); font-family: Verdana;">STM8L10x Standard Peripherals Library Examples (StdPeriph_Examples)<br>
+ </span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span><br>
+ <span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span></h1>
+ <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;">Copyright
+  2014 STMicroelectronics</span><span style="color: black;"><u1:p></u1:p><o:p></o:p></span></p>
+ <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt;"><img style="border: 0px solid ; width: 86px; height: 65px;" alt="" id="_x0000_i1025" src="../../_htmresc/st_logo.png"></span></p>
+ </td>
+ </tr>
+ </tbody>
+ </table>
+ <p class="MsoNormal"><span style="font-family: Arial; display: none;"><o:p>&nbsp;</o:p></span></p>
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+ <tbody>
+ <tr style="">
+ <td style="padding: 0cm;" valign="top">
+ <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;">Contents<o:p></o:p></span></h2>
+ <ol style="margin-top: 0cm;" start="1" type="1">
+ <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#History">STM8L10x Standard Peripherals Library Examples update history</a><o:p></o:p></span></li>
+ <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#License">License</a><o:p></o:p></span></li>
+ </ol>
+             <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="History"></a><span style="font-size: 12pt; color: white;">STM8L10x Standard Peripherals Library Examples update history<o:p></o:p></span></h2>
+ 
+ <p class="MsoNormal"><span style="color: black;"><o:p>&nbsp;</o:p></span></p><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 500pt; width: 208px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.2.1 / 30-September-2014<o:p></o:p></span></h3><p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+ Changes<o:p></o:p></span></u></b></p>
+ <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">IWDG</span></span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Update the IWDG&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">configuration&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">seqeunce</span><span style="font-size: 10pt; font-family: Verdana;"> in the&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">IWDG_Example.</span></li></ul></ul>
+ <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 500pt; width: 167px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.2.0 / 01-June-2012<o:p></o:p></span></h3><p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+ Changes<o:p></o:p></span></u></b></p>
+ <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="margin-top: 4.5pt; margin-bottom: 4.5pt; color: black;"><span style="font-size: 10pt; font-family: Verdana;">Update almost examples to use 
+ Single function for IP configuration(IP, CLK, GPIO...)</span><span style="font-size: 10pt; font-family: Verdana;"></span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Update all examples to 
+ support <span style="font-weight: bold; font-style: italic;">IAR Embedded 
+ Workbench for STM8 (EWSTM8)</span> toolchain</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Update almost examples to use </span><span style="font-size: 10pt; font-family: Verdana;">the new "</span><span style="font-size: 10pt; font-family: Verdana;">stm8l_eval" drivers and "Common" utilities 
+ drivers</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add Library_Examples html 
+ file to provide the list, description&nbsp;and supported devices by all available 
+ examples</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">FLASH</span>&nbsp;</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Added
+ new example FLASH_DataProgram to replace
+ FLASH_ExecutionFromRAMWhileBlockWriteOperation,
+ FLASH_WriteEraseBlockOperation&nbsp;examples</span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">GPIO</span></span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">GPIO_IOToggle_InterruptMode example removed<span style="text-decoration: underline;"><br></span></span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">I2C</span></span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C_EEPROM
+ example updated to use the new serial EEPROM driver
+ stm8l_eval_i2c_ee.c/.h driver available under
+ Utilities\STM8L101_EVAL\Common</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add new example : 
+ I2C_DataExchange which is two boards based and aims to illustrate basic master 
+ and slave I2C communication steps and data exchange.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">I2C_10bitsCommunication axample and I2C_Interrupt example removed and replaced by new added </span><span style="font-size: 10pt; font-family: Verdana;">I2C_DataExchange example.</span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">IWDG</span></span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">IWDG_RearmReset
+ example removed and replaced by new added IWDG_Example to show how to
+ update at regular period the IWDG reload counter and&nbsp;to simulate a
+ software fault generating an MCU IWDG reset on expiry of a&nbsp;programmed time period.</span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">RST</span></span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">RST_IWDG example removed</span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">SPI</span></span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">SPI_MSD example updated to use </span><span style="font-size: 10pt; font-family: Verdana;">the new SPI sd driver stm8l_eval_spi_sd.h/.c driver available under 
+ Utilities\STM8L101_EVAL\Common.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">SPI_FullDuplexUASRT </span><span style="font-size: 10pt; font-family: Verdana;">example updated to use the new mono LCD driver stm8l_eval_lcd.c/.h available under </span><span style="font-size: 10pt; font-family: Verdana;">Utilities\STM8L101_EVAL\Common.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">SPI_SimplexLCD example updated to use the new mono LCD driver stm8l_eval_lcd.c/.h available under </span><span style="font-size: 10pt; font-family: Verdana;">Utilities\STM8L101_EVAL\Common.</span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;">TIM</span></span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">TIM2_PWM_FrequencyConfiguration&nbsp;example removed</span></li></ul></ul><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;"></span></span><span style="font-size: 10pt; font-family: Verdana;"></span><ul style="margin-top: 0cm;" type="square"></ul>
+ 
+ <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="License"></a><span style="font-size: 12pt; color: white;">License<o:p></o:p></span></h2><dl><dd><span style="font-size: 10pt; color: black;"><span style="font-family: Arial;">Licensed under MCD-ST Liberty SW License Agreement V2, (the "License").
+ You may not use this file except in compliance with the License.
+ You may obtain a copy of the License at:</span>
+ 
+ 
+ </span></dd></dl>
+ <p class="MsoNormal" style="line-height: normal; text-align: center; font-family: Arial;"><span style="font-size: 10pt;">
+ <a href="http://www.st.com/software_license_agreement_liberty_v2"> http://www.st.com/software_license_agreement_liberty_v2</a></span></p>
+ <div style="text-align: center;"></div><dl style="font-family: Arial;"><dd><span style="font-size: 10pt; color: black;"><span class="MsoNormal">Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.</span>
+ </span></dd></dl><p class="MsoNormal" style="margin: 4.5pt 0cm;"><b><span style="font-size: 10pt; font-family: Verdana; color: black;"></span></b><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p>
+ <div class="MsoNormal" style="text-align: center;" align="center"><span style="color: black;">
+ <hr align="center" size="2" width="100%"></span></div>
+ <p class="MsoNormal" style="line-height: normal;"><b><span style="font-size: 10pt;">&nbsp;&nbsp;&nbsp;&nbsp;</span></b></p><p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt; text-align: center;" align="center"><span style="font-size: 10pt; font-family: Verdana; color: black;">For
+ complete documentation on </span><span style="font-size: 10pt; font-family: Verdana;">STMicroelectronics<span style="color: black;"> Microcontrollers visit </span><a target="_blank" href="http://www.st.com/internet/mcu/family/141.jsp"><u><span style="color: blue;">www.st.com</span></u></a></span><span style="color: black;"><o:p></o:p></span></p>
+ </td>
+ </tr>
+ </tbody>
+ </table>
+ <p class="MsoNormal"><span style="font-size: 10pt;"><o:p></o:p></span></p>
+ </td>
+ </tr>
+ </tbody>
+ </table>
+ </div>
+ <p class="MsoNormal"><o:p>&nbsp;</o:p></p>
+ </div>
+ </body></html>
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/main.c	2018-04-05 05:29:23.000000000 +0200
***************
*** 0 ****
--- 1,145 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /**
+   * @addtogroup RST_IllegalOpcode
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ 
+ /* Private define ------------------------------------------------------------*/
+ 
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ void Delay (uint16_t nCount);
+ /* Private functions ---------------------------------------------------------*/
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+     uint8_t i =0;
+     
+     FlagStatus IllOpFlag = RESET;
+ 
+     enableInterrupts();
+     
+     /* Initialize Leds mounted on evaluation board */
+     STM_EVAL_LEDInit(LED2);
+     STM_EVAL_LEDInit(LED3);
+     STM_EVAL_LEDInit(LED4);
+ 
+     /* Initialize key button on evaluation board */
+     STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+     
+     /* Initialize the Interrupt sensitivity */
+     EXTI_SetPinSensitivity(EXTI_Pin_5, EXTI_Trigger_Falling);
+     
+     FLASH_Unlock(FLASH_MemType_Program);
+     
+     IllOpFlag = RST_GetFlagStatus(RST_FLAG_ILLOPF);
+ 
+     /* Test if a ILLOP Reset has occured */
+     if (IllOpFlag)
+     {
+         for (i=0;i<50;i++)
+         {
+             /* An ILLOP Reset has occured, Toggles LD2, LD3 and LD4 */
+             STM_EVAL_LEDToggle(LED2);
+             STM_EVAL_LEDToggle(LED3);
+             STM_EVAL_LEDToggle(LED4);
+             /* delay */
+             Delay(0x1FFF);
+         }
+         /* Clear IWDGF Flag */
+         RST_ClearFlag(RST_FLAG_ILLOPF);
+     }
+ 
+     /* Write an illigal opcode */
+     FLASH_ProgramByte(0x9F00, 0x75);
+ 
+     while (1)
+     {
+         /* Toggle LED */
+         STM_EVAL_LEDToggle(LED2);
+         STM_EVAL_LEDToggle(LED3);
+         STM_EVAL_LEDToggle(LED4);
+         /* delay */
+         Delay(0xFFFF);
+     }
+ 
+ }
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,73 ----
+ /** @page RST_IllegalOpcode Illegal Opcode Reset
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    RST/RST_IllegalOpcode/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the Illegal Opcode example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to generate detect 
+   and manage an illegal opcode reset. 
+ 	Pressing the KEY button will cause a jump to a specific memory 
+   address where an illegal opcode is written, so a reset is generated. 
+   LEDs from 2 to 4 start blinking fast signaling the illegal opcode "ILLOP" reset.
+ 	When the reset flag is cleared they will blink slowly.
+ 
+ 
+   @par Directory content
+ 
+   - RST\RST_IllegalOpcode\main.c                    Main file containing the "main" function
+   - RST\RST_IllegalOpcode\stm8l10x_conf.h           Library Configuration file
+   - RST\RST_IllegalOpcode\stm8l10x_it.c             Interrupt routines source
+   - RST\RST_IllegalOpcode\stm8l10x_it.h             Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - Three leds LD2, LD3 and LD4 and 
+      - Key push button.
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - The LD2, LD3 and LD4 are blinking slowly
+   - If you press the button, a Reset occurs and LD2, LD3 and LD4 blink fast
+ 
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,334 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ typedef  void (*Function_Pointer)(void);
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+   Function_Pointer  Jump_Function;
+   /* Jump to the illigal opcode address */
+   Jump_Function = (Function_Pointer) 0x9F00;
+   Jump_Function();
+   EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/RST/RST_IllegalOpcode/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/main.c	2018-04-05 05:29:31.000000000 +0200
***************
*** 0 ****
--- 1,238 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l101_eval.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l_eval_lcd.h"
+ #include <stdio.h>
+ /**
+   * @addtogroup SPI_FullDuplexUSART
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ bool ButtonPressed = FALSE;
+ /* Private function prototypes -----------------------------------------------*/
+ static void CLK_Config(void);
+ static void USART_Config(void);
+ void Delay (uint16_t nCount);
+ bool GetVar_ButtonPressed(void);
+ void SetVar_ButtonPressed(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   uint8_t i = 0;
+   uint8_t DataTx = 0;
+   uint8_t DataRx = 0;
+   uint8_t StrName[16]={0};
+     
+   /* Clock configuration -----------------------------------------*/
+   CLK_Config();  
+   
+   /* Initialize LED2,LED3 and LED4 */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+   
+   /* Initialize KEY button */
+   STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+ 
+   STM8L_EVAL_LCD_Init();
+ 
+   /* USART configuration -----------------------------------------*/
+   USART_Config(); 
+ 
+   /* Initialize LCD and display welcome message */
+   LCD_SetCursorPos(LCD_LINE1, 0);
+   
+   LCD_Print("  *** STM8L *** ");
+   
+   LCD_SetCursorPos(LCD_LINE2, 0);
+   
+   LCD_Print("  SPI example  ");
+   
+   for (i = 0; i < 5; i++)
+   {
+     Delay(0xFFFF);
+   }
+   
+   LCD_Clear();
+   
+   LCD_SetCursorPos(LCD_LINE1, 0);
+   
+   LCD_Print("Press KEY...");
+   
+   DataTx = 0x00;
+ 
+   /* Enable general interrupts for Key button reading */
+   enableInterrupts();
+ 
+   while (1)
+   {
+     /* Check button status */
+     if (GetVar_ButtonPressed() == TRUE) /* Button is pressed */
+     {
+       
+       ButtonPressed = FALSE;
+       
+       /* Set SPI in Slave mode for communication with USART */
+       SPI_Init(SPI_FirstBit_LSB, SPI_BaudRatePrescaler_128, SPI_Mode_Slave,
+                SPI_CPOL_Low, SPI_CPHA_1Edge,  SPI_Direction_2Lines_FullDuplex, SPI_NSS_Soft);
+       USART_Cmd(ENABLE);
+       Delay(300);
+       SPI_Cmd(ENABLE);
+       
+       /* Send data with USART */
+       USART_SendData8(DataTx);
+ 
+       /* Receive data with SPI */
+       DataRx = SPI_ReceiveData();
+       
+       USART_Cmd(DISABLE);
+       
+       STM8L_EVAL_LCD_Init();
+       
+       LCD_SetCursorPos(LCD_LINE1, 0);
+       LCD_Print("Press KEY...");
+       LCD_SetCursorPos(LCD_LINE2, 0);
+       LCD_Print("TX=");
+       LCD_SetCursorPos(LCD_LINE2, 2);
+       sprintf((char*)StrName, "%x", (int)DataTx);
+       LCD_Print(StrName);
+       
+       LCD_SetCursorPos(LCD_LINE2, 4);
+       LCD_Print(" RX=");
+       LCD_SetCursorPos(LCD_LINE2, 6);
+       sprintf((char*)StrName, "%x", (int)DataRx);
+       LCD_Print(StrName);
+       
+       DataTx++; /* Change next data to be sent */
+       
+     }
+   }
+ }
+ 
+ /**
+   * @brief  Enable peripheral clocks
+   * @param  None
+   * @retval None
+   */
+ static void CLK_Config(void)
+ {
+   /*Enable clock SPI */
+   CLK_PeripheralClockConfig(CLK_Peripheral_SPI, ENABLE);
+   
+   /*Enable clock USART */
+   CLK_PeripheralClockConfig(CLK_Peripheral_USART, ENABLE); 
+ }
+ 
+ /**
+   * @brief  Configure USART to run in master mode
+   * @param  None
+   * @retval None
+   */
+ static void USART_Config(void)
+ {
+   /* Initialize USART in Master mode */
+   USART_DeInit();
+   USART_Init((uint32_t)4800, USART_WordLength_8D, USART_StopBits_1, USART_Parity_No,
+             (USART_Mode_TypeDef)(USART_Mode_Rx | USART_Mode_Tx));
+   
+   USART_ClockInit(USART_Clock_Enable, USART_CPOL_Low, USART_CPHA_1Edge,  USART_LastBit_Enable);
+   
+   USART_Cmd(DISABLE);
+ }
+ 
+ /**
+   * @brief Returns ButtonPressed value.
+   * @param  None
+   * @retval BoolT: ButtonPressed
+   */
+ bool GetVar_ButtonPressed(void)
+ {
+   return ButtonPressed;
+ }
+ 
+ /**
+   * @brief Set the ButtonPressed value.
+   * @param  None
+   * @retval None
+   */
+ void SetVar_ButtonPressed(void)
+ {
+   ButtonPressed = TRUE;
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+   /* Decrement nCount value */
+   while (nCount != 0)
+   {
+     nCount--;
+   }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,69 ----
+ /** @page SPI_FullDuplexUSART Full duplex master/slave communication with USART.
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    SPI/SPI_FullDuplexUSART/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the USART in full duplex mode example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to make a master/slave communication
+   between the SPI and the USART, the last is configured in master mode.
+   
+   Data transmitted by USART "DataTx" and data received by SPI "DataRx" are both 
+   printed on the LCD to be compared.
+   
+   @par Directory content
+ 
+   - SPI\SPI_FullDuplexUSART\main.c                       Main file containing the "main" function
+   - SPI\SPI_FullDuplexUSART\stm8l10x_conf.h              Library Configuration file
+   - SPI\SPI_FullDuplexUSART\stm8l10x_it.c                Interrupt routines source
+   - SPI\SPI_FullDuplexUSART\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up    
+       - Connect USART and SPI pins as follows:
+          - USART TX (PC3) to SPI MOSI (PB6)
+          - USART RX (PC2) to SPI MISO (PB7)
+          - USART CLK (PC4) to SPI SCK (PB5)
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Follow instructions on the LCD
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ extern bool ButtonPressed;
+ 
+ /* Private function prototypes -----------------------------------------------*/
+ void SetVar_ButtonPressed(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+   SetVar_ButtonPressed();
+   /* Clear Interrupt pending bit */
+   EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_FullDuplexUSART/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/main.c	2018-04-05 05:29:36.000000000 +0200
***************
*** 0 ****
--- 1,207 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ #include "stm8l_eval_lcd.h"
+ #include "stm8l_eval_spi_sd.h"
+ 
+ /**
+   * @addtogroup SPI_MSD
+   * @{
+   */
+ 
+ /* Private macro -------------------------------------------------------------*/
+ #define countof(a) (sizeof(a) / sizeof(*(a)))
+ /* Private define ------------------------------------------------------------*/
+ #define BufferSize (countof(Tx_Buffer)-1)
+ /* Private variables ---------------------------------------------------------*/
+ uint16_t Status = 0;
+ uint8_t Tx_Buffer[] = "STM8l10x SPI Firmware Library Example: communication with a microSD card";
+ uint8_t Rx_Buffer[BufferSize] = {0};
+ __IO ErrorStatus TransferStatus = ERROR;
+ extern __IO uint8_t ButtonPressed;
+     
+ /* Private function prototypes -----------------------------------------------*/
+ void Delay (uint16_t nCount);
+ ErrorStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {    
+     uint8_t i = 0;
+     
+     /*High speed internal clock prescaler: 4*/  
+     CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv4);
+     
+     /* Initialize KEY button */
+     STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+     
+     /* Initialize LCD and display welcome message */
+     STM8L_EVAL_LCD_Init();
+ 
+     LCD_SetCursorPos(LCD_LINE1, 0);
+     LCD_Print(" SPI & MicroSD ");
+     LCD_SetCursorPos(LCD_LINE2, 0);
+     LCD_Print(" Communication ");
+     for (i = 0; i < 6; i++)
+     {
+         Delay(0xFFFF);
+     }
+ 
+     /* Enable general interrupts for Key button reading */
+     enableInterrupts();
+ 
+     /* Display second message */
+     LCD_Clear();
+     LCD_SetCursorPos(LCD_LINE1, 0);
+     LCD_Print("Insert MicroSD ");
+     LCD_SetCursorPos(LCD_LINE2, 0);
+     LCD_Print("   Press KEY   ");
+     
+     /* Check button status */
+     /* Wait external interrupt */
+     while (ButtonPressed != TRUE);
+ 
+     /* MicroSD card detection */
+     for (i = 0; i < 6; i++)
+     {
+         Delay(0xFFFF);
+     }
+       
+     /* Clear the LCD */
+     LCD_Clear();
+ 
+     /* Init the flash micro SD*/
+     Status = SD_Init();
+ 
+     /***************************Block Read/Write******************************/
+     /* Write block of 512 bytes on address 0 */
+     Status = SD_WriteBlock(Tx_Buffer, 0, BufferSize);
+     /* Read block of 512 bytes from address 0 */
+     Status = SD_ReadBlock(Rx_Buffer, 0, BufferSize);
+ 
+     /* Check data */
+     TransferStatus = Buffercmp(Tx_Buffer, Rx_Buffer, BufferSize);
+   
+     /*Print result of test on LCD */
+     LCD_SetCursorPos(LCD_LINE1, 0);
+     LCD_Print("   W&R block   ");
+ 
+     if (TransferStatus == ERROR)
+     {
+         LCD_SetCursorPos(LCD_LINE2, 0);
+         LCD_Print("     ERROR     ");
+     }
+     else
+     {
+         LCD_SetCursorPos(LCD_LINE2, 0);
+         LCD_Print("    SUCCESS    ");
+     }
+ 
+     for (i = 0; i < 7; i++) /* Delay */
+     {
+         Delay(0xFFFF);
+     }
+     /* Notify user the end of demo */
+     LCD_Clear();
+     LCD_SetCursorPos(LCD_LINE1, 0);
+     LCD_Print("   THE END !   ");
+     while (1)
+     {
+     }
+ }
+ 
+ /**
+   * @brief Compares two buffers.
+   * @par Parameters:
+   * - pBuffer1, pBuffer2: buffers to be compared.
+   * - BufferLength: buffer's length
+   * @retval
+   * - PASSED: pBuffer1 identical to pBuffer2
+   * - FAILED: pBuffer1 differs from pBuffer2
+   */
+ ErrorStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
+ {
+     while (BufferLength--)
+     {
+         if (*pBuffer1 != *pBuffer2)
+         {
+             return ERROR;
+         }
+ 
+         pBuffer1++;
+         pBuffer2++;
+     }
+ 
+     return SUCCESS;
+ }
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,79 ----
+ /** @page SPI_MSD Fast communication with a MicroSD memory card
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    SPI/SPI_MSD/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the SPI MSD Example.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to make a communication 
+   (Write & Read data) between the SPI and a MicroSD memory card like the one 
+   present on the evalboard.
+ 	
+   First, Fill the Tx_Buffer with data to be written into the MicroSD memory 
+   followed by a read of that data.
+   Then data read from the MicroSD memory stored in the Rx_Buffer are compared
+   with the expected values of the Tx_Buffer. The result of this comparison is 
+   stored in the "TransferStatus" variable.
+ 
+  @par Directory contents
+ 
+   - SPI\SPI_MSD\main.c                       Main file containing the "main" function
+   - SPI\SPI_MSD\stm8l10x_conf.h              Library Configuration file
+   - SPI\SPI_MSD\stm8l10x_it.c                Interrupt routines source 
+   - SPI\SPI_MSD\stm8l10x_it.h                Interrupt routines declaration
+   
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1 Set-up
+      - Plug a MicroSD memory card into the dedicated connector (CN1).
+      - LCD display.
+      - Key button.
+      
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Add the required files:
+     - stm8l_eval_spi_sd.c (under Utilities/STM8L101_EVAL/Common)
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Run program: Debug->Run (Ctrl+F5)
+   - The LCD displays " SPI example SPI & MicroSD Communication"
+   - Insert MicroSD memory then validate by pressing Key button
+   - If the read data from the MicroSD memory are the same as the written ones
+     the LCD displays "W&R block Success" otherwise "W&R block Error".
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,334 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ __IO uint8_t ButtonPressed = FALSE;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+      ButtonPressed = TRUE;
+      EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_MSD/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/main.c	2018-04-05 05:29:40.000000000 +0200
***************
*** 0 ****
--- 1,214 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ #include "stm8l_eval_lcd.h"
+ #include <stdio.h>
+ 
+ /**
+   * @addtogroup SPI_SimplexLCD
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ 
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ bool ButtonPressed = FALSE;
+ uint8_t i =0;
+ __IO uint8_t LedState = 1, ButtonIndex = 0;
+ uint8_t pos =0;
+ uint8_t StrName[16];
+ /* Private function prototypes -----------------------------------------------*/
+ void Delay(uint16_t nCount);
+ bool GetVar_ButtonPressed(void);
+ void SetVar_ButtonPressed(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+     STM_EVAL_LEDInit(LED2);
+     STM_EVAL_LEDInit(LED3);
+     STM_EVAL_LEDInit(LED4);
+ 
+     /* Initialize KEY button */
+     STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+ 
+     /* Enable general interrupts for Key button reading */
+     enableInterrupts();
+ 
+     /* Initialize LCD */
+     STM8L_EVAL_LCD_Init();
+ 
+     /* Clear LCD lines */
+     LCD_Clear();
+ 
+     /* Display "moving" ST logo on first line */
+     for (pos = 0x80; pos < 0x88; pos++)
+     {
+         LCD_Clear();
+         LCD_DisplayLogo(pos);
+         Delay(5000);
+     }
+ 
+     /* Display "moving" ST logo on second line */
+     for (pos = 0x90; pos < 0x98; pos++)
+     {
+         LCD_Clear();
+         LCD_DisplayLogo(pos);
+         Delay(5000);
+     }
+ 
+     /* Clear LCD lines */
+     LCD_Clear();
+ 
+     /* Max 15 characters per line */
+     LCD_SetCursorPos(LCD_LINE1, 0);
+     LCD_Print(" *** STM8L *** ");
+     LCD_SetCursorPos(LCD_LINE2, 0);
+     LCD_Print("SPI-LCD example");
+ 
+     for (i = 0; i < 10; i++)
+     {
+         Delay(0xFFFF);
+     }
+ 
+     /* Clear LCD lines */
+     LCD_Clear();
+ 
+     LCD_Print("Press KEY...");
+ 
+     while (1)
+     {
+       /* Check button status */
+       if (GetVar_ButtonPressed() == TRUE) /* Button is pressed */
+       {
+         ButtonPressed = FALSE;
+         LCD_SetCursorPos(LCD_LINE2, 0);
+         LCD_Clear();
+         LCD_Print("LED #");
+         sprintf((char*)StrName, "%d", (int)(ButtonIndex + 2));
+ 
+         LCD_Print(StrName);
+         LCD_SetCursorPos(LCD_LINE2, 2); /* 8th position */
+         if (LedState == 0)
+         {
+           LCD_Print("OFF");
+         }
+         else
+         {
+           LCD_Print("ON");
+         }
+         switch (ButtonIndex)
+         {
+           case 0:
+             STM_EVAL_LEDToggle(LED2);
+             ButtonIndex++;
+           break;
+           
+           case 1:
+             STM_EVAL_LEDToggle(LED3);
+             ButtonIndex++;
+           break;
+ 
+           case 2:
+             STM_EVAL_LEDToggle(LED4);
+             ButtonIndex = 0;
+             LedState ^= 0x01;
+           break;
+         }
+     }
+   }
+ }
+ /**
+   * @brief Returns ButtonPressed value.
+   * @param  None
+   * @retval BoolT: ButtonPressed
+   */
+ bool GetVar_ButtonPressed(void)
+ {
+   return ButtonPressed;
+ }
+ /**
+   * @brief Set the ButtonPressed value.
+   * @param  None
+   * @retval None
+   */
+ void SetVar_ButtonPressed(void)
+ {
+     ButtonPressed = TRUE;
+ }
+ 
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,69 ----
+ /** @page SPI_SimplexLCD Communication with a monochrome LCD
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    SPI/SPI_SimplexLCD/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the SPI simplex LCD example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to use the SPI peripheral 
+   in order to communicate with a monochrome LCD peripheral like the one present 
+   on the eval-board.
+ 
+ 
+   @par Directory content
+ 
+   - SPI\SPI_SimplexLCD\main.c                       Main file containing the "main" function
+   - SPI\SPI_SimplexLCD\main.h                       Main functions prototype
+   - SPI\SPI_SimplexLCD\stm8l10x_conf.h              Library Configuration file
+   - SPI\SPI_SimplexLCD\stm8l10x_it.c                Interrupt routines source
+   - SPI\SPI_SimplexLCD\stm8l10x_it.h                Interrupt routines declaration
+   
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - Three leds LD2, LD3 and LD4 
+      - Key push button.
+      - LCD Display
+  
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - A welcome message should be displayed on the LCD
+   - Press the Key button in order to change the message on the LCD and the LED2,
+     LED3 and LED4 states.
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,329 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ extern void SetVar_ButtonPressed(void);
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+   SetVar_ButtonPressed();
+   /* Clear Interrupt pending bit */
+   EXTI_ClearITPendingBit(EXTI_IT_Pin5);  
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/SPI/SPI_SimplexLCD/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/main.c	2018-04-05 05:30:17.000000000 +0200
***************
*** 0 ****
--- 1,151 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup TIM2_InputCapture 
+   * @{
+   */
+ /* Private variables -----------------------------------------------------------*/	
+ uint16_t Period = 125;
+ uint32_t TIM2ClockFreq = 16000000;
+ uint32_t TIM3ClockFreq = 0;
+ uint16_t ICValue1 = 0, ICValue2 = 0;
+ /* Private defines -----------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void TIM2_Config(void);
+ static void TIM3_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /*--------------------- TIM2 Clock = 16Mhz ----------------*/
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+     
+   /*--------------------- TIM3 Config------------------------*/
+   TIM3_Config();
+   
+   /*--------------------- TIM2 Config------------------------*/
+   TIM2_Config();
+ 
+   /* Compute TIM3 CC2 clock frequency */
+   TIM3ClockFreq = (8 * TIM2ClockFreq) / (ICValue2 - ICValue1);
+   
+   /* Insert a break point here */
+   nop();
+ 
+   while (1)
+   {}
+ }
+ 
+ static void TIM2_Config(void)
+ {
+   /* Enable TIM2 CLK */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+   
+   /* Capture only every 8 events!!! */
+   /* Enable capture of TIM2 */
+   TIM2_ICInit(TIM2_Channel_1, TIM2_ICPolarity_Falling, TIM2_ICSelection_DirectTI, TIM2_ICPSC_Div8, 0);
+   
+   /* Enable timer1 */
+   TIM2_Cmd(ENABLE);
+   
+   /* Config Channel 1 pin*/
+   GPIO_Init(GPIOB, GPIO_Pin_0, GPIO_Mode_In_PU_No_IT);
+ 
+   /* Clear CC1 Flag*/
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+   
+   /* wait a Capture on CC1 */
+   while((TIM2->SR1 & TIM2_FLAG_CC1) != TIM2_FLAG_CC1);
+   
+   /* Get CCR1 value*/
+   ICValue1 = TIM2_GetCapture1();
+   /* Clear CC1 Flag*/
+   TIM2_ClearFlag(TIM2_FLAG_CC1);
+   
+   /* wait a capture on cc1 */
+   while((TIM2->SR1 & TIM2_FLAG_CC1) != TIM2_FLAG_CC1);
+   /* Get CCR1 value*/
+   ICValue2 = TIM2_GetCapture1();
+   TIM2_ClearFlag(TIM2_FLAG_CC1); 
+ }
+ 
+ static void TIM3_Config(void)
+ {
+   /* Enable TIM3 CLK */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE);
+   
+   /* TIM3 Time Base configuration */
+   TIM3_TimeBaseInit(TIM3_Prescaler_1, TIM3_CounterMode_Up, Period);
+   
+   /* Channel 2 Configuration in PWM mode */
+   TIM3_OC2Init(TIM3_OCMode_PWM2, TIM3_OutputState_Enable, Period,  TIM3_OCPolarity_Low, TIM3_OCIdleState_Set);
+   
+   /* TIM3 counter enable */
+   TIM3_Cmd(ENABLE);
+ 
+   /* Main Output Enable */
+   TIM3_CtrlPWMOutputs(ENABLE);
+ 
+   /* GPIO TIM3 Channel1 configuration */
+   GPIO_Init(GPIOD, GPIO_Pin_0, GPIO_Mode_Out_PP_Low_Fast);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,73 ----
+ /** @page TIM2_InputCapture: Signal frequency Capture by TIM2 
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    TIM2/TIM2_InputCapture/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the TIM2 Input Capture example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example shows how to configure the TIM2 peripheral to capture a signal frequency.
+   TIM2CLK is fixed to 16 MHz, the TIM2 used Prescaler is 1 so the TIM2 counter clock used 
+   is 16 MHz.
+   The TIM2 Channel 1 is configured as Input capture.
+   TIM3 channel 2 is configured to generate a 128khz signal frequency. 
+   The TIM2 Channel 1 is connected to the TIM3 Channel 2 pin. 
+   The value of TIM2 CC1 Frequency is stored in the TIM2ClockFreq variable.
+ 
+ 
+   @par Directory content
+ 
+   - TIM2\TIM2_InputCapture\main.c                       Main file containing the "main" function
+   - TIM2\TIM2_InputCapture\stm8l10x_conf.h              Library Configuration file
+   - TIM2\TIM2_InputCapture\stm8l10x_it.c                Interrupt routines source (not used in this example)
+   - TIM2\TIM2_InputCapture\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - Connect the TIM2 Channel 1 (PB.0) to the TIM3 Channel 2 pin (PD.0).  
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Connect the TIM2 CH1 (TIM2_CC1) to the TIM3 CH2 (TIM3_CC2).
+   - Read the value of TIM3ClockFreq variable
+ 
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_InputCapture/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/main.c	2018-04-05 05:30:24.000000000 +0200
***************
*** 0 ****
--- 1,144 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup TIM2_OCActiveMode
+   * @{
+   */
+ /* Private defines -----------------------------------------------------------*/
+ #define CCR1_Val  ((uint16_t)15625)
+ #define CCR2_Val  ((uint16_t)7812)
+ /* Private function prototypes -----------------------------------------------*/
+ static void GPIO_Config(void);
+ static void TIM2_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* GPIO configuration -----------------------------------------*/
+   GPIO_Config();  
+ 
+   /* TIM2 configuration -----------------------------------------*/
+   TIM2_Config();  
+   
+   while (1)
+   {} 
+ }
+ 
+ /**r
+   * @brief  Configure PG6 to allow delay of TIM2 channels computation
+   * @param  None
+   * @retval None
+   */
+ static void GPIO_Config(void)
+ {
+   /* Set PG.6 pin */
+   GPIO_Init(GPIOC, GPIO_Pin_6, GPIO_Mode_Out_PP_Low_Fast);
+   GPIO_SetBits(GPIOC, GPIO_Pin_6);
+ }
+ 
+ /**
+   * @brief  Configure TIM2 peripheral to generate 3 different signals with 3
+   *         different delays
+   * @param  None
+   * @retval None
+   */
+ static void TIM2_Config(void)
+ {
+   /* Enable TIM2 clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+ 
+   /* Config TIM2 Channel 1 and channel 2 pins */
+   GPIO_Init(GPIOB, GPIO_Pin_0 | GPIO_Pin_2, GPIO_Mode_Out_PP_High_Fast);
+ 
+   /* Time base configuration */      
+   TIM2_TimeBaseInit(TIM2_Prescaler_128, TIM2_CounterMode_Up, 65535);
+ 
+   /* Prescaler configuration */
+   TIM2_PrescalerConfig(TIM2_Prescaler_128, TIM2_PSCReloadMode_Immediate);
+ 
+   /* Output Compare Active Mode configuration: Channel1 */
+   /*
+     TIM2_OCMode = TIM2_OCMODE_ACTIVE
+     TIM2_OutputState = TIM2_OUTPUTSTATE_ENABLE
+     TIM2_Pulse = CCR1_Val
+     TIM2_OCPolarity = TIM2_OCPOLARITY_HIGH
+   */
+   TIM2_OC1Init(TIM2_OCMode_Active, TIM2_OutputState_Enable, CCR1_Val, TIM2_OCPolarity_High, TIM2_OCIdleState_Reset);
+   
+   TIM2_OC1PreloadConfig(DISABLE);
+ 
+   /* Output Compare Active Mode configuration: Channel2 */
+   
+   /*TIM2_Pulse = CCR2_Val  */
+   
+   TIM2_OC2Init(TIM2_OCMode_Active, TIM2_OutputState_Enable,CCR2_Val, TIM2_OCPolarity_High, TIM2_OCIdleState_Reset); 
+   TIM2_OC2PreloadConfig(DISABLE);
+   
+   TIM2_ARRPreloadConfig(ENABLE);
+   
+   /* Enable TIM2 outputs */
+   TIM2_CtrlPWMOutputs(ENABLE);
+   
+   /* TIM2 enable counter */
+   TIM2_Cmd(ENABLE);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {}
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,85 ----
+ /** @page TIM2_OCActiveMode Generate two different signals with two different delays with Active Mode
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    TIM2/TIM2_OCActiveMode/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the TIM2 Output Compare active mode example 
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example shows how to configure the TIM2 peripheral to generate two different 
+   signals with two different delays.
+ 
+   The TIM2CLK frequency is set to 2 MHz, the Prescaler is set to 128 and used in 
+   Output Compare Active Mode.
+  
+   TIM2 counter clock = TIM2CLK / (Prescaler) = 15625 Hz 
+ 
+   The TIM2 CCR1 register value is equal to 15625:
+   TIM2_CH1 delay = CCR1_Val/TIM2 counter clock  = 1000 ms
+   so the TIM2 Channel 1 generates a signal with a delay equal to 1000 ms.
+ 
+   The TIM2 CCR2 register value is equal to 7812:
+   TIM2_CH2 delay = CCR2_Val/TIM2 counter clock = 500 ms
+   so the TIM2 Channel 2 generates a signal with a delay equal to 500 ms.
+   
+   The delay corresponds to the time difference between PC.6 and TIM2_CHx signal rising edges
+ 
+ 
+   @par Directory content
+ 
+   - TIM2\TIM2_OCActiveMode\main.c                      Main file containing the "main" function
+   - TIM2\TIM2_OCActiveMode\stm8l10x_conf.h             Library Configuration file
+   - TIM2\TIM2_OCActiveMode\stm8l10x_it.c               Interrupt routines source (not used in this example)
+   - TIM2\TIM2_OCActiveMode\stm8l10x_it.h               Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+     - Connect the following pins to an oscilloscope:
+       - PC.6
+       - TIM2_CH1  pin (PB.0)  
+       - TIM2_CH2  pin (PB.2)  
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Connect the TIM2 pins and PC.6 pin to an oscilloscope 
+   
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCActiveMode/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/main.c	2018-04-05 05:30:28.000000000 +0200
***************
*** 0 ****
--- 1,134 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup TIM2_OCInactiveMode
+   * @{
+   */
+ 
+ /* Private defines -----------------------------------------------------------*/
+ #define CCR1_Val  ((uint16_t)15625)
+ #define CCR2_Val  ((uint16_t)7812)
+ /* Private function prototypes -----------------------------------------------*/
+ static void TIM2_Config(void);
+ static void GPIO_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* Config TIM2 clock */
+   TIM2_Config();
+   
+   /* Config GPIO */
+   GPIO_Config();
+   
+   /* TIM2 enable counter */
+   TIM2_Cmd(ENABLE);
+   
+   enableInterrupts();
+ 
+   while (1)
+   {}
+ }
+ 
+ /**
+   * @brief  Configure GPIO 
+   * @param  None
+   * @retval None
+   */
+ static void GPIO_Config(void)
+ {
+   /* Set pin PC.0, PC5 & PC.6 to high state */
+   GPIO_Init(GPIOC, (GPIO_Pin_0 | GPIO_Pin_5 | GPIO_Pin_6), GPIO_Mode_Out_PP_Low_Fast);
+   GPIO_SetBits(GPIOC, GPIO_Pin_0);
+   GPIO_ResetBits(GPIOC, GPIO_Pin_5 | GPIO_Pin_6);
+ }
+ 
+ /**
+   * @brief  Configure TIM2 peripheral
+   * @param  None
+   * @retval None
+   */
+ static void TIM2_Config(void)
+ {
+    /* Enable TIM2 clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+    
+    /* Time base configuration */
+   TIM2_TimeBaseInit(TIM2_Prescaler_128, TIM2_CounterMode_Up, 65535);
+ 
+   /* Prescaler configuration */
+   TIM2_PrescalerConfig(TIM2_Prescaler_128, TIM2_PSCReloadMode_Immediate);
+   
+   /* Output Compare Active Mode configuration: Channel1 */
+   TIM2_OC1Init(TIM2_OCMode_Inactive, TIM2_OutputState_Enable, CCR1_Val, TIM2_OCPolarity_High, TIM2_OCIdleState_Reset); 
+   TIM2_OC1PreloadConfig(DISABLE);                                      
+ 
+   /* Output Compare Active Mode configuration: Channel2 */
+   TIM2_OC2Init(TIM2_OCMode_Inactive, TIM2_OutputState_Enable, CCR2_Val, TIM2_OCPolarity_High, TIM2_OCIdleState_Reset); 
+   TIM2_OC2PreloadConfig(DISABLE);
+ 
+   TIM2_ARRPreloadConfig(ENABLE);
+   
+   /* TIM IT enable */
+   TIM2_ITConfig(TIM2_IT_CC1, ENABLE);
+   TIM2_ITConfig(TIM2_IT_CC2, ENABLE);
+ }
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,84 ----
+ /** @page TIM2_OCInactiveMode Generate two different signals with two different delays with Inactive Mode
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    TIM2/TIM2_OCInactiveMode/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the TIM2 output compare inactive mode example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example shows how to configure the TIM peripheral to generate two different 
+   signals with two different delays.
+ 
+   The TIM2CLK frequency is set to 2 MHz, the Prescaler is set to 128 and used in 
+   Output Compare Inctive Mode.
+  
+   TIM2 counter clock = TIM2CLK / (Prescaler) = 15625 Hz 
+ 
+ 
+   The TIM2 CCR1 register value is equal to 15625:
+   TIM2_CH1 delay = CCR1_Val/TIM2 counter clock  = 1000 ms
+   so the TIM2 Channel 1 generates a signal with a delay equal to 1000 ms.
+ 
+   The TIM2 CCR2 register value is equal to 7812:
+   TIM2_CH2 delay = CCR2_Val/TIM2 counter clock = 500 ms
+   so the TIM2 Channel 2 generates a signal with a delay equal to 500 ms.
+   
+   The delay correspond to the time difference between PC.0 and TIM2_CHx signal rising edges.
+ 
+ 
+   @par Directory content
+ 
+   - TIM2\TIM2_OCInactiveMode\main.c                       Main file containing the "main" function
+   - TIM2\TIM2_OCInactiveMode\stm8l10x_conf.h              Library Configuration file
+   - TIM2\TIM2_OCInactiveMode\stm8l10x_it.c                Interrupt routines source 
+   - TIM2\TIM2_OCInactiveMode\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+     - Connect the following pins to an oscilloscope:
+       - Pin PC.0
+       - Pin PC.5
+       - Pin PC.6
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Connect PC.0 , PC.5 and PC.6 pins to an oscilloscope 
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,344 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+   if (TIM2_GetITStatus(TIM2_IT_CC1) != RESET)
+   {
+     /* Clear TIM2 Capture Compare1 interrupt pending bit*/
+     TIM2_ClearITPendingBit(TIM2_IT_CC1);
+ 
+     /* PC.5 toggles after 1000 ms */
+     GPIO_SetBits(GPIOC, GPIO_Pin_5);
+   }
+   
+   if (TIM2_GetITStatus(TIM2_IT_CC2) != RESET)
+   {
+     /* Clear TIM2 Capture Compare2 interrupt pending bit*/
+     TIM2_ClearITPendingBit(TIM2_IT_CC2);
+   
+     /* PC.6 toggles after 500 ms */
+     GPIO_SetBits(GPIOC, GPIO_Pin_6);
+   }
+ }
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_OCInactiveMode/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/main.c	2018-04-05 05:30:21.000000000 +0200
***************
*** 0 ****
--- 1,115 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup TIM2_PWM_DutyCycleConfiguration
+   * @{
+   */
+ /* Private variables ---------------------------------------------------------*/
+ uint16_t CCR1_Val = 32767;
+ uint16_t CCR2_Val = 16383;
+ /* Private defines -----------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void TIM2_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* TIM2 Configuration ------------------------------------------------------*/
+   TIM2_Config();
+   
+   while (1)
+   {}
+ }
+ 
+ /**
+   * @brief  Configure TIM2 peripheral
+   * @param  None
+   * @retval None
+   */
+ static void TIM2_Config(void)
+ {
+   /* Enable TIM2 clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+   
+   /* Config TIM2 Channel 1 and channel 2 pins */
+   GPIO_Init(GPIOB, GPIO_Pin_0 | GPIO_Pin_2, GPIO_Mode_Out_PP_High_Fast);
+ 
+   /* Time base configuration */
+   TIM2_TimeBaseInit(TIM2_Prescaler_1, TIM2_CounterMode_Up, 65535);
+ 
+   /* PWM1 Mode configuration: Channel1 */ 
+   TIM2_OC1Init(TIM2_OCMode_PWM1, TIM2_OutputState_Enable, CCR1_Val, TIM2_OCPolarity_High, TIM2_OCIdleState_Set);
+   TIM2_OC1PreloadConfig(ENABLE);
+ 
+   /* PWM1 Mode configuration: Channel2 */ 
+   TIM2_OC2Init(TIM2_OCMode_PWM1, TIM2_OutputState_Enable,CCR2_Val, TIM2_OCPolarity_High, TIM2_OCIdleState_Set);
+   TIM2_OC2PreloadConfig(ENABLE);
+ 
+   TIM2_ARRPreloadConfig(ENABLE);
+ 
+   /* Enable TIM2 outputs */
+   TIM2_CtrlPWMOutputs(ENABLE);
+   
+   /* TIM2 enable counter */
+   TIM2_Cmd(ENABLE);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,85 ----
+ /** @page TIM2_PWMDutyCycleConfiguration Generate two different signals with two different duty cycles 
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    TIM2/TIM2_PWMDutyCycleConfiguration/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the TIM2 PWM Duty Cycle Configuration example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example shows how to configure the TIM2 peripheral in PWM (Pulse Width Modulation) 
+   mode.
+   The TIM2CLK frequency is 2MHz, the Prescaler is 1 so the TIM2 counter clock is 2MHz. 
+ 
+   The TIM2 is running at 30 Hz: TIM2 Frequency = TIM2 counter clock/(ARR + 1) 
+   
+   So TIM2 frequency is 30 Hz.
+ 
+ 
+   The TIM2 CCR1 register value is equal to 32767, so the TIM2 Channel 1 generates a 
+   PWM signal with a frequency equal to 30 Hz and a duty cycle equal to 50%:
+   TIM2 Channel1 duty cycle = [TIM2_CCR1/(TIM2_ARR + 1)] * 100 = 50%
+ 
+   The TIM2 CCR2 register value is equal to 16383, so the TIM2 Channel 2 generates a 
+   PWM signal with a frequency equal to 30 Hz and a duty cycle equal to 25%:
+   TIM2 Channel2 duty cycle = [TIM2_CCR2/ (TIM2_ARR + 1)] * 100 = 25%
+ 
+ 
+   The PWM waveform can be displayed using an oscilloscope.
+ 
+ 
+   @par Directory content
+ 
+   - TIM2\TIM2_PWMDutyCycleConfiguration\main.c                      Main file containing the "main" function
+   - TIM2\TIM2_PWMDutyCycleConfiguration\stm8l10x_conf.h             Library Configuration file
+   - TIM2\TIM2_PWMDutyCycleConfiguration\stm8l10x_it.c               Interrupt routines source
+   - TIM2\TIM2_PWMDutyCycleConfiguration\stm8l10x_it.h               Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+     - Connect TIM2 pins to an oscilloscope:
+        - TIM2_CH1  pin (PB.0)  
+        - TIM2_CH2  pin (PB.2)  
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Connect the TIM2 pins to an oscilloscope 
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_PWMDutyCycleConfiguration/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.c	2018-04-05 05:30:32.000000000 +0200
***************
*** 0 ****
--- 1,187 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "main.h"
+ 
+ __IO MySin_Typedef sin ;/* Stores the sin structure */
+ __IO uint8_t counter = 0;   /* The counter variable for counting the Update cycles in TIM2 */
+ /* Private defines -----------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @addtogroup TIM2_SinewaveGeneration
+   * @{
+   */
+ 
+ /* This shows the value of the samples for the different no of samples in half
+ sine wave. The last value corresponds to the amplitude of the sine wave.*/
+ 
+ #if  nbr_of_samples_half == 16
+ CONST uint8_t sample[9]={0,20,38,56,71,83,92,98,100};
+ 
+ #elif  nbr_of_samples_half == 18
+ CONST uint8_t sample[10]={0,17,34,50,64,76,86,93,97,99};
+ 
+ #elif  nbr_of_samples_half == 22
+ CONST uint8_t sample[12]={0,14,28,42,54,65,76,84,91,96,99,100};
+ 
+ #elif  nbr_of_samples_half == 24
+ CONST uint8_t sample[13]={0,13,25,38,49,60,69,78,85,91,95,97,98};
+ 
+ #elif  nbr_of_samples_half == 26
+ CONST uint8_t sample[14]={0,12,24,35,46,56,66,74,81,88,93,96,98,99};
+ 
+ #elif  nbr_of_samples_half == 28
+ CONST uint8_t sample[15]={0,11,22,33,43,53,62,71,78,85,90,94,97,99,100};
+ 
+ #elif   nbr_of_samples_half == 30 
+ CONST uint8_t sample[16]={0,10,21,31,41,50,59,67,74,81,87,91,95,98,99,100};
+ 
+ #elif  nbr_of_samples_half == 46
+ CONST uint8_t sample[24]={0,7,13,20,26,33,39,45,51,57,62,67,72,76,80,84,87,90,92, \
+                      94,96,97,98,98};
+ #endif
+ /* Private defines -----------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ void LoadValueIntoSinStruct(void);
+ static void TIM_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ { 
+   /* select Clock = 4 MHz */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv4);
+   
+   /* Call LoadValueIntoSinStruct() & TIM_Config()*/
+   LoadValueIntoSinStruct();           
+ 
+   TIM_Config();
+ 
+   /* Enable interrupts*/
+   enableInterrupts();        
+   
+   /* Infinite loop*/
+   while(1)
+   {}
+ }  
+ 
+ /**
+   * @brief  Fill Sin Struncture with the correct values
+   * @param  None
+   * @retval None
+   */
+ void LoadValueIntoSinStruct(void)
+ {
+   uint8_t  offset=0,diff=0;
+   
+   while(offset <= (nbr_of_samples_half/2))
+   {
+       /*First half of upper half samples of sine wave is loaded into "value" of sin structure.*/
+       sin.Value[offset] = sample[offset]; 
+       offset++;                      
+   }
+   diff = (uint8_t)(offset - 1);
+   while(offset < nbr_of_samples_half)
+   {                                    
+       diff--;  
+       /* Second half of upper half samples of sine wave is loaded into "value" of sin structure.*/
+       sin.Value[offset] = sample[diff];    
+       offset++;                         
+   }
+   /*Index is initialized to 0.Sin wave upper half is generated at start*/
+   sin.Index = 0;                      
+   sin.Up = TRUE;                      
+ }
+ 
+ /**
+   * @brief  Configure TIM2 for the Sine wave generation
+   * @param  None
+   * @retval None
+   */
+ void TIM_Config(void)
+ {
+   /* Enable TIM2 clock */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE);
+   
+   /* Config TIM2 Channel 1 and channel 2 pins */
+   GPIO_Init(GPIOB, GPIO_Pin_0, GPIO_Mode_Out_PP_High_Fast);
+   
+   TIM2_DeInit();
+   
+   /* Time base configuration */
+   TIM2_TimeBaseInit(TIM2_Prescaler_1, TIM2_CounterMode_Up, INIT_TIM2_ARR);
+   
+   /* PWM configuration */
+   TIM2_OC1Init(TIM2_OCMode_PWM1, TIM2_OutputState_Enable,INIT_TIM2_CCR1, TIM2_OCPolarity_Low, TIM2_OCIdleState_Reset);
+   
+   /* Update Interrupt Enable */
+   TIM2_ITConfig(TIM2_IT_Update, ENABLE);
+   
+   /* ARRPreload Enable */
+   TIM2_ARRPreloadConfig(ENABLE);
+   
+   /* Enable TIM2 */
+   TIM2_Cmd(ENABLE);
+   
+   /* Enable CC1 output*/
+   TIM2_CtrlPWMOutputs(ENABLE);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/main.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,2718 ----
+ /**
+   ******************************************************************************
+   * @file    main.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains the defines for TIM2 Sinewave Generation example.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Private define ------------------------------------------------------------*/
+ #define FREQ_65_3595
+ /* #define FREQ_65_3083 */
+ /* #define FREQ_65_2316 */
+ /* #define FREQ_65_2061 */
+ /* #define FREQ_65_1890 */
+ /* #define FREQ_65_1042 */
+ /* #define FREQ_65_0407 */
+ /* #define FREQ_65_0280 */
+ /* #define FREQ_64_9351 */
+ /* #define FREQ_64_9013 */
+ /* #define FREQ_64_8340 */
+ /* #define FREQ_64_7501 */
+ /* #define FREQ_64_7249 */
+ /* #define FREQ_64_6412 */
+ /* #define FREQ_64_5995 */
+ /* #define FREQ_64_5661 */
+ /* #define FREQ_64_4745 */
+ /* #define FREQ_64_4122 */
+ /* #define FREQ_64_3501 */
+ /* #define FREQ_64_3004 */
+ /* #define FREQ_64_2013 */
+ /* #define FREQ_64_1026 */
+ /* #define FREQ_64_0615 */
+ /* #define FREQ_64_0041 */
+ /* #define FREQ_63_9304 */
+ /* #define FREQ_63_8366 */
+ /* #define FREQ_63_7755 */
+ /* #define FREQ_63_7105 */
+ /* #define FREQ_63_6618 */
+ /* #define FREQ_63_5728 */
+ /* #define FREQ_63_4921 */
+ /* #define FREQ_63_4196 */
+ /* #define FREQ_63_3955 */
+ /* #define FREQ_63_3112 */
+ /* #define FREQ_63_2111 */
+ /* #define FREQ_63_1313 */
+ /* #define FREQ_63_0517 */
+ /* #define FREQ_63_0040 */
+ /* #define FREQ_62_9327 */
+ /* #define FREQ_62_8457 */
+ /* #define FREQ_62_7943 */
+ /* #define FREQ_62_7510 */
+ /* #define FREQ_62_6566 */
+ /* #define FREQ_62_5626 */
+ /* #define FREQ_62_5000 */
+ /* #define FREQ_62_4376 */
+ /* #define FREQ_62_3830 */
+ /* #define FREQ_62_2859 */
+ /* #define FREQ_62_2355 */
+ /* #define FREQ_62_1388 */
+ /* #define FREQ_62_1118 */
+ /* #define FREQ_62_0347 */
+ /* #define FREQ_61_9348 */
+ /* #define FREQ_61_8429 */
+ /* #define FREQ_61_7856 */
+ /* #define FREQ_61_7284 */
+ /* #define FREQ_61_6371 */
+ /* #define FREQ_61_5385 */
+ /* #define FREQ_61_4439 */
+ /* #define FREQ_61_4213 */
+ /* #define FREQ_61_3422 */
+ /* #define FREQ_61_2595 */
+ /* #define FREQ_61_1621 */
+ /* #define FREQ_61_1172 */
+ /* #define FREQ_61_0501 */
+ /* #define FREQ_60_9719 */
+ /* #define FREQ_60_8828 */
+ /* #define FREQ_60_8162 */
+ /* #define FREQ_60_7607 */
+ /* #define FREQ_60_6870 */
+ /* #define FREQ_60_6061 */
+ /* #define FREQ_60_5180 */
+ /* #define FREQ_60_4741 */
+ /* #define FREQ_60_4047 */
+ /* #define FREQ_60_3318 */
+ /* #define FREQ_60_2773 */
+ /* #define FREQ_60_2228 */
+ /* #define FREQ_60_1902 */
+ /* #define FREQ_60_1251 */
+ /* #define FREQ_60_0601 */
+ /* #define FREQ_60_0240 */
+ /* #define FREQ_59_9305 */
+ /* #define FREQ_59_9089 */
+ /* #define FREQ_59_8480 */
+ /* #define FREQ_59_7907 */
+ /* #define FREQ_59_7729 */
+ /* #define FREQ_59_6516 */
+ /* #define FREQ_59_5735 */
+ /* #define FREQ_59_5238 */
+ /* #define FREQ_59_4177 */
+ /* #define FREQ_59_3542 */
+ /* #define FREQ_59_2592 */
+ /* #define FREQ_59_1856 */
+ /* #define FREQ_59_0902 */
+ /* #define FREQ_58_9971 */
+ /* #define FREQ_58_9345 */
+ /* #define FREQ_58_8512 */
+ /* #define FREQ_58_7889 */
+ /* #define FREQ_58_7372 */
+ /* #define FREQ_58_6441 */
+ /* #define FREQ_58_6029 */
+ /* #define FREQ_58_5103 */
+ /* #define FREQ_58_4795 */
+ /* #define FREQ_58_4112 */
+ /* #define FREQ_58_3567 */
+ /* #define FREQ_58_2751 */
+ /* #define FREQ_58_2242 */
+ /* #define FREQ_58_1395 */
+ /* #define FREQ_58_0720 */
+ /* #define FREQ_58_0114 */
+ /* #define FREQ_57_9609 */
+ /* #define FREQ_57_8704 */
+ /* #define FREQ_57_7901 */
+ /* #define FREQ_57_7501 */
+ /* #define FREQ_57_6901 */
+ /* #define FREQ_57_6037 */
+ /* #define FREQ_57_5109 */
+ /* #define FREQ_57_4911 */
+ /* #define FREQ_57_4218 */
+ /* #define FREQ_57_3394 */
+ /* #define FREQ_57_2344 */
+ /* #define FREQ_57_1559 */
+ /* #define FREQ_57_0776 */
+ /* #define FREQ_56_9801 */
+ /* #define FREQ_56_8925 */
+ /* #define FREQ_56_8182 */
+ /* #define FREQ_56_7279 */
+ /* #define FREQ_56_6316 */
+ /* #define FREQ_56_5611 */
+ /* #define FREQ_56_4780 */
+ /* #define FREQ_56_4207 */
+ /* #define FREQ_56_3730 */
+ /* #define FREQ_56_3063 */
+ /* #define FREQ_56_2303 */
+ /* #define FREQ_56_1545 */
+ /* #define FREQ_56_1167 */
+ /* #define FREQ_56_0538 */
+ /* #define FREQ_55_9848 */
+ /* #define FREQ_55_8909 */
+ /* #define FREQ_55_8628 */
+ /* #define FREQ_55_8036 */
+ /* #define FREQ_55_7414 */
+ /* #define FREQ_55_7041 */
+ /* #define FREQ_55_6297 */
+ /* #define FREQ_55_5556 */
+ /* #define FREQ_55_5001 */
+ /* #define FREQ_55_4324 */
+ /* #define FREQ_55_3710 */
+ /* #define FREQ_55_3097 */
+ /* #define FREQ_55_2608 */
+ /* #define FREQ_55_1633 */
+ /* #define FREQ_55_1146 */
+ /* #define FREQ_55_0237 */
+ /* #define FREQ_54_9451 */
+ /* #define FREQ_54_8968 */
+ /* #define FREQ_54_7975 */
+ /* #define FREQ_58_7345 */
+ /* #define FREQ_54_6717 */
+ /* #define FREQ_54_6329 */
+ /* #define FREQ_54_5554 */
+ /* #define FREQ_54_4662 */
+ /* #define FREQ_54_4010 */
+ /* #define FREQ_54_3241 */
+ /* #define FREQ_54_2535 */
+ /* #define FREQ_54_2005 */
+ /* #define FREQ_54_0950 */
+ /* #define FREQ_54_0774 */
+ /* #define FREQ_53_9811 */
+ /* #define FREQ_53_9374 */
+ /* #define FREQ_53_8677 */
+ /* #define FREQ_53_8097 */
+ /* #define FREQ_53_7634 */
+ /* #define FREQ_53_6769 */
+ /* #define FREQ_53_6423 */
+ /* #define FREQ_53_5447 */
+ /* #define FREQ_53_4445 */
+ /* #define FREQ_53_3504 */
+ /* #define FREQ_53_2822 */
+ /* #define FREQ_53_1971 */
+ /* #define FREQ_53_1011 */
+ /* #define FREQ_53_0223 */
+ /* #define FREQ_52_9773 */
+ /* #define FREQ_52_9101 */
+ /* #define FREQ_52_8541 */
+ /* #define FREQ_52_7649 */
+ /* #define FREQ_52_6759 */
+ /* #define FREQ_52_6094 */
+ /* #define FREQ_52_5100 */
+ /* #define FREQ_52_4439 */
+ /* #define FREQ_52_3670 */
+ /* #define FREQ_52_3122 */
+ /* #define FREQ_52_2575 */
+ /* #define FREQ_52_2139 */
+ /* #define FREQ_52_1268 */
+ /* #define FREQ_52_0915 */
+ /* #define FREQ_52_0075 */
+ /* #define FREQ_51_9481 */
+ /* #define FREQ_51_8888 */
+ /* #define FREQ_51_8242 */
+ /* #define FREQ_51_7411 */
+ /* #define FREQ_51_6529 */
+ /* #define FREQ_51_5677 */
+ /* #define FREQ_51_5145 */
+ /* #define FREQ_51_4192 */
+ /* #define FREQ_51_3321 */
+ /* #define FREQ_51_2715 */
+ /* #define FREQ_51_1876 */
+ /* #define FREQ_51_1300 */
+ /* #define FREQ_51_0308 */
+ /* #define FREQ_50_9580 */
+ /* #define FREQ_50_8751 */
+ /* #define FREQ_50_7924 */
+ /* #define FREQ_50_7305 */
+ /* #define FREQ_50_6586 */
+ /* #define FREQ_50_5663 */
+ /* #define FREQ_50_5051 */
+ /* #define FREQ_50_4439 */
+ /* #define FREQ_50_4032 */
+ /* #define FREQ_50_3221 */
+ /* #define FREQ_50_2311 */
+ /* #define FREQ_50_1781 */
+ /* #define FREQ_50_0801 */
+ /* #define FREQ_50_0200 */
+ /* #define FREQ_49_9500 */
+ /* #define FREQ_49_8604 */
+ /* #define FREQ_49_8107 */
+ /* #define FREQ_49_7240 */
+ /* #define FREQ_49_6327 */
+ /* #define FREQ_49_6032 */
+ /* #define FREQ_49_5148 */
+ /* #define FREQ_49_5000 */
+ /* #define FREQ_49_4071 */
+ /* #define FREQ_49_3681 */
+ /* #define FREQ_49_2732 */
+ /* #define FREQ_49_1836 */
+ /* #define FREQ_49_1352 */
+ /* #define FREQ_49_0581 */
+ /* #define FREQ_48_9620 */
+ /* #define FREQ_48_9045 */
+ /* #define FREQ_48_8400 */
+ /* #define FREQ_48_7424 */
+ /* #define FREQ_48_6760 */
+ /* #define FREQ_48_6239 */
+ /* #define FREQ_48_5248 */
+ /* #define FREQ_48_4496 */
+ /* #define FREQ_48_4097 */
+ /* #define FREQ_48_3302 */
+ /* #define FREQ_48_3092 */
+ /* #define FREQ_48_2253 */
+ /* #define FREQ_48_1974 */
+ /* #define FREQ_48_1000 */
+ /* #define FREQ_48_0031 */
+ /* #define FREQ_47_9869 */
+ /* #define FREQ_47_9478 */
+ /* #define FREQ_47_8721 */
+ /* #define FREQ_47_7829 */
+ /* #define FREQ_47_7464 */
+ /* #define FREQ_47_6463 */
+ /* #define FREQ_47_5647 */
+ /* #define FREQ_47_4654 */
+ /* #define FREQ_47_4226 */
+ /* #define FREQ_47_3485 */
+ /* #define FREQ_47_2590 */
+ /* #define FREQ_47_2010 */
+ /* #define FREQ_47_1343 */
+ /* #define FREQ_47_0544 */
+ /* #define FREQ_46_9814 */
+ /* #define FREQ_46_9219 */
+ /* #define FREQ_46_8516 */
+ /* #define FREQ_46_7639 */
+ /* #define FREQ_46_7115 */
+ /* #define FREQ_46_6505 */
+ /* #define FREQ_46_5636 */
+ /* #define FREQ_46_5030 */
+ /* #define FREQ_46_4511 */
+ /* #define FREQ_46_3671 */
+ /* #define FREQ_46_2963 */
+ /* #define FREQ_46_2535 */
+ /* #define FREQ_46_1723 */
+ /* #define FREQ_46_0914 */
+ /* #define FREQ_46_0575 */
+ /* #define FREQ_45_9791 */
+ /* #define FREQ_45_8884 */
+ /* #define FREQ_45_8631 */
+ /* #define FREQ_45_7875 */
+ /* #define FREQ_45_7059 */
+ /* #define FREQ_45_6704 */
+ /* #define FREQ_45_5976 */
+ /* #define FREQ_45_5000 */
+ /* #define FREQ_45_4091 */
+ /* #define FREQ_45_3515 */
+ /* #define FREQ_45_2960 */
+ /* #define FREQ_45_2223 */
+ /* #define FREQ_45_1671 */
+ /* #define FREQ_45_0938 */
+ /* #define FREQ_45_0369 */
+ /* #define FREQ_44_9843 */
+ /* #define FREQ_44_8934 */
+ 
+ 
+ #ifdef FREQ_65_3595
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xCB
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_65_3083
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE7
+        #define       INIT_TIM2_CCR1      0x73
+        #define       AVERAGE_AMP         0x73
+ #endif
+ 
+ #ifdef FREQ_65_2316
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_65_2061
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_65_1890
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_65_1042
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xEF
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_65_0407
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xCC
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_65_0280
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE8
+        #define       INIT_TIM2_CCR1      0x74
+        #define       AVERAGE_AMP         0x74
+ #endif
+ 
+ #ifdef FREQ_64_9351
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_64_9013
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_64_8340
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xF0
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_64_7501
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE9
+        #define       INIT_TIM2_CCR1      0x74
+        #define       AVERAGE_AMP         0x74
+ #endif
+ 
+ #ifdef FREQ_64_7249
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_64_6412
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_64_5995
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_64_5661
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xF1
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_64_4745
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xEA
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_64_4122
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xCE
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_64_3501
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_64_3004
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_64_2013
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_64_1026
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_64_0615
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_64_0041
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD8
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_63_8366
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF0
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_63_7755
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_63_7105
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_63_6618 
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xED
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_63_5728
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF1
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_63_4921
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_63_4196
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_63_3955 
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xEE
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_63_3112
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF2
+        #define       INIT_TIM2_CCR1      0x79
+        #define       AVERAGE_AMP         0x79
+ #endif
+ 
+ #ifdef FREQ_63_2111
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE1
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_63_1313
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_63_0517
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF3
+        #define       INIT_TIM2_CCR1      0x79
+        #define       AVERAGE_AMP         0x79
+ #endif
+ 
+ #ifdef FREQ_63_0040
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xF1
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_62_9327
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE2
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_62_8457
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_62_7943
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF4
+        #define       INIT_TIM2_CCR1      0x7A
+        #define       AVERAGE_AMP         0x7A
+ #endif
+ 
+ #ifdef FREQ_62_7510
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xF2
+        #define       INIT_TIM2_CCR1      0x79
+        #define       AVERAGE_AMP         0x79
+ #endif
+ 
+ #ifdef FREQ_62_6566
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE3
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_62_5626
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_62_5000
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xF9
+        #define       INIT_TIM2_CCR1      0x7C
+        #define       AVERAGE_AMP         0x7C
+ #endif
+ 
+ #ifdef FREQ_62_4376 
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_62_3830
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE4
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_62_2859
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF6
+        #define       INIT_TIM2_CCR1      0x7B
+        #define       AVERAGE_AMP         0x7B
+ #endif
+ 
+ #ifdef FREQ_62_2355
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_62_1388 
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD0
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_62_1118
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE5
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_62_0347
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF7
+        #define       INIT_TIM2_CCR1      0x7B
+        #define       AVERAGE_AMP         0x7B
+ #endif
+ 
+ #ifdef FREQ_61_9348
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCE
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_61_8429
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD1
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_61_7856
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF8
+        #define       INIT_TIM2_CCR1      0x7C
+        #define       AVERAGE_AMP         0x7C
+ #endif
+ 
+ #ifdef FREQ_61_7284
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_61_6371
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_61_5385
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF9
+        #define       INIT_TIM2_CCR1      0x7C
+        #define       AVERAGE_AMP         0x7C
+ #endif
+ 
+ #ifdef FREQ_61_4439
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xD8
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_61_4213
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xC8
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_61_3422
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD0
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_61_2595
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD3
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_61_1621
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_61_1172
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xC9
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_61_0501
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD1
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_60_9719
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_60_8828
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_60_8162
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xCA
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_60_7607
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD2
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_60_6870
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_60_6061
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_60_5180
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xCB
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_60_4741
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD3
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_60_4047
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_60_3318
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_60_2773
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_60_2228
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xCC
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_60_1902
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_60_1251
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_60_0601
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_60_0240
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xED
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_59_9305
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_59_9089
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_59_8480
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD8
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_59_7907
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_59_7729
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xEE
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_59_6516
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xFD
+        #define       INIT_TIM2_CCR1      0x7E
+        #define       AVERAGE_AMP         0x7E
+ #endif
+ 
+ #ifdef FREQ_59_5735
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_59_5238
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_59_4177
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xFE
+        #define       INIT_TIM2_CCR1      0x7F
+        #define       AVERAGE_AMP         0x7F
+ #endif
+ 
+ #ifdef FREQ_59_3542
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_59_2592
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_59_1856
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xFF
+        #define       INIT_TIM2_CCR1      0x7F
+        #define       AVERAGE_AMP         0x7F
+ #endif
+ 
+ #ifdef FREQ_59_0902
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD0
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_58_9971
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE1
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_58_9345
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xC9
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_58_8512
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_58_7889
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD1
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_58_7372
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE2
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_58_6441
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCA
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_58_6029
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_58_5103
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD2
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_58_4795
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE3
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_58_4112
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_58_3567
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCB
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_58_2751
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_58_2242
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xE4
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_58_1395
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_58_0720
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCC
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_58_0114
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_57_9609
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_57_8704
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_57_7901
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_57_7501
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_57_6901
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_57_6037
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xD8
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_57_5109 
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCE
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_57_4911
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_57_4218
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_57_3394
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_57_2344
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_57_1559
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_57_0776
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_56_9801
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_56_8925
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD8
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_56_8182
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_56_7279
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE1
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_56_6316
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_56_5611
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_56_4780
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE2
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_56_4207
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD2
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_56_3730
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_56_3063
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_56_2303
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE3
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_56_1545
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD3
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_56_1167
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_56_0538
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_55_9848
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE4
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_55_8909
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_55_8628
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_55_8036
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_55_7414
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE5
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_55_7041
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xCB
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_55_6297
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_55_5556
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_55_5001
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE6
+        #define       INIT_TIM2_CCR1      0x73
+        #define       AVERAGE_AMP         0x73
+ #endif
+ 
+ #ifdef FREQ_55_4324
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xCC
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_55_3710
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_55_3097
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xE1
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_55_2608
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE7
+        #define       INIT_TIM2_CCR1      0x73
+        #define       AVERAGE_AMP         0x73
+ #endif
+ 
+ #ifdef FREQ_55_1633
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_55_1146
+        #define       nbr_of_samples_half 28
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_55_0237
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xE8
+        #define       INIT_TIM2_CCR1      0x74
+        #define       AVERAGE_AMP         0x74
+ #endif
+ 
+ #ifdef FREQ_54_9451
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xC7
+        #define       INIT_TIM2_CCR1      0x63
+        #define       AVERAGE_AMP         0x63
+ #endif
+ 
+ #ifdef FREQ_54_8968
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xCE
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_54_7975
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_58_7345
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCA
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_54_6717
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xC8
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_54_6329
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_54_5554
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xEA
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_54_4662
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCB
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_54_4010
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xC9
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_54_3241
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_54_2535
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xFF
+        #define       INIT_TIM2_CCR1      0x7F
+        #define       AVERAGE_AMP         0x7F
+ #endif
+ 
+ #ifdef FREQ_54_2005
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCC
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_54_0950
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_54_0774
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xC8
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_53_9811
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF6
+        #define       INIT_TIM2_CCR1      0x7B
+        #define       AVERAGE_AMP         0x7B
+ #endif
+ 
+ #ifdef FREQ_53_9374
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_53_8677
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xED
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_53_8097
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xC9
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_53_7634
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             5
+        #define       INIT_TIM2_ARR       0xF7
+        #define       INIT_TIM2_CCR1      0x7B
+        #define       AVERAGE_AMP         0x7B
+ #endif
+ 
+ #ifdef FREQ_53_6769
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xCE
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_53_6423
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xEE
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_53_5447
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xCA
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_53_4445
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xF2
+        #define       INIT_TIM2_CCR1      0x79
+        #define       AVERAGE_AMP         0x79
+ #endif
+ 
+ #ifdef FREQ_53_3504
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_53_2822
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xCB
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_53_1971
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xF0
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_53_1011
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_53_0223
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xCC
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_52_9773
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xF1
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_52_9101
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_52_8541
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_52_7649
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_52_6759
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE1
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_52_6094
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_52_5100
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xCE
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_52_4439
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE2
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_52_3670
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xD8
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_52_3122
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_52_2575
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_52_2139
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE3
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_52_1268
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_52_0915
+        #define       nbr_of_samples_half 18
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_52_0075
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xD0
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_51_9481
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xF9
+        #define       INIT_TIM2_CCR1      0x7C
+        #define       AVERAGE_AMP         0x7C
+ #endif
+ 
+ #ifdef FREQ_51_8888
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_51_8242
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xC8
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_51_7411
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xFA
+        #define       INIT_TIM2_CCR1      0x7D
+        #define       AVERAGE_AMP         0x7D
+ #endif
+ 
+ #ifdef FREQ_51_6529
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_51_5677
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xC9
+        #define       INIT_TIM2_CCR1      0x64
+        #define       AVERAGE_AMP         0x64
+ #endif
+ 
+ #ifdef FREQ_51_5145
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xD2
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_51_4192
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_51_3321
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xFC
+        #define       INIT_TIM2_CCR1      0x7E
+        #define       AVERAGE_AMP         0x7E
+ #endif
+ 
+ #ifdef FREQ_51_2715
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xD3
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_51_1876
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_51_1300
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xFD
+        #define       INIT_TIM2_CCR1      0x7E
+        #define       AVERAGE_AMP         0x7E
+ #endif
+ 
+ #ifdef FREQ_51_0308
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_50_9580
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_50_8751
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xFB
+        #define       INIT_TIM2_CCR1      0x7D
+        #define       AVERAGE_AMP         0x7D
+ #endif
+ 
+ #ifdef FREQ_50_7924
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_50_7305
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_50_6586
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEA
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_50_5663
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xCD
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_50_5051
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_50_4439
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_50_4032
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             10
+        #define       INIT_TIM2_ARR       0xF7
+        #define       INIT_TIM2_CCR1      0x7B
+        #define       AVERAGE_AMP         0x7B
+ #endif
+ 
+ #ifdef FREQ_50_3221
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xCE
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_50_2311
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_50_1781
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_50_0801
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             8
+        #define       INIT_TIM2_ARR       0xCF
+        #define       INIT_TIM2_CCR1      0x67
+        #define       AVERAGE_AMP         0x67
+ #endif
+ 
+ #ifdef FREQ_50_0200
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xED
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_49_9500
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_49_8604
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_49_8107
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEE
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_49_7240
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_49_6327
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_49_6032
+        #define       nbr_of_samples_half 24
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEF
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_49_5148
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xCB
+        #define       INIT_TIM2_CCR1      0x65
+        #define       AVERAGE_AMP         0x65
+ #endif
+ 
+ #ifdef FREQ_49_5000
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_49_4071
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_49_3681
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD2
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_49_2732
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xCC
+        #define       INIT_TIM2_CCR1      0x66
+        #define       AVERAGE_AMP         0x66
+ #endif
+ 
+ #ifdef FREQ_49_1836
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_49_1352
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD3
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_49_0581
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_48_9620
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_48_9045
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_48_8400
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_48_7424
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_48_6760
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_48_6239
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE1
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_48_5248
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_48_4496
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_48_4097
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE2
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_48_3302
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD0
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_48_3092
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_48_2253
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_48_1974
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE3
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_48_1000
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD1
+        #define       INIT_TIM2_CCR1      0x68
+        #define       AVERAGE_AMP         0x68
+ #endif
+ 
+ #ifdef FREQ_48_0031
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD8
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_47_9869
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xE4
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_47_9478
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_47_8721
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD2
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_47_7829
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xD9
+        #define       INIT_TIM2_CCR1      0x6C
+        #define       AVERAGE_AMP         0x6C
+ #endif
+ 
+ #ifdef FREQ_47_7464
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             11
+        #define       INIT_TIM2_ARR       0xED
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_47_6463
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD3
+        #define       INIT_TIM2_CCR1      0x69
+        #define       AVERAGE_AMP         0x69
+ #endif
+ 
+ #ifdef FREQ_47_5647
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xDA
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_47_4654
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xE4
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_47_4226
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD4
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_47_3485
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xDB
+        #define       INIT_TIM2_CCR1      0x6D
+        #define       AVERAGE_AMP         0x6D
+ #endif
+ 
+ #ifdef FREQ_47_2590
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xE5
+        #define       INIT_TIM2_CCR1      0x72
+        #define       AVERAGE_AMP         0x72
+ #endif
+ 
+ #ifdef FREQ_47_2010
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD5
+        #define       INIT_TIM2_CCR1      0x6A
+        #define       AVERAGE_AMP         0x6A
+ #endif
+ 
+ #ifdef FREQ_47_1343
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_47_0544
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xE6
+        #define       INIT_TIM2_CCR1      0x73
+        #define       AVERAGE_AMP         0x73
+ #endif
+ 
+ #ifdef FREQ_46_9814
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD6
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_46_9219
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_46_8516
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xE7
+        #define       INIT_TIM2_CCR1      0x73
+        #define       AVERAGE_AMP         0x73
+ #endif
+ 
+ #ifdef FREQ_46_7639
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xD7
+        #define       INIT_TIM2_CCR1      0x6B
+        #define       AVERAGE_AMP         0x6B
+ #endif
+ 
+ #ifdef FREQ_46_7115
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_46_6505
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xE8
+        #define       INIT_TIM2_CCR1      0x74
+        #define       AVERAGE_AMP         0x74
+ #endif
+ 
+ #ifdef FREQ_46_5636
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_46_5030
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_46_4511
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xE9
+        #define       INIT_TIM2_CCR1      0x74
+        #define       AVERAGE_AMP         0x74
+ #endif
+ 
+ #ifdef FREQ_46_3671
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_46_2963
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_46_2535
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xEA
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_46_1723
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xED
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_46_0914
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xE1
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ #ifdef FREQ_46_0575
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xEB
+        #define       INIT_TIM2_CCR1      0x75
+        #define       AVERAGE_AMP         0x75
+ #endif
+ 
+ #ifdef FREQ_45_9791
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEE
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_45_8884
+        #define       nbr_of_samples_half 16
+        #define       COUNTER             12
+        #define       INIT_TIM2_ARR       0xE2
+        #define       INIT_TIM2_CCR1      0x71
+        #define       AVERAGE_AMP         0x71
+ #endif
+ 
+ #ifdef FREQ_45_8631
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xEC
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_45_7875
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xEF
+        #define       INIT_TIM2_CCR1      0x77
+        #define       AVERAGE_AMP         0x77
+ #endif
+ 
+ #ifdef FREQ_45_7059
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xDC
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_45_6704
+        #define       nbr_of_samples_half 46
+        #define       COUNTER             4
+        #define       INIT_TIM2_ARR       0xED
+        #define       INIT_TIM2_CCR1      0x76
+        #define       AVERAGE_AMP         0x76
+ #endif
+ 
+ #ifdef FREQ_45_5976
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xF0
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_45_5000
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xDD
+        #define       INIT_TIM2_CCR1      0x6E
+        #define       AVERAGE_AMP         0x6E
+ #endif
+ 
+ #ifdef FREQ_45_4091
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xF1
+        #define       INIT_TIM2_CCR1      0x78
+        #define       AVERAGE_AMP         0x78
+ #endif
+ 
+ #ifdef FREQ_45_3515
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xF4
+        #define       INIT_TIM2_CCR1      0x7A
+        #define       AVERAGE_AMP         0x7A
+ #endif
+ 
+ #ifdef FREQ_45_2960
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xDE
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_45_2223
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xF2
+        #define       INIT_TIM2_CCR1      0x79
+        #define       AVERAGE_AMP         0x79
+ #endif
+ 
+ #ifdef FREQ_45_1671
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xF5
+        #define       INIT_TIM2_CCR1      0x7A
+        #define       AVERAGE_AMP         0x7A
+ #endif
+ 
+ #ifdef FREQ_45_0938
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xDF
+        #define       INIT_TIM2_CCR1      0x6F
+        #define       AVERAGE_AMP         0x6F
+ #endif
+ 
+ #ifdef FREQ_45_0369
+        #define       nbr_of_samples_half 26
+        #define       COUNTER             7
+        #define       INIT_TIM2_ARR       0xF3
+        #define       INIT_TIM2_CCR1      0x79
+        #define       AVERAGE_AMP         0x79
+ #endif
+ 
+ #ifdef FREQ_44_9843
+        #define       nbr_of_samples_half 30
+        #define       COUNTER             6
+        #define       INIT_TIM2_ARR       0xF6
+        #define       INIT_TIM2_CCR1      0x7B
+        #define       AVERAGE_AMP         0x7B
+ #endif
+ 
+ #ifdef FREQ_44_8934
+        #define       nbr_of_samples_half 22
+        #define       COUNTER             9
+        #define       INIT_TIM2_ARR       0xE0
+        #define       INIT_TIM2_CCR1      0x70
+        #define       AVERAGE_AMP         0x70
+ #endif
+ 
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ typedef struct {
+   uint8_t Value[nbr_of_samples_half];
+   uint8_t Index;
+   bool Up;
+ }MySin_Typedef;
+ 
+ 
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,90 ----
+ /** @page TIM2_SinewaveGeneration Generate a sinewave in the range of 45Hz to 65Hz with the resolution of 0.1Hz
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    TIM2/TIM2_SinewaveGeneration/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the sine wave generation example with TIM2
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Example description
+ 
+   This example shows how user can get the variation in sine wave frequency from 65Hz
+   to 45Hz using TIM2. 
+     
+   TIM2 CLK is fixed to 4 MHz, the TIM2 Prescaler is equal to 0 so the TIM2 counter
+   clock used is 4 MHz. 
+   
+   The TIM2 Channel 1 is configured as PWM Output Mode 1.
+   
+   To generate a sine wave of frequency 65.3595, you have to uncomment "#define FREQ_65_3595"
+   (User can define only specific frequencies, which are commented out in "main.h"). 
+   According to frequency selected by define directive, five parameters will be defined. 
+   These parameters will make the corresponding sine wave frequency.
+   
+   The TIM2_CC1 must be connected to a "Low Pass" filter (Rfilter =1.8Kohm, Cfilter= 0.47uF)
+ 
+  @code  
+   TIM2_CC1 |-><-----[Rfilter=1.8Kohm]----+-------------> to the ossilloscope
+                                          |
+                   [Cfilter=0.47uF]
+                          |
+                       ///// GND
+  @endcode 
+ 
+   @par Directory content
+ 
+   - TIM2\TIM2_SinewaveGeneration\main.h               Defines macroes for all the frequencies in the range
+                                                       of 45Hz to 65Hz with the resolution of 0.1Hz. 
+   - TIM2\TIM2_SinewaveGeneration\main.c               Main file containing the "main" function
+   - TIM2\TIM2_SinewaveGeneration\stm8l10x_conf.h      Library Configuration file
+   - TIM2\TIM2_SinewaveGeneration\stm8l10x_it.c        Interrupt routines source
+   - TIM2\TIM2_SinewaveGeneration\stm8l10x_it.h        Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+      - Connect  TIM2_CC1 pin (PB.0) to a "Low Pass" filter (Rfilter =1.8Kohm, Cfilter= 0.47uF).
+      - Connect the "Low Pass" filter output to an oscilloscope.
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Connect TIM2_CC1 to a "Low Pass" Filter (Rfilter =1.8Kohm, Cfilter= 0.47uF)
+   - Connect the "Low Pass" filter output to an oscilloscope.
+ 
+  
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,367 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "main.h"
+ 
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ extern __IO MySin_Typedef sin ;
+ extern __IO uint8_t counter;
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+   uint8_t PWM_Value = 0;
+  if (counter >= COUNTER)               
+   { 
+     /* Reset the counter value*/
+     counter = 0;
+     /* Upper half cycle of sine wave */
+     if (sin.Up == TRUE)
+     {
+       /* Load the duty cycle register for upper half cycle of sine wave.*/ 
+       /* This is achieved by  adding sample values into AVERAGE_AMP.*/
+       PWM_Value = (uint8_t)(AVERAGE_AMP + sin.Value[sin.Index]);
+     }
+     else 
+     {
+       /* Lower half cycle of sine wave */ 
+       /* Load the duty cycle register for lower  half cycle of sine wave. */ 
+       /* This is achieved by   subtracting sample values into AVERAGE_AMP. */    
+       PWM_Value = (uint8_t)(AVERAGE_AMP - sin.Value[sin.Index]);
+     }
+     TIM2_SetCompare1(PWM_Value);
+     /*Increment the index for pointing to wardsnext sample value to be loaded */
+     sin.Index++;
+     if (sin.Index == nbr_of_samples_half) 
+     {
+       /* Reset the index value */
+       sin.Index = 0;
+       /* Lower half sin wave is activated if previously it was upper half and vice-versa */
+       sin.Up=(bool)(~sin.Up);
+     } 
+   }
+   /* Increment the counter value at each overflow interrupt */
+   counter++;
+ 
+   TIM2_ClearITPendingBit(TIM2_IT_Update);
+ 
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM2/TIM2_SinewaveGeneration/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/main.c	2018-04-05 05:29:14.000000000 +0200
***************
*** 0 ****
--- 1,153 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /**
+   * @addtogroup TIM3_SynchronisationwithTIM4
+   * @{
+   */
+ /* Private defines -----------------------------------------------------------*/
+ #define TIMEOUT ((uint8_t)0xFF)
+ /* Private function prototypes -----------------------------------------------*/
+ static void TIM_Config(void);
+ static FunctionalState TIM3_Status(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   __IO uint8_t Result = 0;
+   __IO uint8_t timeout = TIMEOUT;
+   
+   /* Initialize LED2 and LED3 */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   
+   /* Config TIM3 and TIM4 clocks */
+   TIM_Config();
+ 
+   while((TIM3_Status() == DISABLE) && (timeout != 0))
+   {
+     /* Decrement timeout */
+     timeout--;
+   }
+   
+   if (TIM3_Status() != DISABLE)
+   {
+     /*If the program counter reachs this section, 
+     the TIM3 is correctly triggered by TIM4 */
+     /*Insert break point in the folloing line */
+     Result = 1;
+     STM_EVAL_LEDToggle(LED2);
+   }
+   else
+   {
+     /*If the program counter reachs this section, 
+     the TIM3 is not correctly triggered by TIM4 */
+     /*Insert break point in the folloing line */
+     Result = 0;
+     STM_EVAL_LEDToggle(LED3);
+   }
+   /* infinite loop */
+   while(1)
+   {}
+ }
+ 
+ 
+ /**
+   * @brief  Configure TIM4 and TIM3 peripherals
+   * @param  None
+   * @retval None
+   */
+ static void TIM_Config(void)
+ {
+     /* Enable TIM3 CLK */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE);
+   
+   /* Enable TIM4 CLK */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM4, ENABLE);
+   
+   /*DeInit all TIM3 and TIM4 registers*/
+   TIM3_DeInit();
+   TIM4_DeInit();
+     
+   /* Time base configuration */
+   TIM3_TimeBaseInit(TIM3_Prescaler_1, TIM3_CounterMode_Up, 0xFF );
+   TIM4_TimeBaseInit(TIM4_Prescaler_1, 0xFF );
+ 
+   /* Select TIM4 Update event as source of TIM4 Trigger Output*/
+   TIM4_SelectOutputTrigger(TIM4_TRGOSource_Update);
+   
+   /* Select TIM4 as source of TIM3 Trigger Input*/
+   TIM3_SelectInputTrigger(TIM3_TRGSelection_TIM4);
+   
+   /* configurate TIM3 as slave of Trigger input*/
+   TIM3_SelectSlaveMode(TIM3_SlaveMode_Trigger);
+   
+     /*Enable TIM4*/
+   TIM4_Cmd(ENABLE);/* if this line is commented, TIM4 will not be enabled and */
+                    /* TIM3  will not detect an Edge on its TRGI => Result =0  */
+ }
+ 
+ static FunctionalState TIM3_Status(void)
+ {
+    return ((FunctionalState)(TIM3->CR1 & TIM_CR1_CEN));
+ }  
+   
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/readme.txt	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,73 ----
+ /** @page TIM3_SynchronisationWithTIM4 Synchronisation of TIM3 using TIM4
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    TIM4/TIM3_SynchronisationWithTIM4/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the synchronisation of TIM3 using TIM4 example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to use the TIM3 peripheral
+   synchronised by TIM4. TIM3 is configured as a slave of TIM4. 
+ 
+   TIM3 is configured to be enabled if it detects an edge on its input trigger (TRGI).
+   TIM4 is configured to generate an edge through its (TRGO) at the update event.
+   TIM3 TRGI is configured to be connected (internal connection) to TIM4 TRGO.
+ 
+   If line "Inc1:" in main.c is commented, TIM4 is not enabled => no Edge is detected on TIM3 TRGI),
+   ==> Result variable value will be equal to 0 (FAILED).
+   If line "Inc1" in main.c is uncommented, TIM4 is enabled => TIM4 generate an Edge on its TRGO and 
+   an Edge is detected on TIM3 TRGI. ==> Result variable value will be equal to 1 (PASS).
+ 
+ 
+   @par Directory content
+ 
+   - TIM4\TIM3_SynchronisationWithTIM4\main.c                       Main file containing the "main" function
+   - TIM4\TIM3_SynchronisationWithTIM4\stm8l10x_conf.h              Library Configuration file
+   - TIM4\TIM3_SynchronisationWithTIM4\stm8l10x_it.c                Interrupt routines source
+   - TIM4\TIM3_SynchronisationWithTIM4\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+      
+ @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Insert break point on main.c line "Inc2"
+   - Insert break point on main.c line "Inc3"
+  
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_conf.h	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.c	2014-10-21 14:13:28.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM3_SynchronisationWithTIM4/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/main.c	2018-04-05 05:29:09.000000000 +0200
***************
*** 0 ****
--- 1,106 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup TIM4_TimeBase
+   * @{
+   */
+ 
+ /* Private defines -----------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void TIM4_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   
+   /* TIM4 configuration ------------------------------------------------------*/
+   TIM4_Config();
+   
+   /* Toggles PB.0 in ISR routine*/
+   while (1)
+   {}
+ }
+ 
+ /**
+   * @brief  Configure TIM4 peripheral to generate an interrupt each 128s
+   * @param  None
+   * @retval None
+   */
+ static void TIM4_Config(void)
+ {
+   /* Enable TIM4 CLK */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM4, ENABLE);
+   
+   TIM4_DeInit();
+   
+   /* Time base configuration */ 
+   TIM4_TimeBaseInit(TIM4_Prescaler_1, 0xFF);
+   TIM4_ITConfig(TIM4_IT_Update, ENABLE);
+   
+   enableInterrupts();
+ 
+   /* Initialize I/Os in Output Mode */
+   GPIO_Init(GPIOB, GPIO_Pin_0, GPIO_Mode_Out_PP_Low_Fast);
+ 
+   /* Enable TIM4 */
+   TIM4_Cmd(ENABLE);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/readme.txt	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,75 ----
+ /** @page TIM4_TimeBase Toggling an output with TIM4 update interrupt 
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    TIM4/TIM4_TimeBase/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the TIM4 Time Base Example.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how to use the TIM4 peripheral
+   In this example, the PB.0 pin toggles each time the Update interrupt occurs
+   
+   The TIM4CLK frequency is 2MHz, the Prescaler is 1 so the TIM4 counter clock is 2MHz. 
+ 
+   The TIM4 is running at 7.8125 KHz: TIM4 Frequency = TIM4 counter clock/(ARR value + 1) 
+   So the TIM4 generates an Update Interrupt each 128 us.
+   
+   @note The square signal frequency on PB.0 is the half of Update Interrupt frequency
+    (signal Period = 2 x Update interrupt period).
+   
+ 
+ 
+   @par Directory content
+ 
+   - TIM4\TIM4_TimeBase\main.c                      Main file containing the "main" function
+   - TIM4\TIM4_TimeBase\stm8l10x_conf.h             Library Configuration file
+   - TIM4\TIM4_TimeBase\stm8l10x_it.c               Interrupt routines source
+   - TIM4\TIM4_TimeBase\stm8l10x_it.h               Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+     
+   - STM8L1x-EVAL Set-up
+    - Connect PB.0 pin to an oscilloscope.
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - Connect the PB.0 pin to an oscilloscope 
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_conf.h	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.c	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,332 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+   /* Toggle GPIOB PIN0 */ 
+   GPIO_ToggleBits(GPIOB, GPIO_Pin_0);
+ 
+   TIM4_ClearITPendingBit(TIM4_IT_Update);
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/TIM4/TIM4_TimeBase/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/main.c	2018-04-05 05:31:16.000000000 +0200
***************
*** 0 ****
--- 1,122 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup USART_HyperTerminalInterrupt
+   * @{
+   */
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void USART_Config(void);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+ 
+    /* USART Configuration -----------------------------------------------------*/
+    USART_Config();
+        
+    while (1)
+    {}
+ }
+ 
+ /**
+   * @brief  Configure USART peripheral
+   * @param  None
+   * @retval None
+   */
+ static void USART_Config(void)
+ {
+     /*High speed internal clock prescaler: 1*/
+     CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+     
+     /*Set the USART RX and USART TX at high level*/
+     GPIO_ExternalPullUpConfig(GPIOC,GPIO_Pin_3|GPIO_Pin_4, ENABLE);
+     
+     /* Enable USART clock */
+     CLK_PeripheralClockConfig(CLK_Peripheral_USART, ENABLE);
+     
+     USART_DeInit();
+     /* USART configuration ------------------------------------------------------*/
+     /* USART configured as follow:
+           - BaudRate = 9600 baud  
+           - Word Length = 8 Bits
+           - One Stop Bit
+           - Odd parity
+           - Receive and transmit enabled
+     */
+     USART_Init((uint32_t)9600, USART_WordLength_8D, USART_StopBits_1,
+                USART_Parity_Odd, (USART_Mode_TypeDef)(USART_Mode_Rx | USART_Mode_Tx));
+ 
+     /* Enable the USART Transmit interrupt: this interrupt is generated when the
+        USART transmit data register is empty */
+     USART_ITConfig(USART_IT_TXE, ENABLE);
+     /* Enable the USART Receive interrupt: this interrupt is generated when the
+        USART receive data register is not empty */
+     USART_ITConfig(USART_IT_RXNE, ENABLE);
+ 
+     /* Enable general interrupts */
+     enableInterrupts();
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,86 ----
+ /** @page USART_HyperTerminalInterrupt Communication between USART and hyperterminal using interrupts
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    USART/USART_HyperTerminalInterrupt/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the AWU example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a description of how  to use the USART interrupts to 
+   communicate with the hyperterminal.
+   The USART sends a predefined buffer to the hyperterminal and keep waiting 
+   for a string from the hyperterminal which length is defined by RxBufferSize. 
+   The communication is managed by Transmit and Receive interrupts. 
+ 
+   The USART is configured as follow:
+     - BaudRate = 9600 baud  
+     - Word Length = 8 Bits (Word Length = 7 data bit + 1 parity bit)
+     - One Stop Bit
+     - Odd parity
+     - Receive and transmit enabled
+     - USART Clock disabled
+   
+   @note When the parity is enabled, the computed parity is inserted at the MSB
+           position of the transmitted data.
+ 
+     
+   @par Directory content
+ 
+     - USART\USART_HyperTerminalInterrupt\main.c                  Main file containing the "main" function
+     - USART\USART_HyperTerminalInterrupt\stm8l10x_conf.h         Library Configuration file
+     - USART\USART_HyperTerminalInterrupt\stm8l10x_it.c           Interrupt routines source
+     - USART\USART_HyperTerminalInterrupt\stm8l10x_it.h           Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - Connect a null-modem female/female RS232 cable between the DB9 connector
+        CN8 and PC serial port.
+      - Hyperterminal configuration:
+       - Word Length = 7 Bits
+       - One Stop Bit
+       - Odd parity
+       - BaudRate = 9600 baud
+       - flow control: None
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+  
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,360 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "stm8l101_eval.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ #define TxBufferSize   (countof(TxBuffer) - 1)
+ #define RxBufferSize   0x20
+ 
+ /* Private macro -------------------------------------------------------------*/
+ #define countof(a)   (sizeof(a) / sizeof(*(a)))
+ /* Private variables ---------------------------------------------------------*/
+ uint8_t TxBuffer[] = "\n\rHyperTerminal Interrupt: USART-Hyperterminal communication using Interrupt\n\r";
+ 
+ uint8_t RxBuffer[RxBufferSize];
+ uint8_t NbrOfDataToTransfer = TxBufferSize;
+ uint8_t NbrOfDataToRead = RxBufferSize;
+ uint8_t TxCounter = 0;
+ uint16_t RxCounter = 0;
+ 
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+   STM_EVAL_LEDInit(LED2);
+   
+   /* Write one byte to the transmit data register */
+   USART_SendData8(TxBuffer[TxCounter++]);
+ 
+   if (TxCounter == NbrOfDataToTransfer)
+   {
+     STM_EVAL_LEDToggle(LED2);
+     /* Disable the USART Transmit interrupt */
+     USART_ITConfig(USART_IT_TXE, DISABLE);
+   }
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {  
+   STM_EVAL_LEDInit(LED3);
+   
+   /* Read one byte from the receive data register */
+   RxBuffer[RxCounter++] = (uint8_t) (USART_ReceiveData8() & 0x7F);
+ 
+   if (RxCounter == NbrOfDataToRead)
+   {
+     STM_EVAL_LEDToggle(LED3);
+     /* Disable the USART Receive interrupt */
+      USART_ITConfig(USART_IT_RXNE, DISABLE);
+   }
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_HyperTerminalInterrupt/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.c	2018-04-05 05:31:24.000000000 +0200
***************
*** 0 ****
--- 1,159 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "main.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /**
+   * @addtogroup USART_MultiProcessor
+   * @{
+   */
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+     /*Enable USART clock */
+     CLK_PeripheralClockConfig(CLK_Peripheral_USART, ENABLE);
+ 
+     /* Initialize KEY button */
+     STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+ 
+     /* Initialize the Interrupt sensitivity */
+     EXTI_SetPinSensitivity(EXTI_Pin_5, EXTI_Trigger_Rising);
+ 
+     enableInterrupts();
+ 
+     USART_DeInit();
+ 
+     /* USART configuration ------------------------------------------------------*/
+     /* USART configured as follow:
+           - BaudRate = 9600 baud  
+           - Word Length = 9 Bits
+           - One Stop Bit
+           - No parity
+           - Receive  enabled (USART_Slave)
+           - Transmit enabled (USART_Master)
+     */
+ #ifdef USART_Slave
+   /* Set the USART RX at high level*/
+   GPIO_ExternalPullUpConfig(GPIOC, GPIO_Pin_2, ENABLE);
+     
+   /* Initialize LED2,LED3 and LED4 */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+   
+   /*Initialize USART Config */  
+   USART_Init((uint32_t)9600, USART_WordLength_9D, USART_StopBits_1, USART_Parity_No,
+               USART_Mode_Rx);
+   
+   /* Enable the USART Receive interrupt: this interrupt is generated when the
+     USART receive data register is not empty */
+   USART_ITConfig(USART_IT_RXNE, ENABLE);
+ 
+   /* Set the USART Address */
+   USART_SetAddress(0x2);
+ 
+   /* Select the USART WakeUp Method */
+   USART_WakeUpConfig(USART_WakeUp_AddressMark);
+ 
+   STM_EVAL_LEDOn(LED2);
+   STM_EVAL_LEDOn(LED3);
+   STM_EVAL_LEDOn(LED4);
+   
+ #else /* USART_Master */
+   /*Set the USART USART TX at high level*/
+   GPIO_ExternalPullUpConfig(GPIOC, GPIO_Pin_3, ENABLE);
+     
+   USART_Init((uint32_t)9600, USART_WordLength_9D, USART_StopBits_1, USART_Parity_No,
+              USART_Mode_Tx);
+   /* Enable the USART Transmit interrupt: this interrupt is generated when the
+     USART transmit data register is empty */
+   USART_ITConfig(USART_IT_TXE, ENABLE);
+ 
+   /* Set the USART Address */
+   USART_SetAddress(0x1);
+ #endif /* USART_Slave */  
+     
+   /* Enable the USART */
+   USART_Cmd(ENABLE);
+ 
+   while (1)
+   {}
+ }
+ /**
+   * @brief Inserts a delay time.
+   * @param[in] nCount specifies the delay time length.
+   * @retval void None
+   * @par Required preconditions:
+   * - None
+   * @par Library functions called:
+   * - None
+   */
+ void Delay(uint32_t nCount)
+ {
+     /* Decrement nCount value */
+     for (; nCount != 0; nCount--);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/main.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,46 ----
+ /**
+   ******************************************************************************
+   * @file    main.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the prototypes of the main functions.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __MAIN_H
+ #define __MAIN_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #define USART_Master /*Uncomment this line to run the master in multiprocesor communication*/
+ //#define USART_Slave   /*Uncomment this line to run the Slave in multiprocesor communication*/ 
+ 
+ /* Exported functions ------------------------------------------------------- */
+ void Delay(uint32_t nCount);
+ 
+ #endif /* __MAIN_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,93 ----
+ /** @page USART_MultiProcessor Use the USART in multi-processor mode
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    USART/USART_MultiProcessor/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the USART multi-processor Example.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a description of how to use the USART in multi-processor mode.
+   The USART Master and USART Slave addresses are set to 0x1 and 0x2, 
+   respectively.
+    
+   - In the Master board (define USART_Master in main.h), USART Master continuously
+     sends the 0x33 character to second board (define USART_Slave in main.h) USART Slave. 
+   - In the Slave board, four LEDs (LD2, LD3 and LD4) are toggled while the USART receives 0x33.
+   - In the Slave board when KEY pushbutton is pressed, an interrupt is generated
+     and in the EXTI Interrupt service routine, the USART enters mute mode and 
+     remains in this mode (no LEDs toggling) 
+   - In the Master board when KEY pushbutton is pressed, an interrupt is 
+     generated and in the EXTI Interrupt service routine, USART Master sends the 
+     address mark character (0x102) to wake up USART Slave. 
+   - In the Slave board the USART slave receives the wake up and the LEDs restart 
+     toggling. 
+ 
+   USART Master and Slave configured as follow:
+   - BaudRate = 9600 baud  
+   - Word Length = 9 Bits
+   - One Stop Bit
+   - No parity
+   - Receive and transmit enabled
+ 
+               
+    @par Directory content
+ 
+   - USART\USART_MultiProcessor\main.c                       Main file containing the "main" function
+   - USART\USART_MultiProcessor\main.h                       Main functions prototype  
+   - USART\USART_MultiProcessor\stm8l10x_conf.h              Library Configuration file
+   - USART\USART_MultiProcessor\stm8l10x_it.c                Interrupt routines source
+   - USART\USART_MultiProcessor\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up    
+      - To run this example it is necessary to use two STM8L1x-EVAL boards: one to run
+        the USART Master and another to run the USART Salve 
+        Connect USART_Tx(PC.03) and USART_Rx(PC.02) on the first STM8L1x-EVAL board 
+        to respectively USART_Rx(PC.02) and USART_Tx(PC.03) on the second STM8L1x-EVAL
+        board( or connect a null-modem female/female RS232 cable between 2 STM8L1x-EVAL
+        boards: CN8 connector on each board).
+        Make sure that the two boards are connected to the same ground.
+     - Three leds LD2 to LD4 and Key push-button are used.
+     
+    
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example 
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,357 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "main.h"
+ #include "stm8l101_eval.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+ #ifdef USART_Master
+   USART_SendData9(0x102);
+   /* Wait while USART TXE = 0 */
+   while (USART_GetFlagStatus(USART_FLAG_TXE) == RESET);
+ #endif /* USART_Master */
+ 
+ #ifdef USART_Slave
+   if (USART_GetFlagStatus(USART_FLAG_OR) != RESET)
+   {
+     USART->SR;
+     USART_ReceiveData9();
+   }
+   /* Enable the USART mute mode*/
+   USART_ReceiverWakeUpCmd(ENABLE);
+ #endif /* USART_Slave  */
+ 
+   /* Clear interrupt pending bit */
+   EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   /* Send one byte from USART Master to Slave */
+   USART_SendData9(0x33);
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+   if (USART_ReceiveData9() == 0x33)
+   {
+     STM_EVAL_LEDToggle(LED2);
+     STM_EVAL_LEDToggle(LED3);
+     STM_EVAL_LEDToggle(LED4);
+     Delay(0x1FFF);
+   }
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_MultiProcessor/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/main.c	2018-04-05 05:31:27.000000000 +0200
***************
*** 0 ****
--- 1,150 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stdio.h"
+ /**
+   * @addtogroup USART_Printf
+   * @{
+   */
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ #ifdef _RAISONANCE_
+  #define PUTCHAR_PROTOTYPE int putchar (char c)
+  #define GETCHAR_PROTOTYPE int getchar (void)
+ #elif defined (_COSMIC_)
+  #define PUTCHAR_PROTOTYPE char putchar (char c)
+  #define GETCHAR_PROTOTYPE char getchar (void)
+ #elif defined (_SDCC_)                    /* SDCC patch: same types as stdio.h */
+  #if SDCC_VERSION >= 30600                  /* putchar() was changed for >=3.6.0, see sdcc manual */
+   #define PUTCHAR_PROTOTYPE int putchar (int c)
+  #else
+   #define PUTCHAR_PROTOTYPE void putchar (char c)
+  #endif 
+  #define GETCHAR_PROTOTYPE char getchar (void)
+ #else /* _IAR_ */
+  #define PUTCHAR_PROTOTYPE int putchar (int c)
+  #define GETCHAR_PROTOTYPE int getchar (void)
+ #endif
+ 
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void USART_Config(void);
+ 
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+     /* USART Configuration ---------------------------------------------------*/
+     USART_Config();
+     
+     /* Output a message on Hyperterminal using printf function */
+     printf("\n\rUSART Example: retarget the C library printf function to the USART\n\r");
+ 
+     while (1)
+     {}
+ }
+ 
+ /**
+   * @brief  Configure USART peripheral to print characters on Hyperteminal
+   * @param  None
+   * @retval None
+   */
+ static void USART_Config(void)
+ {
+     /* High speed internal clock prescaler: 1*/
+     CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+  
+      /*Set the USART RX and USART TX at high level*/
+     GPIO_ExternalPullUpConfig(GPIOC,GPIO_Pin_3|GPIO_Pin_4, ENABLE);
+     
+     /* Enable USART clock */
+     CLK_PeripheralClockConfig(CLK_Peripheral_USART, ENABLE);
+     
+     USART_DeInit();
+     /* USART configuration ------------------------------------------------------*/
+     /* USART configured as follow:
+           - BaudRate = 115200 baud  
+           - Word Length = 8 Bits
+           - One Stop Bit
+           - No parity
+           - Receive and transmit enabled
+     */
+      USART_Init((uint32_t)115200, USART_WordLength_8D, USART_StopBits_1,
+                 USART_Parity_No, (USART_Mode_TypeDef)(USART_Mode_Rx | USART_Mode_Tx));
+ }
+ 
+ /**
+   * @brief  Retargets the C library printf function to the USART.
+   * @param  c Character to send
+   * @retval char Character sent
+   */
+ PUTCHAR_PROTOTYPE
+ {
+   /* Write a character to the USART */
+   USART_SendData8(c);
+   
+   /* Loop until the end of transmission */
+   while (USART_GetFlagStatus(USART_FLAG_TXE) == RESET);
+ 
+   return (c);
+ }
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/readme.txt	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,80 ----
+ /** @page USART_Printf Retarget the C library printf function to the USART
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    USART/USART_Printf/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the USART retarget C library Example.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example shows how to retarget the C library printf function to the USART. 
+   This implementation output the printf message on the Hyperterminal using USART.
+ 
+   The USART is configured as follows:
+     - BaudRate = 115200 baud  
+     - Word Length = 8 Bits
+     - One Stop Bit
+     - No parity
+     - Receive and transmit enabled
+  
+ 
+   @par Directory content
+ 
+   - USART\USART_Printf\main.c                    Main file containing the "main" function
+   - USART\USART_Printf\stm8l10x_conf.h           Library Configuration file
+   - USART\USART_Printf\stm8l10x_it.c             Interrupt routines source (not used in this example)
+   - USART\USART_Printf\stm8l10x_it.h             Interrupt routines declaration
+ 
+ 
+    @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - Connect a null-modem female/female RS232 cable between the DB9 connector 
+        CN8 and PC serial port.  
+ 
+      - Hyperterminal configuration:
+        - Word Length = 8 Bits
+        - One Stop Bit
+        - No parity
+        - BaudRate = 115200 baud
+        - flow control: None 
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_conf.h	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Printf/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/main.c	2018-04-05 05:31:20.000000000 +0200
***************
*** 0 ****
--- 1,270 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /**
+   * @addtogroup USART_Synchronous
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ typedef enum {FAILED = 0, PASSED = !FAILED} TestStatus;
+ 
+ /* Private define ------------------------------------------------------------*/
+ #define TxBufferSize1   (countof(TxBuffer1) - 1)
+ #define TxBufferSize2   (countof(TxBuffer2) - 1)
+ #define DYMMY_BYTE      0x00
+ 
+ /* Private macro -------------------------------------------------------------*/
+ #define countof(a)   (sizeof(a) / sizeof(*(a)))
+ 
+ /* Private variables ---------------------------------------------------------*/
+ __IO TestStatus TransferStatus1 = FAILED, TransferStatus2 = FAILED;
+ 
+ /* Private function prototypes -----------------------------------------------*/
+ TestStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength);
+ void Delay (uint16_t nCount);
+ static void CLK_Config(void);
+ static void USART_Config(void);
+ static void SPI_Config(void);
+ 
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+ uint8_t TxBuffer1[] = "USART Example: USART -> SPI using TXE and RXNE Flags";
+ uint8_t TxBuffer2[] = "USART Example: SPI -> USART using TXE and RXNE Flags";
+ uint8_t RxBuffer1[TxBufferSize2];
+ uint8_t RxBuffer2[TxBufferSize1];
+ uint8_t NbrOfDataToRead1 = TxBufferSize2;
+ uint8_t NbrOfDataToRead2 = TxBufferSize1;
+ uint8_t TxCounter1 = 0, RxCounter1 = 0;
+ uint8_t TxCounter2 = 0, RxCounter2 = 0;
+ 
+   /* Clock config */
+   CLK_Config();
+     
+   /* USART config */
+   USART_Config();
+ 
+   /* SPI config */
+   SPI_Config();
+   
+   /* Enable the USART*/
+   USART_Cmd(ENABLE);
+   Delay(300);
+   
+   /* Enable the SPI*/
+   SPI_Cmd(ENABLE);
+   
+     while (NbrOfDataToRead2--)
+     {
+         /* Write one byte in the USART Transmit Data Register */
+         USART_SendData8(TxBuffer1[TxCounter1++]);
+         /* Wait until end of transmit */
+         while (USART_GetFlagStatus(USART_FLAG_TC) == RESET)
+         {
+         }
+         /* Wait the byte is entirtly received by SPI */
+         while (SPI_GetFlagStatus(SPI_FLAG_RXNE) == RESET)
+         {
+         }
+         /* Store the received byte in the RxBuffer2 */
+         RxBuffer2[RxCounter2++] = SPI_ReceiveData();
+     }
+ 
+     /* Clear the USART Data Register */
+     USART_ReceiveData8();
+ 
+     while (NbrOfDataToRead1--)
+     {
+         /* Wait until end of transmit */
+         while (SPI_GetFlagStatus(SPI_FLAG_TXE)== RESET)
+         {
+         }
+         /* Write one byte in the SPI Transmit Data Register */
+         SPI_SendData(TxBuffer2[TxCounter2++]);
+ 
+         /* Send a Dummy byte to generate clock to slave */
+         USART_SendData8(DYMMY_BYTE);
+         /* Wait until end of transmit */
+         while (USART_GetFlagStatus(USART_FLAG_TC) == RESET)
+         {
+         }
+         /* Wait the byte is entirtly received by USART */
+         while (USART_GetFlagStatus(USART_FLAG_RXNE) == RESET)
+         {
+         }
+         /* Store the received byte in the RxBuffer1 */
+         RxBuffer1[RxCounter1++] = USART_ReceiveData8();
+     }
+ 
+     /* Check the received data with the send ones */
+     TransferStatus1 = Buffercmp(TxBuffer1, RxBuffer2, TxBufferSize1);
+     /* TransferStatus = PASSED, if the data transmitted from USART and received by SPI are the same */
+     /* TransferStatus = FAILED, if the data transmitted from USART and received by SPI are different */
+     TransferStatus2 = Buffercmp(TxBuffer2, RxBuffer1, TxBufferSize2);
+     /* TransferStatus = PASSED, if the data transmitted from SPI and received by USART are the same */
+     /* TransferStatus = FAILED, if the data transmitted from SPI and received by USART1 are different */
+ 
+     while (1)
+     {}
+ }
+ 
+ /**
+   * @brief  Configure system clock
+   * @param  None
+   * @retval None
+   */
+ static void CLK_Config(void)
+ {
+     /*High speed internal clock prescaler: 1*/
+     CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+     
+     /* Enable USART clock */
+     CLK_PeripheralClockConfig(CLK_Peripheral_USART, ENABLE);
+     
+     /* Enable SPI clock */
+     CLK_PeripheralClockConfig(CLK_Peripheral_SPI, ENABLE);
+ }
+ 
+ /**
+   * @brief  Configure USART for the synchronous mode communication
+   * @param  None
+   * @retval None
+   */
+ static void USART_Config(void)
+ {
+      /*Set the USART RX and USART TX at high level*/
+   GPIO_ExternalPullUpConfig(GPIOC,GPIO_Pin_3|GPIO_Pin_4, ENABLE);
+      
+    /* USART configured as follow:
+           - Word Length = 8 Bits
+           - 1 Stop Bit
+           - No parity
+           - BaudRate = 9600 baud
+    */
+   USART_Init((uint32_t)9600, USART_WordLength_8D, USART_StopBits_1,
+              USART_Parity_No, (USART_Mode_TypeDef)(USART_Mode_Rx | USART_Mode_Tx));  
+   /* USART configured as follow:
+           - USART Clock enabled
+           - Polarity Low
+           - Phase Middle
+           - Last Bit enabled
+           - Receive and transmit enabled
+   */
+   USART_ClockInit(USART_Clock_Enable, USART_CPOL_Low, USART_CPHA_1Edge,USART_LastBit_Enable);
+   USART_Cmd(DISABLE);
+ }
+ 
+ /**
+   * @brief  Configure SPI for the full duplex communication with UART1
+   * @param  None
+   * @retval None
+   */
+ static void SPI_Config(void)
+ {
+   /*Set the MOSI,MISO and SCK at high level*/
+   GPIO_ExternalPullUpConfig(GPIOB,GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7, ENABLE);
+   
+   SPI_DeInit();
+   /* Initialize SPI in Slave mode  */
+   SPI_Init(SPI_FirstBit_LSB, SPI_BaudRatePrescaler_2, SPI_Mode_Slave, SPI_CPOL_Low,
+            SPI_CPHA_1Edge, SPI_Direction_2Lines_FullDuplex, SPI_NSS_Soft);
+ 
+ }
+ 
+ /**
+   * @brief  Compares two buffers.
+   * @param  pBuffer1 First buffer to be compared.
+   * @param  pBuffer2 Second buffer to be compared.
+   * @param  BufferLength Buffer's length
+   * @retval TestStatus Status of buffer comparison
+   * - PASSED: pBuffer1 identical to pBuffer2
+   * - FAILED: pBuffer1 differs from pBuffer2
+   */
+ TestStatus Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
+ {
+     while (BufferLength--)
+     {
+         if (*pBuffer1 != *pBuffer2)
+         {
+             return FAILED;
+         }
+ 
+         pBuffer1++;
+         pBuffer2++;
+     }
+ 
+     return PASSED;
+ }
+ 
+ /**
+   * @brief  Insert a delay.
+   * @param  nCount specifies the counter value.
+   * @retval none
+   */
+ void Delay (uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     for (; nCount != 0; nCount--);
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/readme.txt	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,98 ----
+ /** @page USART_Synchronous A basic communication between USART and SPI using flags
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    USART/USART_Synchronous/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the USART synchronuous mode example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a basic communication between USART (Synchronous mode) 
+   and SPI using flags.
+ 
+   First, the USART sends data from TxBuffer1 buffer to SPI using TXE flag.
+   Data received using RXNE flag by SPI is stored in RxBuffer2 then compared with
+   the sent ones and the result of this comparison is stored in the "TransferStatus1" 
+   variable.
+  
+   Then, the SPI sends data from TxBuffer2 buffer to USART using TXE flag.
+   Data received using RXNE flag by USART is stored in RxBuffer1 then compared with
+   the sent ones and the result of this comparison is stored in the "TransferStatus2" 
+   variable.   
+ 
+ 
+   The USART is configured as follows:
+     - BaudRate = 9600 baud  
+     - Word Length = 8 Bits
+     - One Stop Bit
+     - No parity
+     - Receive and transmit enabled
+     - USART Clock enabled
+     - USART CPOL: Clock is active low
+     - USART CPHA: Data is captured in middle of data bit 
+     - USART LastBit: The clock pulse of the last data bit is output to the SCLK pin
+ 
+   The SPI is configured as follows:
+     - Direction = 2 Lines FullDuplex
+     - Mode = Slave Mode
+     - DataSize = 8 Bits
+     - CPOL = Clock is active low
+     - CPHA = Data is captured on the first edge 
+     - NSS = NSS Software
+     - First Bit = First Bit is the LSB   
+ 
+ 
+   @par Directory content
+ 
+   - USART\USART_Synchronous\main.c                    Main file containing the "main" function
+   - USART\USART_Synchronous\stm8l10x_conf.h           Library Configuration file
+   - USART\USART_Synchronous\stm8l10x_it.c             Interrupt routines source (not used in this example)
+   - USART\USART_Synchronous\stm8l10x_it.h             Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - Connect USART TX (PC3) to SPI MOSI (PB6)
+      - Connect USART RX (PC2) to SPI MISO (PB7)
+      - Connect USART CK (PC4) to SPI SCK (PB5)
+ 
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_conf.h	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.c	2014-10-21 14:13:26.000000000 +0200
***************
*** 0 ****
--- 1,331 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/USART/USART_Synchronous/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/main.c	2018-04-05 05:29:49.000000000 +0200
***************
*** 0 ****
--- 1,124 ----
+ /**
+   ******************************************************************************
+   * @file    main.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Main program body
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l101_eval.h"
+ 
+ /**
+   * @addtogroup WFE_WakeUp
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ void Delay (uint16_t nCount);
+ /* Private functions ---------------------------------------------------------*/
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief  Main program.
+   * @param  None
+   * @retval None
+   */
+ void main(void)
+ {
+   /* Initialize LEDs mounted on the eval board */
+   STM_EVAL_LEDInit(LED2);
+   STM_EVAL_LEDInit(LED3);
+   STM_EVAL_LEDInit(LED4);
+   
+   STM_EVAL_LEDOn(LED2);
+   STM_EVAL_LEDOn(LED3);
+   STM_EVAL_LEDOn(LED4);
+   
+   STM_EVAL_PBInit(BUTTON_SEL, BUTTON_MODE_EXTI);
+   STM_EVAL_PBInit(BUTTON_KEY, BUTTON_MODE_EXTI);
+   
+   /* Set the input pin to generate the wake up signal*/
+    WFE_WakeUpSourceEventCmd(WFE_Source_EXTI_EV7, ENABLE);
+   
+   enableInterrupts();
+ 
+   wfe();
+   
+   /* The EXTI_IT_Pin7 interrupts is not served, user has to properly clear 
+      the corresponding status flags. */
+   EXTI_ClearITPendingBit(EXTI_IT_Pin7);
+   
+   while (1)
+   {
+     STM_EVAL_LEDToggle(LED2);
+     STM_EVAL_LEDToggle(LED3);
+     STM_EVAL_LEDToggle(LED4);
+     
+     Delay((uint16_t)60000);
+   }
+ }
+ /**
+   * @brief  Delay.
+   * @param  nCount
+   * @retval None
+   */
+ void Delay(uint16_t nCount)
+ {
+     /* Decrement nCount value */
+     while (nCount != 0)
+     {
+         nCount--;
+     }
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ { 
+   /* User can add his own implementation to report the file name and line number,
+      ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+   /* Infinite loop */
+   while (1)
+   {
+   }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/readme.txt	2014-10-21 14:13:22.000000000 +0200
***************
*** 0 ****
--- 1,76 ----
+ /** @page WFE_WakeUp wake up from wait for event mode
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file    WFE/WFE_WakeUp/readme.txt 
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   Description of the WFE example
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+   @par Example description
+ 
+   This example provides a short description of how the CPU operates when entering 
+   in wait for event mode.
+   After entering in WFE mode and when pressing the KEY button an interrupt is 
+   generated: the CPU wakes up from WFE mode and services the interrupt and goes 
+   back to  WFE mode..
+   When pressing the Joystick select button a WFE event occurs: the CPU wakes up 
+   and resumes processing without serving the interrupt.
+   
+ 
+   @par Directory content
+ 
+   - WFE\WFE_WakeUp\main.c                       Main file containing the "main" function
+   - WFE\WFE_WakeUp\stm8l10x_conf.h              Library Configuration file
+   - WFE\WFE_WakeUp\stm8l10x_it.c                Interrupt routines source
+   - WFE\WFE_WakeUp\stm8l10x_it.h                Interrupt routines declaration
+ 
+ 
+   @par Hardware and Software environment
+ 
+   - This example runs on STM8L10x devices.
+   
+   - This example has been tested with STMicroelectronics STM8L101-EVAL evaluation
+     board and can be easily tailored to any other development board.
+ 
+   - STM8L1x-EVAL Set-up
+      - LED2, LED3 and LED4
+      - Key push button
+      - Joystick SEL button
+ 
+   @par How to use it ?
+ 
+   In order to make the program work, you must do the following :
+ 
+   - Copy all source files from this example folder to the template folder under
+     Project\STM8L10x_StdPeriph_Templates
+   - Open your preferred toolchain 
+   - Rebuild all files and load your image into target memory
+   - Run the example
+   - The LED2, LED3 and LED4 are ON
+   - Firstly, press the Key button, an interrupt is generated the CPU wakes up from
+    WFE mode, toggles the LED2.
+   - Then press the Joystick select button, an event is generated: LD2, LD3 and
+    LD4 are blinking continuously.
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_conf.h	2014-10-21 14:13:22.000000000 +0200
***************
*** 0 ****
--- 1,82 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_conf.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment the line below to enable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ #define USE_FULL_ASSERT    1
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.c	2014-10-21 14:13:24.000000000 +0200
***************
*** 0 ****
--- 1,333 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l10x_it.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ #include "stm8l101_eval.h"
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ 
+ /* Public functions ----------------------------------------------------------*/
+ 
+ /**
+   * @brief Dummy interrupt routine
+   * @param  None
+   * @retval None
+   */
+ #ifdef _COSMIC_
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief TRAP interrupt routine
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+     STM_EVAL_LEDToggle(LED2);
+ 
+     EXTI_ClearITPendingBit(EXTI_IT_Pin5);
+ }
+ 
+ /**
+   * @brief External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Examples/WFE/WFE_WakeUp/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewd ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewd
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewd	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewd	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,228 ----
+ <?xml version="1.0" encoding="iso-8859-1"?>
+ 
+ <project>
+   <fileVersion>2</fileVersion>
+   <configuration>
+     <name>stm8l10x</name>
+     <toolchain>
+       <name>STM8</name>
+     </toolchain>
+     <debug>1</debug>
+     <settings>
+       <name>C-SPY</name>
+       <archiveVersion>1</archiveVersion>
+       <data>
+         <version>1</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>CSpyMandatory</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CSpyInput</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CSpyRunToEnable</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CSpyRunToName</name>
+           <state>main</state>
+         </option>
+         <option>
+           <name>CSpyMacOverride</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyMacFile</name>
+           <state></state>
+         </option>
+         <option>
+           <name>DynDriver</name>
+           <state>STLINK_STM8</state>
+         </option>
+         <option>
+           <name>CSpyDDFOverride</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyDDFFile</name>
+           <state>$TOOLKIT_DIR$\config\ddf\iostm8l101k3.ddf</state>
+         </option>
+         <option>
+           <name>CSpyEnableExtraOptions</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyExtraOptions</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CSpyImagesSuppressCheck1</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyImagesPath1</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CSpyImagesSuppressCheck2</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyImagesPath2</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CSpyImagesSuppressCheck3</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyImagesPath3</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CSpyImagesOffset1</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CSpyImagesOffset2</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CSpyImagesOffset3</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CSpyImagesUse1</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyImagesUse2</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CSpyImagesUse3</name>
+           <state>0</state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>SIMULATOR_STM8</name>
+       <archiveVersion>1</archiveVersion>
+       <data>
+         <version>0</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>SimMandatory</name>
+           <state>1</state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>STICE_STM8</name>
+       <archiveVersion>2</archiveVersion>
+       <data>
+         <version>1</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>STiceMandatory</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STiceSuppressLoad</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STiceVerifyLoad</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STiceLogFileOver</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STiceLogFile</name>
+           <state>$PROJ_DIR$\cspycomm.log</state>
+         </option>
+         <option>
+           <name>STiceUseSwim</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STiceOptionBytesSetupFileOver</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STiceOptionBytesSetupFile</name>
+           <state></state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>STLINK_STM8</name>
+       <archiveVersion>2</archiveVersion>
+       <data>
+         <version>1</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>STlinkMandatory</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STlinkSuppressLoad</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STlinkVerifyLoad</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STlinkLogFileOver</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STlinkLogFile</name>
+           <state>$PROJ_DIR$\cspycomm.log</state>
+         </option>
+         <option>
+           <name>STlinkOptionBytesSetupFileOver</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>STlinkOptionBytesSetupFile</name>
+           <state></state>
+         </option>
+       </data>
+     </settings>
+     <debuggerPlugins>
+       <plugin>
+         <file>$TOOLKIT_DIR$\plugins\rtos\embOS\embOSPlugin.ewplugin</file>
+         <loadFlag>0</loadFlag>
+       </plugin>
+       <plugin>
+         <file>$EW_DIR$\common\plugins\CodeCoverage\CodeCoverage.ENU.ewplugin</file>
+         <loadFlag>1</loadFlag>
+       </plugin>
+       <plugin>
+         <file>$EW_DIR$\common\plugins\Orti\Orti.ENU.ewplugin</file>
+         <loadFlag>0</loadFlag>
+       </plugin>
+       <plugin>
+         <file>$EW_DIR$\common\plugins\SymList\SymList.ENU.ewplugin</file>
+         <loadFlag>1</loadFlag>
+       </plugin>
+       <plugin>
+         <file>$EW_DIR$\common\plugins\uCProbe\uCProbePlugin.ENU.ewplugin</file>
+         <loadFlag>0</loadFlag>
+       </plugin>
+     </debuggerPlugins>
+   </configuration>
+ </project>
+ 
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewp ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewp
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewp	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.ewp	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,868 ----
+ <?xml version="1.0" encoding="iso-8859-1"?>
+ 
+ <project>
+   <fileVersion>2</fileVersion>
+   <configuration>
+     <name>stm8l10x</name>
+     <toolchain>
+       <name>STM8</name>
+     </toolchain>
+     <debug>1</debug>
+     <settings>
+       <name>General</name>
+       <archiveVersion>3</archiveVersion>
+       <data>
+         <version>1</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>GenDeviceSelectMenu</name>
+           <state>STM8L101K3T	STM8L101K3T</state>
+         </option>
+         <option>
+           <name>GenCodeModel</name>
+           <version>0</version>
+           <state>0</state>
+         </option>
+         <option>
+           <name>GenDataModel</name>
+           <version>0</version>
+           <state>1</state>
+         </option>
+         <option>
+           <name>GOutputBinary</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>ExePath</name>
+           <state>stm8l10x\Exe</state>
+         </option>
+         <option>
+           <name>ObjPath</name>
+           <state>stm8l10x\Obj</state>
+         </option>
+         <option>
+           <name>ListPath</name>
+           <state>stm8l10x\List</state>
+         </option>
+         <option>
+           <name>GenRuntimeLibSelect</name>
+           <version>0</version>
+           <state>1</state>
+         </option>
+         <option>
+           <name>GenRuntimeLibSelectSlave</name>
+           <version>0</version>
+           <state>1</state>
+         </option>
+         <option>
+           <name>GenRTDescription</name>
+           <state>Use the normal configuration of the C/EC++ runtime library. No locale interface, C locale, no file descriptor support, no multibytes in printf and scanf, and no hex floats in strtod.</state>
+         </option>
+         <option>
+           <name>GenRTConfigPath</name>
+           <state>$TOOLKIT_DIR$\LIB\dlstm8smn.h</state>
+         </option>
+         <option>
+           <name>GenLibInFormatter</name>
+           <version>0</version>
+           <state>2</state>
+         </option>
+         <option>
+           <name>GenLibInFormatterDescription</name>
+           <state>No specifier n, no float, no scan set, no assignment suppressing.</state>
+         </option>
+         <option>
+           <name>GenLibOutFormatter</name>
+           <version>0</version>
+           <state>2</state>
+         </option>
+         <option>
+           <name>GenLibOutFormatterDescription</name>
+           <state>No specifier a or A, no specifier n, no float.</state>
+         </option>
+         <option>
+           <name>GenStackSize</name>
+           <state>0x100</state>
+         </option>
+         <option>
+           <name>GenHeapSize</name>
+           <state>0x100</state>
+         </option>
+         <option>
+           <name>GeneralEnableMisra</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>GeneralMisraVerbose</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>GeneralMisraVer</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>GeneralMisraRules04</name>
+           <version>0</version>
+           <state>111101110010111111111000110111111111111111111111111110010111101111010101111111111111111111111111101111111011111001111011111011111111111111111</state>
+         </option>
+         <option>
+           <name>GeneralMisraRules98</name>
+           <version>0</version>
+           <state>1000111110110101101110011100111111101110011011000101110111101101100111111111111100110011111001110111001111111111111111111111111</state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>ICCSTM8</name>
+       <archiveVersion>3</archiveVersion>
+       <data>
+         <version>9</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>IccRequirePrototypes</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccLanguageConformance</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccCharIs</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccMultibyteSupport</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccOptLevel</name>
+           <state>3</state>
+         </option>
+         <option>
+           <name>IccOptStrategy</name>
+           <version>0</version>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccOptLevelSlave</name>
+           <state>3</state>
+         </option>
+         <option>
+           <name>IccOptAllowList</name>
+           <version>0</version>
+           <state>111111</state>
+         </option>
+         <option>
+           <name>IccGenerateDebugInfo</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccOutputFile</name>
+           <state>$FILE_BNAME$.o</state>
+         </option>
+         <option>
+           <name>IccCodeModel</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccDataModel</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccObjPrefix</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccLibConfigHeader</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CCDefines</name>
+           <state>USE_STDPERIPH_DRIVER</state>
+         </option>
+         <option>
+           <name>CCPreprocFile</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCPreprocComments</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCPreprocLine</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCListCFile</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCListCMnemonics</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCListCMessages</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCListAssFile</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCListAssSource</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCEnableRemarks</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCDiagSuppress</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CCDiagRemark</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CCDiagWarning</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CCDiagError</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CCDiagWarnAreErr</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CCCompilerRuntimeInfo</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>PreInclude</name>
+           <state></state>
+         </option>
+         <option>
+           <name>CCIncludePath2</name>
+           <state>$PROJ_DIR$\..</state>
+           <state>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\inc</state>
+           <state>$PROJ_DIR$\..\..\..\Utilities\STM8L101_EVAL</state>
+           <state>$PROJ_DIR$\..\..\..\Utilities\STM8L101_EVAL\Common</state>
+         </option>
+         <option>
+           <name>CCStdIncCheck</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CompilerMisraOverride</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CompilerMisraRules04</name>
+           <version>0</version>
+           <state>111101110010111111111000110111111111111111111111111110010111101111010101111111111111111111111111101111111011111001111011111011111111111111111</state>
+         </option>
+         <option>
+           <name>CompilerMisraRules98</name>
+           <version>0</version>
+           <state>1000111110110101101110011100111111101110011011000101110111101101100111111111111100110011111001110111001111111111111111111111111</state>
+         </option>
+         <option>
+           <name>IccUseExtraOptions</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccExtraOptions</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IccLang</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccCDialect</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccAllowVLA</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccCppDialect</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccNoVregs</name>
+           <version>0</version>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccOptNoSizeConstraints</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccCppInlineSemantics</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IccStaticDestr</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IccFloatSemantics</name>
+           <state>0</state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>ASTM8</name>
+       <archiveVersion>3</archiveVersion>
+       <data>
+         <version>2</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>AsmCaseSensitivity</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>AsmMultibyteSupport</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmAllowMnemonics</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmAllowDirectives</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmMacroChars</name>
+           <version>0</version>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmDebugInfo</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>AsmListFile</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmListNoDiagnostics</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmListIncludeCrossRef</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmListMacroDefinitions</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmListNoMacroExpansion</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmListAssembledOnly</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmListTruncateMultiline</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmStdIncludeIgnore</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmIncludePath</name>
+           <state></state>
+         </option>
+         <option>
+           <name>AsmDefines</name>
+           <state></state>
+         </option>
+         <option>
+           <name>AsmPreprocOutput</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmPreprocComment</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmPreprocLine</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmEnableRemarks</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmDiagnosticsSuppress</name>
+           <state></state>
+         </option>
+         <option>
+           <name>AsmDiagnosticsRemark</name>
+           <state></state>
+         </option>
+         <option>
+           <name>AsmDiagnosticsWarning</name>
+           <state></state>
+         </option>
+         <option>
+           <name>AsmDiagnosticsError</name>
+           <state></state>
+         </option>
+         <option>
+           <name>AsmDiagnosticsWarningsAreErrors</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmLimitNumberOfErrors</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmMaxNumberOfErrors</name>
+           <state>100</state>
+         </option>
+         <option>
+           <name>AsmCodeModel</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmDataModel</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmObjPrefix</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>AsmOutputFile</name>
+           <state>$FILE_BNAME$.o</state>
+         </option>
+         <option>
+           <name>AsmUseExtraOptions</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>AsmExtraOptions</name>
+           <state></state>
+         </option>
+         <option>
+           <name>AsmPreInclude</name>
+           <state></state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>OBJCOPY</name>
+       <archiveVersion>0</archiveVersion>
+       <data>
+         <version>0</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>OOCOutputFormat</name>
+           <version>2</version>
+           <state>0</state>
+         </option>
+         <option>
+           <name>OCOutputOverride</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>OOCOutputFile</name>
+           <state>project.srec</state>
+         </option>
+         <option>
+           <name>OOCCommandLineProducer</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>OOCObjCopyEnable</name>
+           <state>0</state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>CUSTOM</name>
+       <archiveVersion>3</archiveVersion>
+       <data>
+         <extensions></extensions>
+         <cmdline></cmdline>
+       </data>
+     </settings>
+     <settings>
+       <name>BICOMP</name>
+       <archiveVersion>0</archiveVersion>
+       <data/>
+     </settings>
+     <settings>
+       <name>BUILDACTION</name>
+       <archiveVersion>1</archiveVersion>
+       <data>
+         <prebuild></prebuild>
+         <postbuild></postbuild>
+       </data>
+     </settings>
+     <settings>
+       <name>ILINK</name>
+       <archiveVersion>3</archiveVersion>
+       <data>
+         <version>2</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>IlinkLibIOConfig</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>XLinkMisraHandler</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkInputFileSlave</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkOutputFile</name>
+           <state>stm8l101-eval.out</state>
+         </option>
+         <option>
+           <name>IlinkDebugInfoEnable</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IlinkKeepSymbols</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkRawBinaryFile</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkRawBinarySymbol</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkRawBinarySegment</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkRawBinaryAlign</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkDefines</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkConfigDefines</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkMapFile</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogFile</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogInitialization</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogModule</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogSection</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogVeneer</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkIcfOverride</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkIcfFile</name>
+           <state>$TOOLKIT_DIR$\config\lnkstm8l101k3.icf</state>
+         </option>
+         <option>
+           <name>IlinkIcfFileSlave</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkEnableRemarks</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkSuppressDiags</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkTreatAsRem</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkTreatAsWarn</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkTreatAsErr</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkWarningsAreErrors</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkStackSize</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IlinkHeapSize</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IlinkUseExtraOptions</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkExtraOptions</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkAutoLibEnable</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IlinkAdditionalLibs</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IlinkOverrideProgramEntryLabel</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkProgramEntryLabelSelect</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkProgramEntryLabel</name>
+           <state>__iar_program_start</state>
+         </option>
+         <option>
+           <name>DoFill</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>FillerByte</name>
+           <state>0xFF</state>
+         </option>
+         <option>
+           <name>FillerStart</name>
+           <state>0x0</state>
+         </option>
+         <option>
+           <name>FillerEnd</name>
+           <state>0x0</state>
+         </option>
+         <option>
+           <name>CrcSize</name>
+           <version>0</version>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CrcAlign</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CrcPoly</name>
+           <state>0x11021</state>
+         </option>
+         <option>
+           <name>CrcCompl</name>
+           <version>0</version>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CrcBitOrder</name>
+           <version>0</version>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CrcInitialValue</name>
+           <state>0x0</state>
+         </option>
+         <option>
+           <name>DoCrc</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>CrcFullSize</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkCspyDebugSupportEnable</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>IlinkCspyBufferedWrite</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogAutoLibSelect</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogRedirSymbols</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkLogUnusedFragments</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkCrcReverseByteOrder</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkCrcUseAsInput</name>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CrcAlgorithm</name>
+           <version>0</version>
+           <state>1</state>
+         </option>
+         <option>
+           <name>CrcUnitSize</name>
+           <version>0</version>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IlinkOptMergeDuplSections</name>
+           <state>0</state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>IARCHIVE</name>
+       <archiveVersion>3</archiveVersion>
+       <data>
+         <version>0</version>
+         <wantNonLocal>1</wantNonLocal>
+         <debug>1</debug>
+         <option>
+           <name>IarchiveInputs</name>
+           <state></state>
+         </option>
+         <option>
+           <name>IarchiveOverride</name>
+           <state>0</state>
+         </option>
+         <option>
+           <name>IarchiveOutput</name>
+           <state>###Unitialized###</state>
+         </option>
+       </data>
+     </settings>
+     <settings>
+       <name>BILINK</name>
+       <archiveVersion>0</archiveVersion>
+       <data/>
+     </settings>
+   </configuration>
+   <group>
+     <name>StdPeriph_Drivers</name>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_awu.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_beep.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_clk.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_comp.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_exti.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_flash.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_gpio.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_i2c.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_irtim.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_itc.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_iwdg.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_rst.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_spi.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_tim2.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_tim3.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_tim4.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_usart.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_wfe.c</name>
+     </file>
+   </group>
+   <group>
+     <name>STM8L101_EVAL</name>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Utilities\STM8L101_EVAL\stm8l101_eval.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\..\..\Utilities\STM8L101_EVAL\Common\stm8l_eval_lcd.c</name>
+     </file>
+   </group>
+   <group>
+     <name>User</name>
+     <file>
+       <name>$PROJ_DIR$\..\main.c</name>
+     </file>
+     <file>
+       <name>$PROJ_DIR$\..\stm8l10x_it.c</name>
+     </file>
+   </group>
+ </project>
+ 
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.eww ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.eww
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.eww	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/project.eww	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,10 ----
+ <?xml version="1.0" encoding="iso-8859-1"?>
+ 
+ <workspace>
+   <project>
+     <path>$WS_DIR$\project.ewp</path>
+   </project>
+   <batchBuild/>
+ </workspace>
+ 
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/EWSTM8/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/EWSTM8/readme.txt	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,59 ----
+ /** @page ewstm8 Template project for IAR Embedded Workbench for STM8 (EWSTM8)
+ 
+   @verbatim
+   ******************* (C) COPYRIGHT 2012 STMicroelectronics ********************
+   * @file     Project/STM8L10x_StdPeriph_Templates/EWSTM8/readme.txt
+   * @author   MCD Application Team
+   * @version  V1.2.0
+   * @date     01-June-2012
+   * @brief    This sub-directory contains all the user-modifiable files needed to
+   *           create a new project linked with the STM8L10x Standard Peripherals 
+   *           Library and working with IAR Embedded Workbench for STM8 (EWSTM8)
+   *           software toolchain.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Description
+ 
+   This folder contains a standard EWSTM8 template workspace including all the 
+   user-modifiable files that are necessary to create a new project.
+   These project templates can be used by mean of minor updates in the library files
+   to run theSTM8L10x_StdPeriph_Examples, or custom user applications.  
+ 
+   
+   @par Directories contents
+ 
+  - project .ewd/.eww/.ewp: A pre-configured project file with the provided library 
+                            structure that produces an executable image with IAR 
+                            Embedded Workbench.
+ 
+ 
+   @par How to use it ?
+ 
+  - Open the Project.eww workspace.
+      @note The needed define symbols for the project configurations are already 
+            declared in the preprocessor section.
+ 
+  - Rebuild all files: Project->Rebuild all
+  - Load project image: Project->Debug
+  - Run program: Debug->Go(F5)
+   
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a Flash memory density up to 8 Kbytes.
+   
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/main.c	2018-04-05 05:29:05.000000000 +0200
***************
*** 0 ****
--- 1,77 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/main.c
+   * @author   MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief    This file contains the firmware main function.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Templates
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ void main(void)
+ {
+     /* Infinite loop */
+     while (1)
+     {
+     }
+ 
+ }
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ {
+     /* User can add his own implementation to report the file name and line number,
+        ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+     /* Infinite loop */
+     while (1)
+     {
+     }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+   
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/readme.txt	2017-08-16 15:08:47.000000000 +0200
***************
*** 0 ****
--- 1,57 ----
+ /**
+   @page exampletemplate Project Example Template
+   
+   @verbatim
+   ******************** (C)COPYRIGHT 2014 STMicroelectronics *******************
+   * @file     Project/STM8L10x_StdPeriph_Templates/readme.txt 
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This sub-directory contains all the user-modifiable files 
+   *           needed to create a new project linked with the STM8L10x  
+   *           Standard Peripheral Library.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+ 
+ @par Project Example Template Description 
+ 
+ This example is used as a template that can be used as reference to build any new 
+ firmware development for all STM8L10x product devices using the STM8L10x
+ Standard Peripherals Library.
+ 
+ 
+ @par Directory contents 
+ 
+ This folder contains standard template projects for EWSTM8, SDCC, STVD with Cosmic, 
+ STVD with raisonance and RIDE toolchains that compile the needed STM8L10x Standard
+ Peripheral's drivers plus all the user-modifiable files that are necessary to 
+ create a new project. 
+ 
+   - Project/STM8L10x_StdPeriph_Templates/stm8l10x_conf.h    Library Configuration file
+ 
+   - Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.c:     Source file containing the interrupt handlers (the 
+                                      function bodies are empty in this template).
+ 
+   - Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h      Header file including all interrupt handlers prototypes.
+ 
+   - Project/STM8L10x_StdPeriph_Templates/main.c             Main program
+ 
+           
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a flash memory density up to 8 Kbytes.  
+  
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/Release_Notes.html ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/Release_Notes.html
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/Release_Notes.html	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/Release_Notes.html	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,353 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+ <html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+ 
+ 
+ 
+ 
+ <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+ <link rel="File-List" href="Release_Notes%20%28package%29_files/filelist.xml">
+ <link rel="Edit-Time-Data" href="Release_Notes%20%28package%29_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>STM8L10x Standard Peripherals Library Templates Release Notes</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>tguilhot</o:LastAuthor> <o:Revision>145</o:Revision> <o:TotalTime>461</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2010-12-13T14:14:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>358</o:Words> <o:Characters>2045</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>17</o:Lines> <o:Paragraphs>4</o:Paragraphs> <o:CharactersWithSpaces>2399</o:CharactersWithSpaces> <o:Version>11.9999</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:View>Normal</w:View> <w:SpellingState>Clean</w:SpellingState> <w:GrammarState>Clean</w:GrammarState> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:Compatibility> <w:UseFELayout/> </w:Compatibility> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->
+ 
+ 
+ 
+ <style>
+ <!--
+ /* Font Definitions */
+ @font-face
+ {font-family:Wingdings;
+ panose-1:5 0 0 0 0 0 0 0 0 0;
+ mso-font-charset:2;
+ mso-generic-font-family:auto;
+ mso-font-pitch:variable;
+ mso-font-signature:0 268435456 0 0 -2147483648 0;}
+ @font-face
+ {font-family:"MS Mincho";
+ panose-1:2 2 6 9 4 2 5 8 3 4;
+ mso-font-alt:"Arial Unicode MS";
+ mso-font-charset:128;
+ mso-generic-font-family:roman;
+ mso-font-format:other;
+ mso-font-pitch:fixed;
+ mso-font-signature:1 134676480 16 0 131072 0;}
+ @font-face
+ {font-family:Verdana;
+ panose-1:2 11 6 4 3 5 4 4 2 4;
+ mso-font-charset:0;
+ mso-generic-font-family:swiss;
+ mso-font-pitch:variable;
+ mso-font-signature:536871559 0 0 0 415 0;}
+ @font-face
+ {font-family:"\@MS Mincho";
+ panose-1:0 0 0 0 0 0 0 0 0 0;
+ mso-font-charset:128;
+ mso-generic-font-family:roman;
+ mso-font-format:other;
+ mso-font-pitch:fixed;
+ mso-font-signature:1 134676480 16 0 131072 0;}
+ /* Style Definitions */
+ p.MsoNormal, li.MsoNormal, div.MsoNormal
+ {mso-style-parent:"";
+ margin:0cm;
+ margin-bottom:.0001pt;
+ mso-pagination:widow-orphan;
+ font-size:12.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"Times New Roman";}
+ h1
+ {mso-margin-top-alt:auto;
+ margin-right:0cm;
+ mso-margin-bottom-alt:auto;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ mso-outline-level:1;
+ font-size:24.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"MS Mincho";
+ font-weight:bold;}
+ h2
+ {mso-style-next:Normal;
+ margin-top:12.0pt;
+ margin-right:0cm;
+ margin-bottom:3.0pt;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ page-break-after:avoid;
+ mso-outline-level:2;
+ font-size:14.0pt;
+ font-family:Arial;
+ mso-fareast-font-family:"MS Mincho";
+ font-weight:bold;
+ font-style:italic;}
+ h3
+ {mso-margin-top-alt:auto;
+ margin-right:0cm;
+ mso-margin-bottom-alt:auto;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ mso-outline-level:3;
+ font-size:13.5pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"MS Mincho";
+ font-weight:bold;}
+ a:link, span.MsoHyperlink
+ {color:blue;
+ text-decoration:underline;
+ text-underline:single;}
+ a:visited, span.MsoHyperlinkFollowed
+ {color:blue;
+ text-decoration:underline;
+ text-underline:single;}
+ p
+ {mso-margin-top-alt:auto;
+ margin-right:0cm;
+ mso-margin-bottom-alt:auto;
+ margin-left:0cm;
+ mso-pagination:widow-orphan;
+ font-size:12.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"Times New Roman";}
+ @page Section1
+ {size:612.0pt 792.0pt;
+ margin:72.0pt 90.0pt 72.0pt 90.0pt;
+ mso-header-margin:36.0pt;
+ mso-footer-margin:36.0pt;
+ mso-paper-source:0;}
+ div.Section1
+ {page:Section1;}
+ /* List Definitions */
+ @list l0
+ {mso-list-id:1315182333;
+ mso-list-template-ids:555131286;}
+ @list l0:level1
+ {mso-level-tab-stop:36.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level2
+ {mso-level-tab-stop:72.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level3
+ {mso-level-tab-stop:108.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level4
+ {mso-level-tab-stop:144.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level5
+ {mso-level-tab-stop:180.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level6
+ {mso-level-tab-stop:216.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level7
+ {mso-level-tab-stop:252.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level8
+ {mso-level-tab-stop:288.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l0:level9
+ {mso-level-tab-stop:324.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1
+ {mso-list-id:2024673066;
+ mso-list-template-ids:154433278;}
+ @list l1:level1
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0A7;
+ mso-level-tab-stop:36.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ mso-ansi-font-size:10.0pt;
+ font-family:Wingdings;}
+ @list l1:level2
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0B7;
+ mso-level-tab-stop:72.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ mso-ansi-font-size:10.0pt;
+ font-family:Symbol;}
+ @list l1:level3
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0B0;
+ mso-level-tab-stop:108.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ font-family:Symbol;}
+ @list l1:level4
+ {mso-level-tab-stop:144.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level5
+ {mso-level-tab-stop:180.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level6
+ {mso-level-tab-stop:216.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level7
+ {mso-level-tab-stop:252.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level8
+ {mso-level-tab-stop:288.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l1:level9
+ {mso-level-tab-stop:324.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2
+ {mso-list-id:2095200852;
+ mso-list-type:hybrid;
+ mso-list-template-ids:-391638944 67698693 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
+ @list l2:level1
+ {mso-level-number-format:bullet;
+ mso-level-text:\F0A7;
+ mso-level-tab-stop:36.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;
+ font-family:Wingdings;}
+ @list l2:level2
+ {mso-level-tab-stop:72.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level3
+ {mso-level-tab-stop:108.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level4
+ {mso-level-tab-stop:144.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level5
+ {mso-level-tab-stop:180.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level6
+ {mso-level-tab-stop:216.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level7
+ {mso-level-tab-stop:252.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level8
+ {mso-level-tab-stop:288.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ @list l2:level9
+ {mso-level-tab-stop:324.0pt;
+ mso-level-number-position:left;
+ text-indent:-18.0pt;}
+ ol
+ {margin-bottom:0cm;}
+ ul
+ {margin-bottom:0cm;}
+ -->
+ </style><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Table Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0cm 5.4pt 0cm 5.4pt; mso-para-margin:0cm; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-fareast-font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]-->
+ <style type="disc">
+ </style><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="45058"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]--><meta content="MCD Application Team" name="author"></head>
+ <body link="blue" vlink="blue">
+ <div class="Section1">
+ <p class="MsoNormal"><span style="font-family: Arial;"><br>
+ </span><span style="font-family: Arial;"><o:p></o:p></span></p>
+ <div align="center">
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+ <tbody>
+ <tr style="">
+ <td style="padding: 0cm;" valign="top">
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+ <tbody>
+ <tr style="">
+ <td style="padding: 1.5pt;">
+ 
+ <h1 style="margin-bottom: 18pt; text-align: center;" align="center"><span style="font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);">Release
+ Notes for<o:p></o:p> </span><span style="font-size: 20pt; color: rgb(51, 102, 255); font-family: Verdana;">STM8L10x Standard Peripherals Library Templates (StdPeriph_Templates)<br>
+ </span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span></h1>
+ <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;">Copyright
+  2014 STMicroelectronics</span><span style="color: black;"><u1:p></u1:p><o:p></o:p></span></p>
+ <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt;"><img style="border: 0px solid ; width: 86px; height: 65px;" alt="" id="_x0000_i1025" src="../../_htmresc/st_logo.png"></span></p>
+ </td>
+ </tr>
+ </tbody>
+ </table>
+ <p class="MsoNormal"><span style="font-family: Arial; display: none;"><o:p>&nbsp;</o:p></span></p>
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+ <tbody>
+ <tr style="">
+ <td style="padding: 0cm;" valign="top">
+ <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;">ContentsS<o:p></o:p></span></h2>
+ <ol style="margin-top: 0cm;" start="1" type="1">
+ <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#History">STM8L10x Standard Peripherals Library Templates update history</a><o:p></o:p></span></li>
+ <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#License">License</a><o:p></o:p></span></li>
+ </ol>
+             <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="History"></a><span style="font-size: 12pt; color: white;">STM8L10x Standard Peripherals Library Templates update history<o:p></o:p></span></h2>
+ 
+ 
+ <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; width: 197px; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 558.05pt;"><span style="font-family: Arial; color: white; font-size: 10pt;">1.2.1 /30-September-2014</span></h3>
+ <p style="margin: 4.5pt 0cm 4.5pt 18pt;" class="MsoNormal"><b><u><span style="font-family: Verdana; color: black; font-size: 10pt;">Main 
+ Changes<o:p></o:p></span></u></b></p>
+ <ul style="margin-top: 0in;" type="disc"><li style="margin-top: 4.5pt; margin-bottom: 4.5pt; color: black;" class="MsoNormal"><b><i><span style="font-family: Verdana; font-size: 10pt;">STM8L10x_StdPeriph_Template: 
+ Template projects update:</span></i></b><span style="font-family: Verdana; font-size: 10pt;"></span>
+ <ul><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;">ST 
+ Visual Develop (STVD) software toolchain</span> 
+ <ul><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;">STVD 
+ Version 4.3.6</span> 
+ </li><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;">Cosmic 
+ STM8 32K compiler Version 4.3.12 (or later)</span> 
+ </li><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;">Raisonance STM8/ST7 C compiler 
+ Version 2.52.13.0324</span></li></ul></li></ul>
+ <ul><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;">Raisonance IDE RIDE7 (RIDE) 
+ software toolchain</span> 
+ <ul><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;">Version: 
+ RIDE7 IDE:7.48.13.0324, RKit-STM8 for </span><span style="font-family: Verdana; font-size: 10pt;">2.52.13.0324</span></li></ul></li></ul>
+ <ul><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;"><span class="MsoNormal">IAR Embedded Workbench for</span> STM8 IDE (EWSTM8) software 
+ toolchain</span> 
+ <ul><li class="MsoNormal"><span style="font-family: Verdana; font-size: 10pt;">Version 
+ v1.42.1</span><br><span style="font-size: 10pt; font-family: Arial; color: white;"></span></li></ul></li></ul></li></ul><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 500pt; width: 167px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.2.0 /01-June-2012<o:p></o:p></span></h3><p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+ Changes<o:p></o:p></span></u></b></p>
+ <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Rename project to&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;">stm8l10x</span> 
+ in all the workspaces with the different toolchains.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add new template project 
+ folder for <span style="font-weight: bold; font-style: italic;">IAR Embedded 
+ Workbench for STM8 </span></span><span style="font-weight: bold; font-size: 10pt; font-style: italic; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-weight: bold; font-style: italic;">(EWSTM8)</span> </span><span style="font-size: 10pt; font-family: Verdana;">toolchain</span><span style="font-size: 10pt; font-family: Verdana;">.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Update </span><span style="font-size: 10pt; font-family: Verdana;">the different project 
+ preprocessors with new "Utilities" folders names.</span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Update the <span style="font-style: italic;">stm8l10x_it.c/.h</span> files&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic;"><span style="font-weight: bold;"></span></span></span><span style="font-size: 10pt; font-family: Verdana;">to support&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-style: italic; font-weight: bold;">EWSTM8 </span>toolchain</span><span style="font-size: 10pt; font-family: Verdana;">.</span></li></ul><span style="font-size: 10pt; font-family: Verdana;"></span><ul style="margin-top: 0cm;" type="square"></ul>
+ 
+ <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="License"></a><span style="font-size: 12pt; color: white;">License<o:p></o:p></span></h2><p class="MsoNormal" style="margin-right: 4cm; line-height: normal; margin-left: 0.85cm; text-align: left; font-family: Arial;"><span style="font-size: 10pt; color: black;">Licensed under MCD-ST Liberty SW License Agreement V2, (the "License").
+ You may not use this file except in compliance with the License.
+ You may obtain a copy of the License at:
+ 
+ 
+ </span></p>
+ <dl style="text-align: center; font-family: Arial;"><dd><span style="font-size: 10pt;">
+ <a href="http://www.st.com/software_license_agreement_liberty_v2"> http://www.st.com/software_license_agreement_liberty_v2</a></span></dd></dl>
+ <dl><dd><span style="font-size: 10pt; color: black;"><span style="font-family: Arial;">Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.</span>
+ </span></dd></dl><p class="MsoNormal" style="margin: 4.5pt 0cm;"><b><span style="font-size: 10pt; font-family: Verdana; color: black;"></span></b><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p>
+ <div class="MsoNormal" style="text-align: center;" align="center"><span style="color: black;">
+ <hr align="center" size="2" width="100%"></span></div>
+ <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt; text-align: center;" align="center"><span style="font-size: 10pt; font-family: Verdana; color: black;">For
+ complete documentation on </span><span style="font-size: 10pt; font-family: Verdana;">STMicroelectronics<span style="color: black;"> Microcontrollers visit </span><a target="_blank" href="http://www.st.com/internet/mcu/family/141.jsp"><u><span style="color: blue;">www.st.com</span></u></a></span><span style="color: black;"><o:p></o:p></span></p>
+ </td>
+ </tr>
+ </tbody>
+ </table>
+ <p class="MsoNormal"><span style="font-size: 10pt;"><o:p></o:p></span></p>
+ </td>
+ </tr>
+ </tbody>
+ </table>
+ </div>
+ <p class="MsoNormal"><o:p>&nbsp;</o:p></p>
+ </div>
+ </body></html>
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/RIDE/project.rprj ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/RIDE/project.rprj
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/RIDE/project.rprj	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/RIDE/project.rprj	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,4 ----
+ 
+ <Project Header="Project 'stm8l10x'" Path=".\project.rprj" Project="Yes" OutputFile="" sate="96" ActiveApp="stm8l10x" >
+ 	<ApplicationBuild Header="stm8l10x" Extern=".\stm8l10x.rapp" Path=".\stm8l10x.rapp" OutputFile=".\Debug\stm8l10x.aof" sate="98" >		</ApplicationBuild>
+ </Project>
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/RIDE/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/RIDE/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/RIDE/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/RIDE/readme.txt	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,54 ----
+ /** @page project_RIDE Template project for RIDE toolchain with Raisonance compiler
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2012 STMicroelectronics *******************
+   * @file     Project/STM8L10x_StdPeriph_Templates/RIDE/readme.txt 
+   * @author   MCD Application Team
+   * @version  V1.2.0
+   * @date     01-June-2012
+   * @brief    This sub-directory contains all the user-modifiable files needed
+   *           to create a new project linked with the STM8L Standard Peripheral 
+   *           Library and working with RIDE7 toolchain.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Project description
+ 
+   This folder contains a standard RIDE template workspace with a project 
+   including all the user-modifiable files that are necessary to create a new project.
+   This project template can be used by mean of minor updates in the library files
+   to run the StdPeriph_Lib examples, or custom user applications.
+   
+   
+   @par Directories contents
+ 
+   -  Project\STM8L10x_StdPeriph_Templates\\RIDE
+      - project.rprj              Workspace file
+      - stm8l10x.rapp             Project file for STM8L10x devices  
+ 
+ 
+   @par How to use it ?
+ 
+   - Open the RIDE workspace (project.rprj)
+   - Rebuild all files: : Project -> Build (Alt+F9)
+   - Load project image: Debug->Load(Ctrl+L)
+   - Run program: Debug->Start (Ctrl+D)
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a flash memory density up to 8 Kbytes.  
+  
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/RIDE/stm8l10x.rapp ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/RIDE/stm8l10x.rapp
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/RIDE/stm8l10x.rapp	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/RIDE/stm8l10x.rapp	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,123 ----
+ 
+ <ApplicationBuild Header="stm8l10x" Extern=".\stm8l10x.rapp" Path=".\stm8l10x.rapp" OutputFile=".\Debug\stm8l10x.aof" sate="98" >
+ 	<Group Header="User" Marker="-1" OutputFile="" sate="96" >
+ 		<NodeC Path="..\main.c" Header="main.c" Marker="0" OutputFile=".\Debug\main.obj" sate="0" >
+ 			<Options>
+ 				<Config Header="Standard" >
+ 					<Set Header="RCST7" >
+ 						<Section Header="CodeGen" >
+ 							<Property Header="UNSIGNEDCHAR" Value="" Removable="1" />
+ 							<Property Header="ENUMTYPE" Value="ET(INT)" Removable="1" />
+ 																																																																																																																														
+ 						</Section>
+ 																																																																																																										
+ 					</Set>
+ 					<Set Header="Target" >
+ 						<Section Header="ToolSetST7" >
+ 							<Property Header="ArelocInfo" Value="" Removable="1" />
+ 																																			
+ 						</Section>
+ 																													
+ 					</Set>
+ 																		
+ 				</Config>
+ 														
+ 			</Options>
+ 																																													
+ 		</NodeC>
+ 		<NodeC Path="..\stm8l10x_it.c" Header="stm8l10x_it.c" Marker="-1" OutputFile=".\Debug\stm8l10x_it.obj" sate="0" />
+ 																											
+ 	</Group>
+ 	<Group Header="StdPeriph_Lib" Marker="-1" OutputFile="" sate="0" >
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_awu.c" Header="stm8l10x_awu.c" Marker="-1" OutputFile=".\Debug\stm8l10x_awu.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_beep.c" Header="stm8l10x_beep.c" Marker="-1" OutputFile=".\Debug\stm8l10x_beep.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_clk.c" Header="stm8l10x_clk.c" Marker="-1" OutputFile=".\Debug\stm8l10x_clk.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_comp.c" Header="stm8l10x_comp.c" Marker="-1" OutputFile=".\Debug\stm8l10x_comp.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_exti.c" Header="stm8l10x_exti.c" Marker="-1" OutputFile=".\Debug\stm8l10x_exti.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_flash.c" Header="stm8l10x_flash.c" Marker="-1" OutputFile=".\Debug\stm8l10x_flash.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_gpio.c" Header="stm8l10x_gpio.c" Marker="-1" OutputFile=".\Debug\stm8l10x_gpio.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_i2c.c" Header="stm8l10x_i2c.c" Marker="-1" OutputFile=".\Debug\stm8l10x_i2c.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_irtim.c" Header="stm8l10x_irtim.c" Marker="-1" OutputFile=".\Debug\stm8l10x_irtim.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_itc.c" Header="stm8l10x_itc.c" Marker="-1" OutputFile=".\Debug\stm8l10x_itc.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_iwdg.c" Header="stm8l10x_iwdg.c" Marker="-1" OutputFile=".\Debug\stm8l10x_iwdg.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_rst.c" Header="stm8l10x_rst.c" Marker="-1" OutputFile=".\Debug\stm8l10x_rst.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_spi.c" Header="stm8l10x_spi.c" Marker="-1" OutputFile=".\Debug\stm8l10x_spi.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_tim2.c" Header="stm8l10x_tim2.c" Marker="-1" OutputFile=".\Debug\stm8l10x_tim2.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_tim3.c" Header="stm8l10x_tim3.c" Marker="-1" OutputFile=".\Debug\stm8l10x_tim3.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_tim4.c" Header="stm8l10x_tim4.c" Marker="-1" OutputFile=".\Debug\stm8l10x_tim4.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_usart.c" Header="stm8l10x_usart.c" Marker="-1" OutputFile=".\Debug\stm8l10x_usart.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Libraries\STM8L10x_StdPeriph_Driver\src\stm8l10x_wfe.c" Header="stm8l10x_wfe.c" Marker="-1" OutputFile=".\Debug\stm8l10x_wfe.obj" sate="0" />
+ 			
+ 	</Group>
+ 	<Group Header="STM8L_EVAL" Marker="-1" OutputFile="" sate="96" >
+ 		<NodeC Path="..\..\..\Utilities\STM8L101_EVAL\stm8l101_eval.c" Header="stm8l101_eval.c" Marker="-1" OutputFile=".\Debug\stm8l101_eval.obj" sate="0" />
+ 		<NodeC Path="..\..\..\Utilities\STM8L101_EVAL\Common\stm8l_eval_lcd.c" Header="stm8l_eval_lcd.c" Marker="-1" OutputFile=".\Debug\stm8l_eval_lcd.obj" sate="0" />
+ 			
+ 	</Group>
+ 	<Options>
+ 		<Config Header="Standard" >
+ 			<Set Header="ApplicationBuild" >
+ 				<Section Header="General" >
+ 					<Property Header="TargetFamily" Value="ST7" />
+ 																																																																																								
+ 				</Section>
+ 				<Section Header="Directories" >
+ 					<Property Header="IncDir" Value="$(ApplicationDir)\..;$(ApplicationDir)\..\..\..\Libraries\STM8L10x_StdPeriph_Driver\inc;$(ApplicationDir)\..\..\..\Utilities\STM8L101_EVAL;$(RkitInc);$(RkitInc)\ST7;$(ApplicationDir)\..\..\..\Utilities\STM8L101_EVAL\Common" Removable="1" />
+ 					<Property Header="OutDir" Value="$(ApplicationDir)\Debug" Removable="1" />
+ 					<Property Header="ListDir" Value="$(ApplicationDir)\Debug" Removable="1" />
+ 																
+ 				</Section>
+ 												
+ 			</Set>
+ 			<Set Header="Target" >
+ 				<Section Header="ProcessorST7" >
+ 					<Property Header="Processor" Value="STM8L101K3" Removable="1" />
+ 																																																																																								
+ 				</Section>
+ 				<Section Header="ToolSetST7" >
+ 					<Property Header="BuildToolSetST7" Value="ST7\\RaisonanceTools.config" Removable="1" />
+ 					<Property Header="ArelocInfo" Value="" Removable="1" />
+ 							
+ 				</Section>
+ 				<Section Header="DebugST7" >
+ 					<Property Header="DebugTool_STM8" Value="RLINK_STM8" Removable="1" />
+ 																																																																															
+ 				</Section>
+ 					
+ 			</Set>
+ 			<Set Header="RCST7" >
+ 				<Section Header="CodeGen" >
+ 					<Property Header="ENUMTYPE" Value="ET(INT)" Removable="1" />
+ 					<Property Header="INITSTAT" Value="INITSTATICVAR" Removable="1" />
+ 																																		
+ 				</Section>
+ 				<Section Header="OPTIM" >
+ 					<Property Header="OTLEVEL" Value="3" Removable="1" />
+ 																									
+ 				</Section>
+ 																			
+ 			</Set>
+ 			<Set Header="MAST7" >
+ 				<Section Header="Listing" >
+ 					<Property Header="GenLST" Value="" Removable="1" />
+ 					<Property Header="GenCOND" Value="" Removable="1" />
+ 					<Property Header="InclPROG" Value="NOLI" Removable="1" />
+ 																																																				
+ 				</Section>
+ 				<Section Header="Set" >
+ 					<Property Header="More" Value="MODESTM8" Removable="1" />
+ 																																																																						
+ 				</Section>
+ 																																					
+ 			</Set>
+ 			<Set Header="RLST7" >
+ 				<Section Header="Output" >
+ 					<Property Header="ExtendedBin" Value="" Removable="1" />
+ 							
+ 				</Section>
+ 					
+ 			</Set>
+ 		</Config>
+ 	</Options>
+ 			
+ </ApplicationBuild>
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/Makefile ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/Makefile
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/Makefile	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/Makefile	2017-11-19 09:01:32.000000000 +0100
***************
*** 0 ****
--- 1,77 ----
+ #######
+ # makefile for STM8*_StdPeriph_Lib and SDCC compiler
+ #
+ # note: paths in this Makefile assume unmodified SPL folder structure
+ #
+ # usage:
+ #   1. if SDCC not in PATH set path -> CC_ROOT
+ #   2. set correct STM8 device -> DEVICE
+ #   3. set project paths -> PRJ_ROOT, PRJ_SRC_DIR, PRJ_INC_DIR
+ #   4. set SPL paths -> SPL_ROOT
+ #   5. add required SPL modules -> SPL_SOURCE
+ #   6. add required STM8L101_EVAL modules -> EVAL_SOURCE, EVAL_COMM_SOURCE
+ #
+ #######
+ 
+ # STM8 device (doesn't matter here, just for Makefile)
+ DEVICE=STM8L10x
+ 
+ # set compiler path & parameters 
+ CC_ROOT =
+ CC      = sdcc
+ CFLAGS  = -mstm8 -lstm8 --opt-code-size
+ 
+ # set output folder and target name
+ OUTPUT_DIR = ./$(DEVICE)
+ TARGET     = $(OUTPUT_DIR)/$(DEVICE).hex
+ 
+ # set project folder and files (all *.c)
+ PRJ_ROOT    = ..
+ PRJ_SRC_DIR = $(PRJ_ROOT)
+ PRJ_INC_DIR = $(PRJ_ROOT)
+ PRJ_SOURCE  = $(notdir $(wildcard $(PRJ_SRC_DIR)/*.c))
+ PRJ_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(PRJ_SOURCE:.c=.rel))
+ 
+ # set SPL paths
+ SPL_ROOT    = ../../..
+ SPL_SRC_DIR = $(SPL_ROOT)/Libraries/STM8L10x_StdPeriph_Driver/src
+ SPL_INC_DIR = $(SPL_ROOT)/Libraries/STM8L10x_StdPeriph_Driver/inc
+ SPL_SOURCE  = stm8l10x_gpio.c
+ SPL_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(SPL_SOURCE:.c=.rel))
+ 
+ # set path to STM8L101_EVAL board routines
+ EVAL_DIR     = $(SPL_ROOT)/Utilities/STM8L101_EVAL
+ EVAL_SOURCE  = 
+ EVAL_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(EVAL_SOURCE:.c=.rel))
+ 
+ # set path to STM8L101_EVAL common routines
+ EVAL_COMM_DIR    = $(EVAL_DIR)/Common
+ EVAL_COMM_SOURCE  = 
+ EVAL_COMM_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(EVAL_COMM_SOURCE:.c=.rel))
+ 
+ 
+ # collect all include folders
+ INCLUDE = -I$(PRJ_SRC_DIR) -I$(SPL_INC_DIR) -I$(EVAL_DIR) -I$(EVAL_COMM_DIR)
+ 
+ # collect all source directories
+ VPATH=$(PRJ_SRC_DIR):$(SPL_SRC_DIR):$(EVAL_DIR):$(EVAL_COMM_DIR)
+ 
+ .PHONY: clean
+ 
+ all: $(OUTPUT_DIR) $(TARGET)
+ 
+ $(OUTPUT_DIR):
+ 	mkdir -p $(OUTPUT_DIR)
+ 
+ $(OUTPUT_DIR)/%.rel: %.c
+ 	$(CC) $(CFLAGS) $(INCLUDE) -D$(DEVICE) -c $?
+ 
+ $(OUTPUT_DIR)/%.rel: %.c
+ 	$(CC) $(CFLAGS) $(INCLUDE) -D$(DEVICE) -c $? -o $@
+ 
+ $(TARGET): $(PRJ_OBJECTS) $(SPL_OBJECTS) $(EVAL_OBJECTS) $(EVAL_COMM_OBJECTS)
+ 	$(CC) $(CFLAGS) -o $(TARGET) $^
+ 
+ clean: 
+ 	rm -fr $(OUTPUT_DIR)
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_clean.sh ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_clean.sh
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_clean.sh	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_clean.sh	2017-11-19 09:02:04.000000000 +0100
***************
*** 0 ****
--- 1,20 ----
+ #!/bin/bash 
+ 
+ # change to current working directory
+ cd `dirname $0`
+ 
+ # just for output
+ echo off
+ clear
+ 
+ # target device (doesn't matter here)
+ DEVICE=STM8L10x
+ 
+ # set make tool (if not in PATH, set complete path)
+ MAKE=make
+ 
+ # use Makefiles to delete outputs
+ $MAKE -f Makefile DEVICE=$DEVICE clean 
+ 
+ echo on
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_compile_run.sh ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_compile_run.sh
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_compile_run.sh	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_UX_compile_run.sh	2017-11-19 09:02:34.000000000 +0100
***************
*** 0 ****
--- 1,44 ----
+ #!/bin/bash 
+ 
+ # change to current working directory
+ cd `dirname $0`
+ 
+ # just for output
+ clear
+ 
+ # target device (doesn't matter here)
+ DEVICE=STM8L10x
+ 
+ # set make tool (if not in PATH, set complete path)
+ MAKE=make
+ 
+ # STM8L10x has no bootloader, see tech note UM0560 and TN0189 on http://www.st.com
+ 
+ # set SWIM upload tool and device name (stm8flash from https://github.com/vdudouyt/stm8flash)
+ SWIM_LOADER=~/ffentlich/GitHub/stm8flash/stm8flash
+ SWIM_TOOL=stlink
+ SWIM_DEVICE=stm8l101?3
+ 
+ # target hexfile
+ TARGET=./$DEVICE/$DEVICE.hex
+ 
+ # make project
+ echo "make application"
+ $MAKE -f Makefile DEVICE=$DEVICE
+ if [ $? -ne 0 ]; then
+   echo " "
+   read -p "press key to close window..."
+   echo on
+   exit
+ fi
+ echo "done with application"
+ echo " "
+ 
+ # upload using SWIM debug interface
+ $SWIM_LOADER -c $SWIM_TOOL -w $TARGET -p $SWIM_DEVICE
+ 
+ echo " "
+ read -p "press key to close window..."
+ echo " "
+ 
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_clean.bat ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_clean.bat
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_clean.bat	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_clean.bat	2017-11-19 09:02:17.000000000 +0100
***************
*** 0 ****
--- 1,18 ----
+ REM just for output
+ echo off
+ cls
+ 
+ REM target device (doesn't matter here)
+ set DEVICE=STM8L10x
+ 
+ REM set make tool (if not in PATH, set complete path)
+ set MAKE=mingw32-make
+ 
+ REM set make tool (if not in PATH, set complete path)
+ set MAKE=mingw32-make
+ 
+ REM use makefile to delete sdcc output
+ %MAKE% -f Makefile DEVICE=%DEVICE% clean
+ 
+ echo on
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_compile_run.bat ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_compile_run.bat
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_compile_run.bat	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/SDCC/_WIN_compile_run.bat	2017-11-19 09:02:43.000000000 +0100
***************
*** 0 ****
--- 1,44 ----
+ REM just for output
+ echo off
+ cls
+ 
+ REM target device (doesn't matter here)
+ set DEVICE=STM8L10x
+ 
+ REM set make tool (if not in PATH, set complete path)
+ set MAKE=mingw32-make
+ 
+ REM STM8L10x has no bootloader, see tech note UM0560 and TN0189 on http://www.st.com
+ 
+ REM set SWIM upload tool and device name (stm8flash from https://github.com/vdudouyt/stm8flash)
+ REM set SWIM_LOADER=C:\Programme\stm8flash\stm8flash.exe"
+ REM set SWIM_TOOL=stlink
+ REM set SWIM_DEVICE=stm8l101?3
+ 
+ REM set SWIM upload tool and device name (STVP-STM8 on http://www.st.com)
+ set SWIM_LOADER="C:\Programme\STMicroelectronics\st_toolset\stvp\STVP_CmdLine.exe"
+ set SWIM_DEVICE=STM8L101x3
+ 
+ REM name of target hexfile
+ set TARGET=.\%DEVICE%\%DEVICE%.hex
+ 
+ REM compile and link
+ echo make application
+ %MAKE% -f Makefile DEVICE=%DEVICE%
+ IF ERRORLEVEL 1 GOTO END
+ echo done with application
+ echo.
+ 
+ REM GOTO END
+ 
+ REM upload using SWIM debug interface (stm8flash from https://github.com/vdudouyt/stm8flash)
+ REM %SWIM_LOADER% -c %SWIM_TOOL% -w %TARGET% -p %SWIM_DEVICE%
+ 
+ REM upload using SWIM debug interface (STVP-STM8 on http://www.st.com)
+ %SWIM_LOADER% -BoardName=ST-LINK -Port=USB -ProgMode=SWIM -Device=%DEVICE_STVP% -readData -readOption -no_progData -no_progOption -no_loop -no_log -FileProg=%TARGET%
+ 
+ REM clean up
+ :END
+ PAUSE
+ echo on
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/stm8l10x_conf.h	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,81 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_conf.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ /* #define USE_FULL_ASSERT    1 */
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.c	2017-09-02 15:53:04.000000000 +0200
***************
*** 0 ****
--- 1,337 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.c
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Templates
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ #ifdef _COSMIC_
+ /**
+   * @brief  Dummy interrupt routine
+   * @param  None
+   * @retval None
+ */
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief  TRAP interrupt routine
+   * @param  None
+   * @retval None
+ */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ 
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief  Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief  Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief  Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief  USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief  I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/project.stw ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/project.stw
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/project.stw	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/project.stw	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,12 ----
+ ;	STMicroelectronics Workspace file
+ 
+ [Version]
+ Keyword=ST7Workspace-V0.7
+ 
+ [Project0]
+ Filename=stm8l10x.stp
+ Dependencies=
+ [Options]
+ ActiveProject=stm8l10x
+ ActiveConfig=Debug
+ AddSortedElements=1
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/readme.txt	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,67 ----
+ /** @page project Template project for ST Visual Develop (STVD) toolchain with Cosmic compiler
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2012 STMicroelectronics *******************
+   * @file     Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/readme.txt 
+   * @author   MCD Application Team
+   * @version  V1.2.0
+   * @date     01-June-2012
+   * @brief    This sub-directory contains all the user-modifiable files needed
+   *           to create a new project linked with the STM8L Standard Peripheral 
+   *           Library and working with STVD and Cosmic software toolchain.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Project description
+ 
+   This folder contains a standard STVD template workspace with a project 
+   including all the user-modifiable files that are necessary to create a new project.
+   This project template can be used by mean of minor updates in the library files
+   to run the StdPeriph_Lib examples, or custom user applications. 
+   
+  
+   @par Directories contents
+      
+   -  Project\STM8L10x_StdPeriph_Templates\\STVD\\Cosmic
+      - project.stw              Workspace file
+      - stm8l10x.stp             Project file for STM8L10x devices 
+      - stm8_interrupt_vector.c  Interrupt vectors table
+ 
+ 
+   @par How to use it ?
+ 
+   - Open the STVD workspace
+   - Select your debug instrument: Debug instrument-> Target Settings, select the 
+     target you want to use for debug session (Swim ST-Link..)
+   - Rebuild all files: Build-> Rebuild all. 
+   - Load project image: Debug->Start Debugging
+   - Run program: Debug->Run (Ctrl+F5)
+   
+   @b Tip: If it is your first time using STVD, you have to confirm the default 
+   toolset and path information that will be used when building your application, 
+   to do so:
+     - Select Tools -> Options
+     - In the Options window click on the Toolset tab
+     - Select your toolset from the Toolset list box.
+     If the path is incorrect you can type the correct path in the Root Path 
+     field, or use the browse button to locate it.
+     - In the subpath fields, type the correct subpath if necessary 
+   
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a flash memory density up to 8 Kbytes.  
+  
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8_interrupt_vector.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8_interrupt_vector.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8_interrupt_vector.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8_interrupt_vector.c	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,50 ----
+ /*	BASIC INTERRUPT VECTOR TABLE FOR STM8 devices
+  *	Copyright (c) 2012 STMicroelectronics
+  */
+ 
+ 
+ #include "stm8l10x_it.h"
+ 
+ typedef void @far (*interrupt_handler_t)(void);
+ 
+ struct interrupt_vector {
+ 	uint8_t interrupt_instruction;
+ 	interrupt_handler_t interrupt_handler;
+ };
+ 
+ struct interrupt_vector const _vectab[] = {
+   {0x82, (interrupt_handler_t)_stext},		/* Reset */
+   {0x82, (interrupt_handler_t)TRAP_IRQHandler}, 			  /* TRAP - Software interrupt  [for GP products]*/
+   {0x82, (interrupt_handler_t)NonHandledInterrupt}, 		/* irq0 - Reserved */
+   {0x82, (interrupt_handler_t)FLASH_IRQHandler}, 			  /* irq1 - FLASH interrupt */
+   {0x82, (interrupt_handler_t)NonHandledInterrupt}, 		/* irq2 - Reserved */
+   {0x82, (interrupt_handler_t)NonHandledInterrupt}, 	  /* irq3 - Reserved */
+   {0x82, (interrupt_handler_t)AWU_IRQHandler}, 		    	/* irq4 - Auto Wake Up interrupt */
+   {0x82, (interrupt_handler_t)NonHandledInterrupt},     /* irq5 - Reserved */
+   {0x82, (interrupt_handler_t)EXTIB_IRQHandler},        /* irq6 - External IT PORTB interrupt */
+   {0x82, (interrupt_handler_t)EXTID_IRQHandler}, 			  /* irq7 - External IT PORTD interrupt */
+   {0x82, (interrupt_handler_t)EXTI0_IRQHandler}, 			  /* irq8 - External IT PIN0 interrupt */
+   {0x82, (interrupt_handler_t)EXTI1_IRQHandler}, 			  /* irq9 - External IT PIN1 interrupt */
+   {0x82, (interrupt_handler_t)EXTI2_IRQHandler}, 			  /* irq10 - External IT PIN2 interrupt */
+   {0x82, (interrupt_handler_t)EXTI3_IRQHandler}, 		    /* irq11 - External IT PIN3 interrupt */
+   {0x82, (interrupt_handler_t)EXTI4_IRQHandler},        /* irq12 - External IT PIN4 interrupt */
+   {0x82, (interrupt_handler_t)EXTI5_IRQHandler},        /* irq13 - External IT PIN5 interrupt */
+   {0x82, (interrupt_handler_t)EXTI6_IRQHandler},        /* irq14 - External IT PIN6 interrupt */
+   {0x82, (interrupt_handler_t)EXTI7_IRQHandler},        /* irq15 - External IT PIN7 interrupt */
+   {0x82, (interrupt_handler_t)NonHandledInterrupt},     /* irq16 - Reserved */
+   {0x82, (interrupt_handler_t)NonHandledInterrupt},     /* irq17 - Reserved */
+   {0x82, (interrupt_handler_t)COMP_IRQHandler},         /* irq18 - Comparator interrupt */
+   {0x82, (interrupt_handler_t)TIM2_UPD_OVF_TRG_BRK_IRQHandler},       /* irq19 - Timer2 Update/Overflow/Trigger/Break interrupt */
+   {0x82, (interrupt_handler_t)TIM2_CAP_IRQHandler},     /* irq20 - Timer2 Capture/Compare interrupt */
+   {0x82, (interrupt_handler_t)TIM3_UPD_OVF_TRG_BRK_IRQHandler},       /* irq21 - Timer3 Update/Overflow/Trigger/Break interrupt */
+   {0x82, (interrupt_handler_t)TIM3_CAP_IRQHandler}, 		/* irq22 - Timer3 Capture/Compare interrupt */
+   {0x82, (interrupt_handler_t)NonHandledInterrupt},     /* irq23 - Reserved */
+   {0x82, (interrupt_handler_t)NonHandledInterrupt},     /* irq24 - Reserved */
+   {0x82, (interrupt_handler_t)TIM4_UPD_OVF_IRQHandler}, /* irq25 - Timer4 Update/Overflow interrupt */
+   {0x82, (interrupt_handler_t)SPI_IRQHandler},          /* irq26 - SPI interrupt */
+   {0x82, (interrupt_handler_t)USART_TX_IRQHandler},     /* irq27 - USART TX interrupt */
+   {0x82, (interrupt_handler_t)USART_RX_IRQHandler},     /* irq28 - USART RX interrupt */
+   {0x82, (interrupt_handler_t)I2C_IRQHandler},          /* irq29 - I2C interrupt */
+ };
+ 
+ /******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8l10x.stp ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8l10x.stp
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8l10x.stp	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Cosmic/stm8l10x.stp	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,347 ----
+ ;	STMicroelectronics Project file
+ 
+ [Version]
+ Keyword=ST7Project
+ Number=1.3
+ 
+ [Project]
+ Name=stm8l10x
+ Toolset=STM8 Cosmic
+ 
+ [Config]
+ 0=Config.0
+ 
+ [Config.0]
+ ConfigName=Debug
+ Target=$(ProjectSFile).elf
+ OutputFolder=Debug
+ Debug=$(TargetFName)
+ 
+ [Root]
+ ElemType=Project
+ PathName=stm8l10x
+ Child=Root.STM8L_EVAL
+ Config.0=Root.Config.0
+ 
+ [Root.Config.0]
+ Settings.0.0=Root.Config.0.Settings.0
+ Settings.0.1=Root.Config.0.Settings.1
+ Settings.0.2=Root.Config.0.Settings.2
+ Settings.0.3=Root.Config.0.Settings.3
+ Settings.0.4=Root.Config.0.Settings.4
+ Settings.0.5=Root.Config.0.Settings.5
+ Settings.0.6=Root.Config.0.Settings.6
+ Settings.0.7=Root.Config.0.Settings.7
+ Settings.0.8=Root.Config.0.Settings.8
+ 
+ [Root.Config.0.Settings.0]
+ String.6.0=2012,5,30,10,31,49
+ String.100.0=ST Assembler Linker
+ String.100.1=ST7 Cosmic
+ String.100.2=STM7 Cosmic
+ String.100.3=STM8 Cosmic
+ String.100.4=ST7 Metrowerks V1.1
+ String.100.5=Raisonance
+ String.101.0=STM8 Cosmic
+ String.102.0=C:\Program Files (x86)\COSMIC\CXSTM8_32K
+ String.103.0=
+ String.104.0=Hstm8
+ String.105.0=Lib
+ String.106.0=Debug
+ String.107.0=$(ProjectSFile).elf
+ Int.108=0
+ 
+ [Root.Config.0.Settings.1]
+ String.6.0=2009,3,4,9,37,25
+ String.100.0=$(TargetFName)
+ String.101.0=
+ String.103.0=.\;..\..;..\..\..\..\libraries\stm8l10x_stdperiph_driver\src;..\..\..\..\utilities\stm8l101_eval;..\..\..\..\utilities\stm8l101_eval\common;
+ 
+ [Root.Config.0.Settings.2]
+ String.2.0=
+ String.6.0=2009,6,19,11,53,13
+ String.100.0=STM8L101K3U
+ 
+ [Root.Config.0.Settings.3]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=cxstm8 +mods0 -customDebCompat -customOpt +compact +split -customC-pp -customLst -l -i..\..\ -i..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc -i..\..\..\..\utilities\stm8l101_eval -i..\..\..\..\utilities\stm8l101_eval\common $(ToolsetIncOpts) -cl$(IntermPath) -co$(IntermPath) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2012,5,30,10,30,26
+ 
+ [Root.Config.0.Settings.4]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=castm8 -xx -l $(ToolsetIncOpts) -o$(IntermPath)$(InputName).$(ObjectExt) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.Config.0.Settings.5]
+ String.2.0=Running Pre-Link step
+ String.6.0=2009,3,4,9,37,25
+ String.8.0=
+ 
+ [Root.Config.0.Settings.6]
+ String.2.0=Running Linker
+ String.3.0=clnk $(ToolsetLibOpts) -o $(OutputPath)$(TargetSName).sm8 -fakeInteger -fakeOutFile$(ProjectSFile).elf -fakeRunConv -fakeStartupcrtsi0.sm8 -fakeAutoGen -fakeVectFilestm8_interrupt_vector.c -fakeVectAddr0x8000 -customMapFile -customMapFile-m$(OutputPath)$(TargetSName).map -customMapAddress -customCfgFile$(OutputPath)$(TargetSName).lkf 
+ String.3.1=cvdwarf $(OutputPath)$(TargetSName).sm8
+ String.4.0=$(OutputPath)$(TargetFName)
+ String.5.0=$(OutputPath)$(ProjectSFile).elf $(OutputPath)$(TargetSName).map
+ String.6.0=2012,5,30,10,31,49
+ String.100.0=
+ String.101.0=crtsi.st7
+ String.102.0=+seg .const -b 0x8080 -m 0x1f80 -n .const -it
+ String.102.1=+seg .text -a .const -n .text
+ String.102.2=+seg .bsct -b 0x0 -m 0x100 -n .bsct
+ String.102.3=+seg .ubsct -a .bsct -n .ubsct
+ String.102.4=+seg .bit -a .ubsct -n .bit -id
+ String.102.5=+seg .share -a .bit -n .share -is
+ String.102.6=+seg .data -b 0x100 -m 0x2ff -n .data
+ String.102.7=+seg .bss -a .data -n .bss
+ String.103.0=Code,Constants[0x8080-0x9fff]=.const,.text
+ String.103.1=Zero Page[0x0-0xff]=.bsct,.ubsct,.bit,.share
+ String.103.2=Ram[0x100-0x3fe]=.data,.bss
+ String.104.0=0x5ff
+ String.105.0=libis0.sm8;libm0.sm8
+ Int.0=0
+ Int.1=0
+ 
+ [Root.Config.0.Settings.7]
+ String.2.0=Running Post-Build step
+ String.3.0=chex -o $(OutputPath)$(TargetSName).s19 $(OutputPath)$(TargetSName).sm8
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.Config.0.Settings.8]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.STM8L_EVAL]
+ ElemType=Folder
+ PathName=STM8L_EVAL
+ Child=Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\common\stm8l_eval_lcd.c
+ Next=Root.Source Files
+ Config.0=Root.STM8L_EVAL.Config.0
+ 
+ [Root.STM8L_EVAL.Config.0]
+ Settings.0.0=Root.STM8L_EVAL.Config.0.Settings.0
+ Settings.0.1=Root.STM8L_EVAL.Config.0.Settings.1
+ Settings.0.2=Root.STM8L_EVAL.Config.0.Settings.2
+ Settings.0.3=Root.STM8L_EVAL.Config.0.Settings.3
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.0]
+ String.6.0=2012,5,30,10,6,59
+ String.8.0=Debug
+ Int.0=0
+ Int.1=0
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.1]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=cxstm8 +mods0 -customDebCompat -customOpt +compact +split -customC-pp -customLst -l -i..\..\ -i..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc -i..\..\..\..\utilities\stm8l101_eval -i..\..\..\..\utilities\stm8l101_eval\common $(ToolsetIncOpts) -cl$(IntermPath) -co$(IntermPath) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2012,5,30,10,30,26
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.2]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=castm8 -xx -l $(ToolsetIncOpts) -o$(IntermPath)$(InputName).$(ObjectExt) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.3]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.3.0=
+ String.4.0=
+ String.5.0=
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\common\stm8l_eval_lcd.c]
+ ElemType=File
+ PathName=..\..\..\..\utilities\stm8l101_eval\common\stm8l_eval_lcd.c
+ Next=Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\stm8l101_eval.c
+ 
+ [Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\stm8l101_eval.c]
+ ElemType=File
+ PathName=..\..\..\..\utilities\stm8l101_eval\stm8l101_eval.c
+ 
+ [Root.Source Files]
+ ElemType=Folder
+ PathName=Source Files
+ Child=Root.Source Files...\..\main.c
+ Next=Root.StdPeriph_Driver
+ Config.0=Root.Source Files.Config.0
+ 
+ [Root.Source Files.Config.0]
+ Settings.0.0=Root.Source Files.Config.0.Settings.0
+ Settings.0.1=Root.Source Files.Config.0.Settings.1
+ Settings.0.2=Root.Source Files.Config.0.Settings.2
+ Settings.0.3=Root.Source Files.Config.0.Settings.3
+ 
+ [Root.Source Files.Config.0.Settings.0]
+ String.6.0=2009,3,4,9,37,25
+ String.8.0=Debug
+ Int.0=0
+ Int.1=0
+ 
+ [Root.Source Files.Config.0.Settings.1]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=cxstm8 +mods0 -customDebCompat -customOpt +compact +split -customC-pp -customLst -l -i..\..\ -i..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc -i..\..\..\..\utilities\stm8l101_eval -i..\..\..\..\utilities\stm8l101_eval\common $(ToolsetIncOpts) -cl$(IntermPath) -co$(IntermPath) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2012,5,30,10,30,26
+ 
+ [Root.Source Files.Config.0.Settings.2]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=castm8 -xx -l $(ToolsetIncOpts) -o$(IntermPath)$(InputName).$(ObjectExt) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.Source Files.Config.0.Settings.3]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.3.0=
+ String.4.0=
+ String.5.0=
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.Source Files...\..\main.c]
+ ElemType=File
+ PathName=..\..\main.c
+ Next=Root.Source Files...\..\stm8l10x_it.c
+ 
+ [Root.Source Files...\..\stm8l10x_it.c]
+ ElemType=File
+ PathName=..\..\stm8l10x_it.c
+ Next=Root.Source Files.stm8_interrupt_vector.c
+ 
+ [Root.Source Files.stm8_interrupt_vector.c]
+ ElemType=File
+ PathName=stm8_interrupt_vector.c
+ 
+ [Root.StdPeriph_Driver]
+ ElemType=Folder
+ PathName=StdPeriph_Driver
+ Child=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_awu.c
+ Config.0=Root.StdPeriph_Driver.Config.0
+ 
+ [Root.StdPeriph_Driver.Config.0]
+ Settings.0.0=Root.StdPeriph_Driver.Config.0.Settings.0
+ Settings.0.1=Root.StdPeriph_Driver.Config.0.Settings.1
+ Settings.0.2=Root.StdPeriph_Driver.Config.0.Settings.2
+ Settings.0.3=Root.StdPeriph_Driver.Config.0.Settings.3
+ 
+ [Root.StdPeriph_Driver.Config.0.Settings.0]
+ String.6.0=2009,4,7,18,23,6
+ String.8.0=Debug
+ Int.0=0
+ Int.1=0
+ 
+ [Root.StdPeriph_Driver.Config.0.Settings.1]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=cxstm8 +mods0 -customDebCompat -customOpt +compact +split -customC-pp -customLst -l -i..\..\ -i..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc -i..\..\..\..\utilities\stm8l101_eval -i..\..\..\..\utilities\stm8l101_eval\common $(ToolsetIncOpts) -cl$(IntermPath) -co$(IntermPath) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2012,5,30,10,30,26
+ 
+ [Root.StdPeriph_Driver.Config.0.Settings.2]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=castm8 -xx -l $(ToolsetIncOpts) -o$(IntermPath)$(InputName).$(ObjectExt) $(InputFile)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).ls
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.StdPeriph_Driver.Config.0.Settings.3]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.3.0=
+ String.4.0=
+ String.5.0=
+ String.6.0=2009,3,4,9,37,25
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_awu.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_awu.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_beep.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_beep.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_beep.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_clk.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_clk.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_clk.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_comp.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_comp.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_comp.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_exti.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_exti.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_exti.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_flash.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_flash.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_flash.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_gpio.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_gpio.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_gpio.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_i2c.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_i2c.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_i2c.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_irtim.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_irtim.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_irtim.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_itc.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_itc.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_itc.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_iwdg.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_iwdg.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_iwdg.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_rst.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_rst.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_rst.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_spi.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_spi.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_spi.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim2.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim2.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim2.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim3.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim3.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim3.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim4.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim4.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim4.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_usart.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_usart.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_usart.c
+ Next=Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_wfe.c
+ 
+ [Root.StdPeriph_Driver...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_wfe.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_wfe.c
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/project.stw ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/project.stw
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/project.stw	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/project.stw	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,12 ----
+ ;	STMicroelectronics Workspace file
+ 
+ [Version]
+ Keyword=ST7Workspace-V0.7
+ 
+ [Project0]
+ Filename=stm8l10x.stp
+ Dependencies=
+ [Options]
+ ActiveProject=stm8l10x
+ ActiveConfig=Debug
+ AddSortedElements=0
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/readme.txt ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/readme.txt
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/readme.txt	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/readme.txt	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,66 ----
+ /** @page project_r Template project for ST Visual Develop (STVD) toolchain with Raisonance compiler
+ 
+   @verbatim
+   ******************** (C)COPYRIGHT 2012 STMicroelectronics *******************
+   * @file     Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/readme.txt 
+   * @author   MCD Application Team
+   * @version  V1.2.0
+   * @date     01-June-2012
+   * @brief    This sub-directory contains all the user-modifiable files needed
+   *           to create a new project linked with the STM8L Standard Peripheral 
+   *           Library and working with STVD and Raisonance software toolchain.
+   ******************************************************************************
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   @endverbatim
+   
+   @par Project description
+  
+   This folder contains a standard STVD template workspace with a project 
+   including all the user-modifiable files that are necessary to create a new project.
+   This project template can be used by mean of minor updates in the library files
+   to run the StdPeriph_Lib examples, or custom user applications.   
+ 
+   
+   @par Directories contents
+ 
+   -  Project\STM8L10x_StdPeriph_Templates\\STVD\\Raisonnance
+      - project.stw              Workspace file
+      - stm8l10x.stp             Project file for STM8L10x devices.
+ 
+ 
+   @par How to use it ?
+ 
+   - Open the STVD workspace
+   - Select your debug instrument: Debug instrument -> Target Settings, select the 
+     target you want to use for debug session (Swim ST-Link or Swim Rlink)
+   - Rebuild all files: Build -> Rebuild all. 
+   - Load project image: Debug ->Start Debugging
+   - Run program: Debug ->Run (Ctrl+F5)
+   
+   @b Tip: If it is your first time using STVD, you have to confirm the default 
+   toolset and path information that will be used when building your application, 
+   to do so:
+     - Select Tools-> Options
+     - In the Options window click on the Toolset tab
+     - Select your toolset from the Toolset list box.
+     If the path is incorrect you can type the correct path in the Root Path 
+     field, or use the browse button to locate it.
+     - In the subpath fields, type the correct subpath if necessary 
+ 
+ @note
+  - STM8L10x devices are STM8L microcontrollers with a flash memory density up to 8 Kbytes.  
+  
+  * <h3><center>&copy; COPYRIGHT STMicroelectronics</center></h3>
+  */
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/stm8l10x.stp ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/stm8l10x.stp
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/stm8l10x.stp	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_Templates/STVD/Raisonance/stm8l10x.stp	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,330 ----
+ ;	STMicroelectronics Project file
+ 
+ [Version]
+ Keyword=ST7Project
+ Number=1.3
+ 
+ [Project]
+ Name=stm8l10x
+ Toolset=Raisonance
+ 
+ [Config]
+ 0=Config.0
+ 
+ [Config.0]
+ ConfigName=Debug
+ Target=$(ProjectSFile).elf
+ OutputFolder=Debug
+ Debug=$(TargetFName)
+ 
+ [Root]
+ ElemType=Project
+ PathName=stm8l10x
+ Child=Root.STM8L_EVAL
+ Config.0=Root.Config.0
+ 
+ [Root.Config.0]
+ Settings.0.0=Root.Config.0.Settings.0
+ Settings.0.1=Root.Config.0.Settings.1
+ Settings.0.2=Root.Config.0.Settings.2
+ Settings.0.3=Root.Config.0.Settings.3
+ Settings.0.4=Root.Config.0.Settings.4
+ Settings.0.5=Root.Config.0.Settings.5
+ Settings.0.6=Root.Config.0.Settings.6
+ Settings.0.7=Root.Config.0.Settings.7
+ Settings.0.8=Root.Config.0.Settings.8
+ 
+ [Root.Config.0.Settings.0]
+ String.6.0=2009,2,26,18,9,34
+ String.100.0=ST Assembler Linker
+ String.100.1=ST7 Cosmic
+ String.100.2=STM8 Cosmic
+ String.100.3=ST7 Metrowerks V1.1
+ String.100.4=Raisonance
+ String.101.0=Raisonance
+ String.102.0=C:\Raisonance\Ride
+ String.103.0=bin
+ String.104.0=INC\STM8;INC\ST7;INC
+ String.105.0=LIB\ST7
+ String.106.0=Debug
+ String.107.0=$(ProjectSFile).elf
+ Int.108=0
+ 
+ [Root.Config.0.Settings.1]
+ String.6.0=2009,2,26,18,1,19
+ String.100.0=$(TargetFName)
+ String.101.0=
+ String.102.0=
+ String.103.0=.\;..\..;..\..\..\..\stm8l10x_stdperiph_lib\libraries\stm8l10x_stdperiph_driver\src;..\..\..\..\libraries\stm8l10x_stdperiph_driver\src;..\..\..\..\utilities\stm8l101_eval;..\..\..\..\utilities\stm8l101_eval\common;
+ 
+ [Root.Config.0.Settings.2]
+ String.2.0=
+ String.6.0=2009,6,19,11,54,6
+ String.100.0=STM8L101K3U
+ 
+ [Root.Config.0.Settings.3]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=rcstm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) WRV(0) STM8(SMALL) DEBUG DGC(page0) AUTO -customSizeOpt -CustomOptimOT(7,SIZE) NOPR -customC INITSTATICVAR LAOB PIN(..\..\) PIN(..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc) PIN(..\..\..\..\utilities\stm8l101_eval) PIN(..\..\..\..\utilities\stm8l101_eval\common)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2012,5,30,9,43,15
+ 
+ [Root.Config.0.Settings.4]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=mastm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) QUIET DEBUG NOPR ERRORPRINT -customUserMODESTM8
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2009,4,5,12,9,37
+ 
+ [Root.Config.0.Settings.5]
+ String.2.0=Running Pre-Link step
+ String.6.0=2009,2,26,18,1,19
+ String.8.0=
+ 
+ [Root.Config.0.Settings.6]
+ String.2.0=Running Linker
+ String.3.0=rlstm8 -P $(ObjectFiles) TO($(OutputPath)$(TargetSName).aof) $(ToolsetLibOpts) -CustomOutFile[$(ProjectSFile).elf] DEBUGLINES DEBUGPUBLICS DEBUGSYMBOLS -CustomRunHexConv -customMapFile -customMapFilePR($(OutputPath)$(TargetSName).map) IXREF -customUserrmun -customUserSCINAME(STM8) 
+ String.3.1=omf2elf $(OutputPath)$(TargetSName).aof
+ String.4.0=$(OutputPath)$(TargetFName)
+ String.5.0=$(OutputPath)$(ProjectSFile).elf $(OutputPath)$(TargetSName).map
+ String.6.0=2011,11,30,17,10,24
+ String.100.0= DATASTART(0x0) RAMSIZE(0x600) CODESTART(0x8000) CODESIZE(0x2000) STACKTOP(0x600) STACKSIZE(0x201)
+ String.101.0=
+ String.102.0=
+ Int.0=0
+ Int.1=0
+ 
+ [Root.Config.0.Settings.7]
+ String.2.0=Running Post-Build step
+ String.3.0=omf2hex $(OutputPath)$(TargetSName).aof HEX
+ String.6.0=2011,11,30,17,10,24
+ 
+ [Root.Config.0.Settings.8]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.6.0=2009,2,26,18,1,19
+ 
+ [Root.STM8L_EVAL]
+ ElemType=Folder
+ PathName=STM8L_EVAL
+ Child=Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\common\stm8l_eval_lcd.c
+ Next=Root.StdPeriph_Lib
+ Config.0=Root.STM8L_EVAL.Config.0
+ 
+ [Root.STM8L_EVAL.Config.0]
+ Settings.0.0=Root.STM8L_EVAL.Config.0.Settings.0
+ Settings.0.1=Root.STM8L_EVAL.Config.0.Settings.1
+ Settings.0.2=Root.STM8L_EVAL.Config.0.Settings.2
+ Settings.0.3=Root.STM8L_EVAL.Config.0.Settings.3
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.0]
+ String.6.0=2011,11,30,17,8,53
+ String.8.0=Debug
+ Int.0=0
+ Int.1=0
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.1]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=rcstm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) WRV(0) STM8(SMALL) DEBUG DGC(page0) AUTO -customSizeOpt -CustomOptimOT(7,SIZE) NOPR -customC INITSTATICVAR LAOB PIN(..\..\) PIN(..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc) PIN(..\..\..\..\utilities\stm8l101_eval) PIN(..\..\..\..\utilities\stm8l101_eval\common)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2012,5,30,9,43,15
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.2]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=mastm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) QUIET DEBUG NOPR ERRORPRINT -customUserMODESTM8
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2009,4,5,12,9,37
+ 
+ [Root.STM8L_EVAL.Config.0.Settings.3]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.3.0=
+ String.4.0=
+ String.5.0=
+ String.6.0=2009,2,26,18,1,19
+ 
+ [Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\common\stm8l_eval_lcd.c]
+ ElemType=File
+ PathName=..\..\..\..\utilities\stm8l101_eval\common\stm8l_eval_lcd.c
+ Next=Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\stm8l101_eval.c
+ 
+ [Root.STM8L_EVAL...\..\..\..\utilities\stm8l101_eval\stm8l101_eval.c]
+ ElemType=File
+ PathName=..\..\..\..\utilities\stm8l101_eval\stm8l101_eval.c
+ 
+ [Root.StdPeriph_Lib]
+ ElemType=Folder
+ PathName=StdPeriph_Lib
+ Child=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_wfe.c
+ Next=Root.User
+ Config.0=Root.StdPeriph_Lib.Config.0
+ 
+ [Root.StdPeriph_Lib.Config.0]
+ Settings.0.0=Root.StdPeriph_Lib.Config.0.Settings.0
+ Settings.0.1=Root.StdPeriph_Lib.Config.0.Settings.1
+ Settings.0.2=Root.StdPeriph_Lib.Config.0.Settings.2
+ Settings.0.3=Root.StdPeriph_Lib.Config.0.Settings.3
+ 
+ [Root.StdPeriph_Lib.Config.0.Settings.0]
+ String.6.0=2009,4,5,11,11,8
+ String.8.0=Debug
+ Int.0=0
+ Int.1=0
+ 
+ [Root.StdPeriph_Lib.Config.0.Settings.1]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=rcstm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) WRV(0) STM8(SMALL) DEBUG DGC(page0) AUTO -customSizeOpt -CustomOptimOT(7,SIZE) NOPR -customC INITSTATICVAR LAOB PIN(..\..\) PIN(..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc) PIN(..\..\..\..\utilities\stm8l101_eval) PIN(..\..\..\..\utilities\stm8l101_eval\common)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2012,5,30,9,43,15
+ 
+ [Root.StdPeriph_Lib.Config.0.Settings.2]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=mastm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) QUIET DEBUG NOPR ERRORPRINT -customUserMODESTM8
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2009,4,5,12,9,37
+ 
+ [Root.StdPeriph_Lib.Config.0.Settings.3]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.3.0=
+ String.4.0=
+ String.5.0=
+ String.6.0=2009,2,26,18,1,19
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_wfe.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_wfe.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_usart.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_usart.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_usart.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim4.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim4.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim4.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim3.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim3.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim3.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim2.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim2.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_tim2.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_spi.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_spi.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_spi.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_rst.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_rst.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_rst.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_iwdg.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_iwdg.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_iwdg.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_itc.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_itc.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_itc.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_irtim.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_irtim.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_irtim.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_i2c.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_i2c.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_i2c.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_gpio.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_gpio.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_gpio.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_flash.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_flash.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_flash.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_exti.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_exti.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_exti.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_comp.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_comp.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_comp.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_clk.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_clk.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_clk.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_beep.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_beep.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_beep.c
+ Next=Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_awu.c
+ 
+ [Root.StdPeriph_Lib...\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_awu.c]
+ ElemType=File
+ PathName=..\..\..\..\libraries\stm8l10x_stdperiph_driver\src\stm8l10x_awu.c
+ 
+ [Root.User]
+ ElemType=Folder
+ PathName=User
+ Child=Root.User...\..\main.c
+ Config.0=Root.User.Config.0
+ 
+ [Root.User.Config.0]
+ Settings.0.0=Root.User.Config.0.Settings.0
+ Settings.0.1=Root.User.Config.0.Settings.1
+ Settings.0.2=Root.User.Config.0.Settings.2
+ Settings.0.3=Root.User.Config.0.Settings.3
+ 
+ [Root.User.Config.0.Settings.0]
+ String.6.0=2011,11,30,17,9,38
+ String.8.0=Debug
+ Int.0=0
+ Int.1=0
+ 
+ [Root.User.Config.0.Settings.1]
+ String.2.0=Compiling $(InputFile)...
+ String.3.0=rcstm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) WRV(0) STM8(SMALL) DEBUG DGC(page0) AUTO -customSizeOpt -CustomOptimOT(7,SIZE) NOPR -customC INITSTATICVAR LAOB PIN(..\..\) PIN(..\..\..\..\libraries\stm8l10x_stdperiph_driver\inc) PIN(..\..\..\..\utilities\stm8l101_eval) PIN(..\..\..\..\utilities\stm8l101_eval\common)
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2012,5,30,9,43,15
+ 
+ [Root.User.Config.0.Settings.2]
+ String.2.0=Assembling $(InputFile)...
+ String.3.0=mastm8 $(InputFile) OBJECT($(IntermPath)$(InputName).$(ObjectExt)) $(ToolsetIncOpts) QUIET DEBUG NOPR ERRORPRINT -customUserMODESTM8
+ String.4.0=$(IntermPath)$(InputName).$(ObjectExt)
+ String.5.0=$(IntermPath)$(InputName).lst
+ String.6.0=2009,4,5,12,9,37
+ 
+ [Root.User.Config.0.Settings.3]
+ String.2.0=Performing Custom Build on $(InputFile)
+ String.3.0=
+ String.4.0=
+ String.5.0=
+ String.6.0=2009,2,26,18,1,19
+ 
+ [Root.User...\..\main.c]
+ ElemType=File
+ PathName=..\..\main.c
+ Next=Root.User...\..\stm8l10x_it.c
+ 
+ [Root.User...\..\stm8l10x_it.c]
+ ElemType=File
+ PathName=..\..\stm8l10x_it.c
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/main.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/main.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/main.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/main.c	2018-04-05 05:29:01.000000000 +0200
***************
*** 0 ****
--- 1,118 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/main.c
+   * @author   MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief    This file contains the firmware main function.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ #include "stm8l10x_it.h"    /* SDCC patch: required by SDCC for interrupts */
+ #include "stm8l10x_tim4.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Templates
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /* Public variables ---------------------------------------------------------*/
+ uint8_t     g_flag1ms=0;    // flag for 1ms interrupt (for TIM4 ISR)
+ uint32_t    g_count1ms=0;   // 1ms counter (for TIM4 ISR)
+ 
+ 
+ void main(void)
+ {
+   /* init High speed internal clock prescaler: 1 */
+   CLK_MasterPrescalerConfig(CLK_MasterPrescaler_HSIDiv1);
+ 
+   /* Enable TIM4 CLK */
+   CLK_PeripheralClockConfig(CLK_Peripheral_TIM4, ENABLE);
+ 
+   /* Initialize LED pins in Output Mode */
+   GPIO_Init(GPIOA, (GPIO_Pin_TypeDef) GPIO_Pin_7, GPIO_Mode_Out_PP_Low_Fast);
+   GPIO_SetBits(GPIOA, (GPIO_Pin_TypeDef) GPIO_Pin_7);
+ 
+   // config 1ms clock
+   TIM4_DeInit();
+   TIM4_TimeBaseInit(TIM4_Prescaler_128, 124);
+   TIM4_ClearFlag(TIM4_FLAG_Update);
+   TIM4_ITConfig(TIM4_IT_Update, ENABLE);
+   TIM4_Cmd(ENABLE);
+ 
+   // enable interrupts
+   enableInterrupts();
+ 
+   // main loop
+   while (1)
+   {
+     // every 1ms
+     if (g_flag1ms)
+     { 
+       g_flag1ms=0;
+     
+       if ((g_count1ms % 500) == 0)
+       {
+         // toogle LED
+         GPIO_ToggleBits(GPIOA, (GPIO_Pin_TypeDef) GPIO_Pin_7);
+ 
+       } // every 500ms
+     
+     } // every 1ms
+     
+   } // main loop
+ 
+ } // main()
+ 
+ 
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  Reports the name of the source file and the source line number
+   *   where the assert_param error has occurred.
+   * @param file: pointer to the source file name
+   * @param line: assert_param error line source number
+   * @retval : None
+   */
+ void assert_failed(uint8_t* file, uint32_t line)
+ {
+     /* User can add his own implementation to report the file name and line number,
+        ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
+ 
+     /* Infinite loop */
+     while (1)
+     {
+     }
+ }
+ #endif
+ 
+ /**
+   * @}
+   */
+   
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/Makefile ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/Makefile
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/Makefile	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/Makefile	2017-11-19 09:03:18.000000000 +0100
***************
*** 0 ****
--- 1,77 ----
+ #######
+ # makefile for STM8*_StdPeriph_Lib and SDCC compiler
+ #
+ # note: paths in this Makefile assume unmodified SPL folder structure
+ #
+ # usage:
+ #   1. if SDCC not in PATH set path -> CC_ROOT
+ #   2. set correct STM8 device -> DEVICE
+ #   3. set project paths -> PRJ_ROOT, PRJ_SRC_DIR, PRJ_INC_DIR
+ #   4. set SPL paths -> SPL_ROOT
+ #   5. add required SPL modules -> SPL_SOURCE
+ #   6. add required STM8L101_EVAL modules -> EVAL_SOURCE, EVAL_COMM_SOURCE
+ #
+ #######
+ 
+ # STM8 device (doesn't matter here, just for Makefile)
+ DEVICE=STM8L10x
+ 
+ # set compiler path & parameters 
+ CC_ROOT =
+ CC      = sdcc
+ CFLAGS  = -mstm8 -lstm8 --opt-code-size
+ 
+ # set output folder and target name
+ OUTPUT_DIR = ./$(DEVICE)
+ TARGET     = $(OUTPUT_DIR)/$(DEVICE).hex
+ 
+ # set project folder and files (all *.c)
+ PRJ_ROOT    = ..
+ PRJ_SRC_DIR = $(PRJ_ROOT)
+ PRJ_INC_DIR = $(PRJ_ROOT)
+ PRJ_SOURCE  = $(notdir $(wildcard $(PRJ_SRC_DIR)/*.c))
+ PRJ_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(PRJ_SOURCE:.c=.rel))
+ 
+ # set SPL paths
+ SPL_ROOT    = ../../..
+ SPL_SRC_DIR = $(SPL_ROOT)/Libraries/STM8L10x_StdPeriph_Driver/src
+ SPL_INC_DIR = $(SPL_ROOT)/Libraries/STM8L10x_StdPeriph_Driver/inc
+ SPL_SOURCE  = stm8l10x_gpio.c stm8l10x_clk.c stm8l10x_tim4.c
+ SPL_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(SPL_SOURCE:.c=.rel))
+ 
+ # set path to STM8L101_EVAL board routines
+ EVAL_DIR     = $(SPL_ROOT)/Utilities/STM8L101_EVAL
+ EVAL_SOURCE  = 
+ EVAL_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(EVAL_SOURCE:.c=.rel))
+ 
+ # set path to STM8L101_EVAL common routines
+ EVAL_COMM_DIR    = $(EVAL_DIR)/Common
+ EVAL_COMM_SOURCE  = 
+ EVAL_COMM_OBJECTS := $(addprefix $(OUTPUT_DIR)/, $(EVAL_COMM_SOURCE:.c=.rel))
+ 
+ 
+ # collect all include folders
+ INCLUDE = -I$(PRJ_SRC_DIR) -I$(SPL_INC_DIR) -I$(EVAL_DIR) -I$(EVAL_COMM_DIR)
+ 
+ # collect all source directories
+ VPATH=$(PRJ_SRC_DIR):$(SPL_SRC_DIR):$(EVAL_DIR):$(EVAL_COMM_DIR)
+ 
+ .PHONY: clean
+ 
+ all: $(OUTPUT_DIR) $(TARGET)
+ 
+ $(OUTPUT_DIR):
+ 	mkdir -p $(OUTPUT_DIR)
+ 
+ $(OUTPUT_DIR)/%.rel: %.c
+ 	$(CC) $(CFLAGS) $(INCLUDE) -D$(DEVICE) -c $?
+ 
+ $(OUTPUT_DIR)/%.rel: %.c
+ 	$(CC) $(CFLAGS) $(INCLUDE) -D$(DEVICE) -c $? -o $@
+ 
+ $(TARGET): $(PRJ_OBJECTS) $(SPL_OBJECTS) $(EVAL_OBJECTS) $(EVAL_COMM_OBJECTS)
+ 	$(CC) $(CFLAGS) -o $(TARGET) $^
+ 
+ clean: 
+ 	rm -fr $(OUTPUT_DIR)
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_UX_clean.sh ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_UX_clean.sh
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_UX_clean.sh	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_UX_clean.sh	2017-11-19 09:03:29.000000000 +0100
***************
*** 0 ****
--- 1,20 ----
+ #!/bin/bash 
+ 
+ # change to current working directory
+ cd `dirname $0`
+ 
+ # just for output
+ echo off
+ clear
+ 
+ # target device (doesn't matter here)
+ DEVICE=STM8L10x
+ 
+ # set make tool (if not in PATH, set complete path)
+ MAKE=make
+ 
+ # use Makefiles to delete outputs
+ $MAKE -f Makefile DEVICE=$DEVICE clean 
+ 
+ echo on
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_UX_compile_run.sh ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_UX_compile_run.sh
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_UX_compile_run.sh	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_UX_compile_run.sh	2017-11-19 09:03:40.000000000 +0100
***************
*** 0 ****
--- 1,44 ----
+ #!/bin/bash 
+ 
+ # change to current working directory
+ cd `dirname $0`
+ 
+ # just for output
+ clear
+ 
+ # target device (doesn't matter here)
+ DEVICE=STM8L10x
+ 
+ # set make tool (if not in PATH, set complete path)
+ MAKE=make
+ 
+ # STM8L10x has no bootloader, see tech note UM0560 and TN0189 on http://www.st.com
+ 
+ # set SWIM upload tool and device name (stm8flash from https://github.com/vdudouyt/stm8flash)
+ SWIM_LOADER=~/ffentlich/GitHub/stm8flash/stm8flash
+ SWIM_TOOL=stlink
+ SWIM_DEVICE=stm8l101?3
+ 
+ # target hexfile
+ TARGET=./$DEVICE/$DEVICE.hex
+ 
+ # make project
+ echo "make application"
+ $MAKE -f Makefile DEVICE=$DEVICE
+ if [ $? -ne 0 ]; then
+   echo " "
+   read -p "press key to close window..."
+   echo on
+   exit
+ fi
+ echo "done with application"
+ echo " "
+ 
+ # upload using SWIM debug interface
+ $SWIM_LOADER -c $SWIM_TOOL -w $TARGET -p $SWIM_DEVICE
+ 
+ echo " "
+ read -p "press key to close window..."
+ echo " "
+ 
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_clean.bat ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_clean.bat
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_clean.bat	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_clean.bat	2017-11-19 09:03:50.000000000 +0100
***************
*** 0 ****
--- 1,15 ----
+ REM just for output
+ echo off
+ cls
+ 
+ REM target device (doesn't matter here)
+ set DEVICE=STM8L10x
+ 
+ REM set make tool (if not in PATH, set complete path)
+ set MAKE=mingw32-make
+ 
+ REM use makefile to delete sdcc output
+ %MAKE% -f Makefile DEVICE=%DEVICE% clean
+ 
+ echo on
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_compile_run.bat ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_compile_run.bat
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_compile_run.bat	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/SDCC/_WIN_compile_run.bat	2017-11-19 09:03:59.000000000 +0100
***************
*** 0 ****
--- 1,44 ----
+ REM just for output
+ echo off
+ cls
+ 
+ REM target device (doesn't matter here)
+ set DEVICE=STM8L10x
+ 
+ REM set make tool (if not in PATH, set complete path)
+ set MAKE=mingw32-make
+ 
+ REM STM8L10x has no bootloader, see tech note UM0560 and TN0189 on http://www.st.com
+ 
+ REM set SWIM upload tool and device name (stm8flash from https://github.com/vdudouyt/stm8flash)
+ REM set SWIM_LOADER=C:\Programme\stm8flash\stm8flash.exe"
+ REM set SWIM_TOOL=stlink
+ REM set SWIM_DEVICE=stm8l101?3
+ 
+ REM set SWIM upload tool and device name (STVP-STM8 on http://www.st.com)
+ set SWIM_LOADER="C:\Programme\STMicroelectronics\st_toolset\stvp\STVP_CmdLine.exe"
+ set SWIM_DEVICE=STM8L101x3
+ 
+ REM name of target hexfile
+ set TARGET=.\%DEVICE%\%DEVICE%.hex
+ 
+ REM compile and link
+ echo make application
+ %MAKE% -f Makefile DEVICE=%DEVICE%
+ IF ERRORLEVEL 1 GOTO END
+ echo done with application
+ echo.
+ 
+ REM GOTO END
+ 
+ REM upload using SWIM debug interface (stm8flash from https://github.com/vdudouyt/stm8flash)
+ REM %SWIM_LOADER% -c %SWIM_TOOL% -w %TARGET% -p %SWIM_DEVICE%
+ 
+ REM upload using SWIM debug interface (STVP-STM8 on http://www.st.com)
+ %SWIM_LOADER% -BoardName=ST-LINK -Port=USB -ProgMode=SWIM -Device=%DEVICE_STVP% -readData -readOption -no_progData -no_progOption -no_loop -no_log -FileProg=%TARGET%
+ 
+ REM clean up
+ :END
+ PAUSE
+ echo on
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/stm8l10x_conf.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/stm8l10x_conf.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/stm8l10x_conf.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/stm8l10x_conf.h	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,81 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_conf.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file is used to configure the Library.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_CONF_H
+ #define __STM8L10x_CONF_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */
+ #include "stm8l10x_awu.h"
+ #include "stm8l10x_beep.h"
+ #include "stm8l10x_clk.h"
+ #include "stm8l10x_comp.h"
+ #include "stm8l10x_exti.h"
+ #include "stm8l10x_flash.h"
+ #include "stm8l10x_gpio.h"
+ #include "stm8l10x_i2c.h"
+ #include "stm8l10x_irtim.h"
+ #include "stm8l10x_itc.h"
+ #include "stm8l10x_iwdg.h"
+ #include "stm8l10x_rst.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_tim2.h"
+ #include "stm8l10x_tim3.h"
+ #include "stm8l10x_tim4.h"
+ #include "stm8l10x_usart.h"
+ #include "stm8l10x_wfe.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Uncomment the line below to expanse the "assert_param" macro in the 
+    Standard Peripheral Library drivers code */
+ /* #define USE_FULL_ASSERT    1 */
+ 
+ /* Exported macro ------------------------------------------------------------*/
+ #ifdef  USE_FULL_ASSERT
+ 
+ /**
+   * @brief  The assert_param macro is used for function's parameters check.
+   * @param expr: If expr is false, it calls assert_failed function
+   *   which reports the name of the source file and the source
+   *   line number of the call that failed. 
+   *   If expr is true, it returns no value.
+   * @retval : None
+   */
+   #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
+ /* Exported functions ------------------------------------------------------- */
+   void assert_failed(uint8_t* file, uint32_t line);
+ #else
+   #define assert_param(expr) ((void)0)
+ #endif /* USE_FULL_ASSERT */
+ 
+ #endif /* __STM8L10x_CONF_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/stm8l10x_it.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/stm8l10x_it.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/stm8l10x_it.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/stm8l10x_it.c	2017-09-02 19:16:22.000000000 +0200
***************
*** 0 ****
--- 1,346 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.c
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains all the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x_it.h"
+ 
+ /** @addtogroup STM8L10x_StdPeriph_Templates
+   * @{
+   */
+   
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ /* Public variables ----------------------------------------------------------*/
+ 
+ extern uint8_t     g_flag1ms;    // flag for 1ms interrupt (for TIM4 ISR)
+ extern uint32_t    g_count1ms;   // 1ms counter (for TIM4 ISR)
+ 
+ #ifdef _COSMIC_
+ /**
+   * @brief  Dummy interrupt routine
+   * @param  None
+   * @retval None
+ */
+ INTERRUPT_HANDLER(NonHandledInterrupt,0)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ #endif
+ 
+ /**
+   * @brief  TRAP interrupt routine
+   * @param  None
+   * @retval None
+ */
+ INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  FLASH Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(FLASH_IRQHandler,1)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Auto Wake Up Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(AWU_IRQHandler,4)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PORTB Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTIB_IRQHandler, 6)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PORTD Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTID_IRQHandler, 7)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN0 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI0_IRQHandler, 8)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN1 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI1_IRQHandler, 9)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN2 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI2_IRQHandler, 10)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN3 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI3_IRQHandler, 11)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN4 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI4_IRQHandler, 12)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN5 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI5_IRQHandler, 13)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN6 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI6_IRQHandler, 14)
+ 
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  External IT PIN7 Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(EXTI7_IRQHandler, 15)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Comparator Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(COMP_IRQHandler, 18)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Timer2 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_UPD_OVF_TRG_BRK_IRQHandler, 19)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  Timer2 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM2_CAP_IRQHandler, 20)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief  Timer3 Update/Overflow/Trigger/Break Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_UPD_OVF_TRG_BRK_IRQHandler, 21)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief  Timer3 Capture/Compare Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM3_CAP_IRQHandler, 22)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief  Timer4 Update/Overflow Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 25)
+ {
+   
+   // clear timer 4 interrupt flag
+   TIM4_ClearITPendingBit(TIM4_IT_Update);
+ 
+   // increase 1ms SW clock
+   g_flag1ms = 1;
+   g_count1ms++;
+  
+ }
+ 
+ /**
+   * @brief  SPI Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(SPI_IRQHandler, 26)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ /**
+   * @brief  USART TX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_TX_IRQHandler, 27)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @brief  USART RX Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(USART_RX_IRQHandler, 28)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ 
+ /**
+   * @brief  I2C Interrupt routine.
+   * @param  None
+   * @retval None
+   */
+ INTERRUPT_HANDLER(I2C_IRQHandler, 29)
+ {
+     /* In order to detect unexpected events during development,
+        it is recommended to set a breakpoint on the following instruction.
+     */
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/stm8l10x_it.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/stm8l10x_it.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Project/STM8L10x_StdPeriph_test/stm8l10x_it.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Project/STM8L10x_StdPeriph_test/stm8l10x_it.h	2017-08-19 09:11:40.000000000 +0200
***************
*** 0 ****
--- 1,104 ----
+ /**
+   ******************************************************************************
+   * @file     Project/STM8L10x_StdPeriph_Templates/stm8l10x_it.h
+   * @author   MCD Application Team
+   * @version  V1.2.1
+   * @date     30-September-2014
+   * @brief    This file contains the external declarations of the interrupt routines.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L10x_IT_H
+ #define __STM8L10x_IT_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /* Exported types ------------------------------------------------------------*/
+ /* Exported constants --------------------------------------------------------*/
+ /* Exported macro ------------------------------------------------------------*/
+ /* Exported functions ------------------------------------------------------- */
+ #ifdef _COSMIC_
+  void _stext(void); /* RESET startup routine */
+  INTERRUPT void NonHandledInterrupt(void);
+ #endif /* _COSMIC_ */
+ 
+ // SDCC patch: requires separate handling for SDCC (see below)
+ #if !defined(_RAISONANCE_) && !defined(_SDCC_)
+  INTERRUPT void NonHandledInterrupt(void);
+  INTERRUPT void TRAP_IRQHandler(void); /* TRAP */
+  INTERRUPT void FLASH_IRQHandler(void); /* FLASH EOP/PG_DIS */
+  INTERRUPT void AWU_IRQHandler(void); /* AWU */
+  INTERRUPT void EXTIB_IRQHandler(void); /* EXTI PORTB */
+  INTERRUPT void EXTID_IRQHandler(void); /* EXTI PORTD */
+  INTERRUPT void EXTI0_IRQHandler(void); /* EXTI PIN0 */
+  INTERRUPT void EXTI1_IRQHandler(void); /* EXTI PIN1 */
+  INTERRUPT void EXTI2_IRQHandler(void); /* EXTI PIN2 */
+  INTERRUPT void EXTI3_IRQHandler(void); /* EXTI PIN3 */
+  INTERRUPT void EXTI4_IRQHandler(void); /* EXTI PIN4 */
+  INTERRUPT void EXTI5_IRQHandler(void); /* EXTI PIN5 */
+  INTERRUPT void EXTI6_IRQHandler(void); /* EXTI PIN6 */
+  INTERRUPT void EXTI7_IRQHandler(void); /* EXTI PIN7 */
+  INTERRUPT void COMP_IRQHandler(void); /* COMP */
+  INTERRUPT void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM2 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM2_CAP_IRQHandler(void); /* TIM2 CAP*/
+  INTERRUPT void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void); /* TIM3 UPD/OVF/TRG/BRK */
+  INTERRUPT void TIM3_CAP_IRQHandler(void); /* TIM3 CAP*/
+  INTERRUPT void TIM4_UPD_OVF_IRQHandler(void); /* TIM4 UPD/OVF */
+  INTERRUPT void SPI_IRQHandler(void); /* SPI */
+  INTERRUPT void USART_TX_IRQHandler(void); /* USART TX */
+  INTERRUPT void USART_RX_IRQHandler(void); /* USART RX */
+  INTERRUPT void I2C_IRQHandler(void); /* I2C */
+ 
+ 
+ // SDCC patch: __interrupt keyword required after function name --> requires new block
+ #elif defined (_SDCC_)
+ 
+  void TRAP_IRQHandler(void) __trap;               /* TRAP */
+  void FLASH_IRQHandler(void) INTERRUPT(1);        /* FLASH EOP/PG_DIS */
+  void AWU_IRQHandler(void)   INTERRUPT(4);        /* AWU */
+  void EXTIB_IRQHandler(void) INTERRUPT(6);        /* EXTI PORTB */
+  void EXTID_IRQHandler(void) INTERRUPT(7);        /* EXTI PORTD */
+  void EXTI0_IRQHandler(void) INTERRUPT(8);        /* EXTI PIN0 */
+  void EXTI1_IRQHandler(void) INTERRUPT(9);        /* EXTI PIN1 */
+  void EXTI2_IRQHandler(void) INTERRUPT(10);       /* EXTI PIN2 */
+  void EXTI3_IRQHandler(void) INTERRUPT(11);       /* EXTI PIN3 */
+  void EXTI4_IRQHandler(void) INTERRUPT(12);       /* EXTI PIN4 */
+  void EXTI5_IRQHandler(void) INTERRUPT(13);       /* EXTI PIN5 */
+  void EXTI6_IRQHandler(void) INTERRUPT(14);       /* EXTI PIN6 */
+  void EXTI7_IRQHandler(void) INTERRUPT(15);       /* EXTI PIN7 */
+  void COMP_IRQHandler(void)  INTERRUPT(18);       /* COMP */
+  void TIM2_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(19); /* TIM2 UPD/OVF/TRG/BRK */
+  void TIM2_CAP_IRQHandler(void) INTERRUPT(20);    /* TIM2 CAP*/
+  void TIM3_UPD_OVF_TRG_BRK_IRQHandler(void) INTERRUPT(21); /* TIM3 UPD/OVF/TRG/BRK */
+  void TIM3_CAP_IRQHandler(void) INTERRUPT(22);    /* TIM3 CAP*/
+  void TIM4_UPD_OVF_IRQHandler(void) INTERRUPT(25); /* TIM4 UPD/OVF */
+  void SPI_IRQHandler(void)   INTERRUPT(26);       /* SPI */
+  void USART_TX_IRQHandler(void) INTERRUPT(27);    /* USART TX */
+  void USART_RX_IRQHandler(void) INTERRUPT(28);    /* USART RX */
+  void I2C_IRQHandler(void)   INTERRUPT(29);       /* I2C */
+ 
+ #endif /* !(_RAISONANCE_) && !(_SDCC_) */
+ 
+ #endif /* __STM8L10x_IT_H */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Readme.md ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Readme.md
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Readme.md	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Readme.md	2017-09-02 17:38:05.000000000 +0200
***************
*** 0 ****
--- 1,19 ----
+ Toolchain Installation for SDCC
+ =================
+ 
+   - if required, download and install [SDCC](http://sdcc.sourceforge.net/) and Gnu-Make. Add binaries to $(PATH)
+   - for STM8 programming via SWIM debug interface
+     - install libusb-dev (e.g. `sudo apt-get install libusb-1.0-0-dev`)
+     - download and make [stm8flash](https://github.com/vdudouyt/stm8flash) source code
+     - on Linux grant write access to ST-Link debugger by creating a file `/etc/udev/rules.d/99-stlinkv2.rules` with content  
+     `SUBSYSTEM=="usb", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3744", MODE="0666"`  
+     Note: since several versions of ST-Link exist, check the idProduct of your device via command `usb-devices`
+   - for STM8 programming via serial bootloader
+     - STM8L10x has no bootloader, see tech note UM0560 and TN0189 on http://www.st.com
+   - if necessary, set execute permission for build scripts in project folders
+ 
+ ### Notes
+ 
+   - the SPL projects are also compatible with other compilers and IDEs, e.g. [Cosmic](http://www.cosmic-software.com/) and [STVisualDevelop](http://www.st.com). These are not tested or supported by the build scripts, but allow graphical debugging which is not yet supported by SDCC 
+   - on Windows SWIM upload can also be performed via [STVisualProgrammer](http://www.st.com). Please adapt build scripts accordingly
+ 
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Release_Notes.html ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Release_Notes.html
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Release_Notes.html	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Release_Notes.html	2014-10-21 14:13:30.000000000 +0200
***************
*** 0 ****
--- 1,236 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+ <html><head>
+ <style>
+ <!--
+ /* Style Definitions */
+ p.MsoNormal, li.MsoNormal, div.MsoNormal
+ {margin-top:0cm;margin-right:0cm;margin-bottom:8pt;margin-left:0cm;line-height:normal;font-size:10.0pt;font-family:Verdana,sans-serif;}
+ p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
+ {margin-top:0cm;margin-right:0cm;margin-bottom:2pt;margin-left:0cm;line-height:normal;font-size:10.0pt;font-family:Verdana,sans-serif;}
+ -->
+ </style>
+ <title>STM8L10x Standard Peripherals Library Release Notes</title></head>
+ <body lang="EN-US">
+ <p class="MsoNormal" style="text-align: center; line-height: normal;" align="center"><b><span style="font-size: 18pt; color: rgb(51, 102, 255);">
+ Release Notes for
+ </span></b></p>
+ <p class="MsoNormal" style="text-align: center; line-height: normal;" align="center"><b><span style="font-size: 18pt; color: rgb(51, 102, 255);">
+ STM8L10x Standard Peripherals Library
+ </span></b></p>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span></p>
+ <p class="MsoNormal" style="line-height: normal;" align="center"><span style="font-size: 10pt;">
+ Copyright  2014 STMicroelectronics
+ </span></p>
+ <p class="MsoNormal" style="line-height: normal;" align="center"><span style="font-size: 10pt;">
+ Microcontrollers Division - Application Team
+ </span></p>
+ <p class="MsoNormal" align="center"> <img style="border: 0px solid ; width: 171px; height: 126px;" alt="" id="_rnc_img0" src="_htmresc/st_logo.png"> </p>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span></p>
+ <table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; margin-right: 4cm; width: 80%;" border="0" cellpadding="0" cellspacing="0" width="100%">
+ <tbody><tr><td style="padding: 0cm 5.4pt;">
+ <p class="MsoNormal" style="margin-left: 0cm; margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 12pt; color: white;">
+ Overview</span></b></p></td></tr></tbody></table>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;&nbsp;</span></p>
+ 
+ <p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ The <b>STM8L10x-Standard Peripheral Library Package</b> consists of device drivers for all of the standard device peripherals, for the STM8L10x 8-bit Flash microcontrollers. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 12pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol"><span style=""></span><span style="font-size: 10pt;">
+  
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol"><span style=""></span><span style="font-size: 10pt;">It includes a description of the device drivers plus a set of examples for each peripheral. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol"><span style="font-size: 10pt;"> <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span></p>
+ <table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; margin-right: 4cm; width: 966px; height: 22px;" border="0" cellpadding="0" cellspacing="0">
+ <tbody><tr><td style="padding: 0cm 5.4pt;">
+ <p class="MsoNormal" style="margin-left: 0cm; margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 12pt; color: white;">
+ Update History</span></b></p></td></tr></tbody></table>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;&nbsp;</span></p></span></spanstyle></p><p class="MsoListParagraph" style="margin-right: 4cm; text-indent: 10pt; line-height: normal;"><span style="font-size: 10pt;"><table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; width: 634px; height: 20px;" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="padding: 0cm 5.4pt;" align="left"><p class="MsoNormal" style="margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 10pt; color: white;">
+ V1.2.1 - 30-September-2014</span></b></p></td></tr></tbody></table></span></p><p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><b><u><span style="font-size: 10pt;">Main Changes</span></u></b></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol"><span style="font-size: 10pt;">
+ 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span></spanstyle><span style="font-size: 10pt; font-family: Verdana;">Update the IWDG&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">configuration&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">seqeunce</span><span style="font-size: 10pt; font-family: Verdana;"><span class="Apple-converted-space">&nbsp;</span>in the </span><span style="font-size: 10pt; font-family: Verdana;">IWDG_Example.</span></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226; </spanstyle><span style="font-size: 10pt; font-family: Verdana; text-decoration: underline;"></span><span style="font-size: 10pt; font-family: Verdana;"><span style="text-decoration: underline;"></span></span><span style="font-size: 10pt; font-family: Verdana;">Update timeout variable declaration&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">on 16 bit instead of 32 bit<span class="Apple-converted-space">&nbsp;</span></span><span style="font-size: 10pt; font-family: Verdana;">in<span class="Apple-converted-space">&nbsp;</span></span><span style="font-size: 10pt; font-family: Verdana;">the FLASH_WaitForLastOperation() function</span><span style="font-size: 10pt; font-family: Verdana;"><span class="Apple-converted-space">&nbsp;</span></span><span style="font-size: 10pt; font-family: Verdana;">to avoid&nbsp;__ramfunc issue with IAR.</span></p><p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span><br><b><u><span style="font-size: 10pt;">Content
+ </span></u></b></p>
+ <p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x Standard Peripheral Driver <b>v1.2.1</b>. <a href="Libraries/STM8L10x_StdPeriph_Driver/Release_Notes.html">(release notes)</a></span>
+ 
+ 
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x Standard Peripheral Examples <b>v1.2.1</b>. <a href="Project/STM8L10x_StdPeriph_Examples/Release_Notes.html">(release notes)</a></span>
+ 
+ 
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x_StdPeriph_Templates <b>v1.2.1</b>. <a href="Project/STM8L10x_StdPeriph_Templates/Release_Notes.html">(release notes)</a></span>
+ 
+ 
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L101_EVAL <b>v1.2.0</b>. <a href="Utilities/STM8L101_EVAL/Release_Notes.html">(release notes)</a></span>
+ 
+ </spanstyle></p>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span></p>
+ <p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><b><u><span style="font-size: 10pt;">
+ Development Toolchains and Compilers
+ </span></u></b></p>
+ <p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ ST Visual Debug (STVD) toolchain v4.3.6. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Cosmic compiler v4.3.12 (or later). 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Raisonance RKit for STM8 v2.52. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Raisonance RIDE toolchain v7.48. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ IAR Embedded Workbench for STM8 IDE (EWSTM8) v1.42.1.</span></spanstyle></p>
+ <p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><b><u><span style="font-size: 10pt;">
+ Supported Devices and EVAL boards
+ </span></u></b></p>
+ <p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x devices and STM8L1/L2-EVAL revB.</span></spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol"><span style="font-size: 10pt;"></span></spanstyle></p><p class="MsoListParagraph" style="margin-right: 4cm; text-indent: 10pt; line-height: normal;"><span style="font-size: 10pt;"><p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;&nbsp;</span></p></span></p><p class="MsoListParagraph" style="margin-right: 4cm; text-indent: 10pt; line-height: normal;"><span style="font-size: 10pt;"><table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; width: 634px; height: 20px;" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="padding: 0cm 5.4pt;" align="left"><p class="MsoNormal" style="margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 10pt; color: white;">
+ V1.2.0 - 01-June-2012</span></b></p></td></tr></tbody></table></span></p><p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><span style="font-size: 10pt;"></span><span style="font-size: 10pt;"></span><b><u><span style="font-size: 10pt;">Main Changes
+ </span></u></b></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol"><span style="font-size: 10pt;">
+ 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Add IAR Embedded Workbench for STM8 (EWSTM8) toolchain support. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ New "Utilities" folder and drivers architecture. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Package updated with&nbsp;<b><u>new license agreement</u></b>. 
+ </span></spanstyle></p>
+ 
+ <p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span><br><b><u><span style="font-size: 10pt;">Content
+ </span></u></b></p>
+ <p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x Standard Peripheral Driver <b>v1.2.0</b>. <a href="Libraries/STM8L10x_StdPeriph_Driver/Release_Notes.html">(release notes)</a></span>
+ 
+ 
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x Standard Peripheral Examples <b>v1.2.0</b>. <a href="Project/STM8L10x_StdPeriph_Examples/Release_Notes.html">(release notes)</a></span>
+ 
+ 
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x_StdPeriph_Templates <b>v1.2.0</b>. <a href="Project/STM8L10x_StdPeriph_Templates/Release_Notes.html">(release notes)</a></span>
+ 
+ 
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L101_EVAL <b>v1.2.0</b>. <a href="Utilities/STM8L101_EVAL/Release_Notes.html">(release notes)</a></span>
+ 
+ </spanstyle></p>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span></p>
+ <p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><b><u><span style="font-size: 10pt;">
+ Development Toolchains and Compilers
+ </span></u></b></p>
+ <p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ ST Visual Debug (STVD) toolchain v4.3.0. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Cosmic compiler v4.3.6 (or later). 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Raisonance RKit for STM8 v2.40. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ Raisonance RIDE toolchain v7.36. 
+ </span>
+ </spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ IAR Embedded Workbench for STM8 IDE (EWSTM8) v1.30.1. 
+ </span></spanstyle></p>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span></p>
+ <p class="MsoNormal" style="margin-left: 4cm; line-height: normal;"><b><u><span style="font-size: 10pt;">
+ Supported Devices and EVAL boards
+ </span></u></b></p>
+ <p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><spanstyle ="font-size:10.0pt;font-family:Symbol">&#8226;<span style="">&nbsp;</span><span style="font-size: 10pt;">
+ STM8L10x devices and STM8L1/L2-EVAL revB.</span></spanstyle></p><p class="MsoListParagraph" style="margin-left: 4cm; margin-right: 4cm; text-indent: 10pt; line-height: normal;"><span style="font-size: 10pt;"><p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;&nbsp;</span></p></span></p><p class="MsoListParagraph" style="margin-right: 4cm; text-indent: 10pt; line-height: normal;"><span style="font-size: 10pt;"><table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; width: 634px; height: 20px;" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="padding: 0cm 5.4pt;" align="left"><p class="MsoNormal" style="margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 10pt; color: white;">
+ V1.1.0 - 14-September-2009</span></b></p></td></tr></tbody></table></span></p><br><ul style="margin-top: 0cm; margin-left: 160px;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Library<o:p></o:p></span></u></li></ul><p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 205.99pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><o:p></o:p></span></p>
+     <ul style="margin-top: 0cm; margin-left: 160px;" type="square"><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm8l10x_tim2.h:</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style=""> <span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">Change "TIM2_SelectTI1XORInput" function name to&nbsp;"TIM2_SelectHallSensor"</span></li></ul></ul></ul><ul style="margin-top: 0cm; margin-left: 160px;" type="square"><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm8l10x_tim3.h:</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style=""> <span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"></span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">Change "TIM3_SelectTI1XORInput" function name to&nbsp;"TIM3_SelectHallSensor"</span><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style=""></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></span></li></ul></ul></ul>
+     <ul style="margin-top: 0cm; margin-left: 160px;" type="square"><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm8l10x_exti.h:</span></li><ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;"></span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">Change "EXTI_Sensitivity_TypeDef" enumeration name to&nbsp;"EXTI_Trigger_TypeDef"</span><br></li></ul></ul></ul><ul style="margin-top: 0cm; margin-left: 160px;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Examples</span></u><span style="font-size: 10pt; font-family: Verdana;"><o:p></o:p></span></li><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Under "Project" repository, change "Examples" folder name&nbsp; to "STM8L10x_StdPeriph_Examples"</span><span style="font-size: 10pt; font-family: Verdana;"></span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Add &nbsp;GPIO configuration in TIM2 examples&nbsp;</span></li></ul></ul><span style="font-size: 10pt;"><table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; width: 634px; height: 20px;" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="padding: 0cm 5.4pt;" align="left"><p class="MsoNormal" style="margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 10pt; color: white;">
+ 1.0.1 - 19-June-2009</span></b></p></td></tr></tbody></table></span><br><ul style="margin-top: 0cm; margin-left: 200px;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">General</span></u></li><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Project template updated
+           for STVD with both Cosmic and Raisonance compilers<o:p></o:p></span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Project template added
+           for RIDE7 toolchain<o:p></o:p></span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Almost peripheral
+           examples reviewed and validated with both Cosmic and Raisonance
+           compilers<o:p></o:p></span></li></ul><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Library<o:p></o:p></span></u></li><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm8l10x.h : <u><o:p></o:p></u></span></li></ul></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 235.75pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">Flash pointer definition added<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 235.75pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">__CONST<span style="">&nbsp;
+     </span>definition added for Cosmic and Raisonance compilers<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 235.75pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">TINY definition added for Cosmic and Raisonance
+     compilers<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 235.75pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">STM8L10x Standard Peripheral Library old types added
+     for legacy purpose<o:p></o:p></span></p>
+     <ul style="margin-top: 0cm; margin-left: 200px;" type="square"><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm8l10x_gpio.h:<u><o:p></o:p></u></span></li></ul></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 235.75pt; text-indent: -9pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">The GPIO_Mode_TypeDef enum element definition updated:<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_OD_Low_Fast<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_PP_Low_Fast<span style="">&nbsp; </span><o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_OD_Low_Slow <o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_PP_Low_Slow <o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_OD_HiZ_Fast <o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_PP_High_Fast <o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_OD_HiZ_Slow<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">GPIO_Mode_Out_PP_High_Slow<o:p></o:p></span></p>
+     <ul style="margin-top: 0cm; margin-left: 200px;" type="square"><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">stm8l10x_beep.c:<u><o:p></o:p></u></span></li></ul></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">BEEP_Init function updated<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">&nbsp;-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">BEEP-&gt;CSR |= BEEP_CSR_BEEPEN; removed from init
+     function<o:p></o:p></span></p>
+     <ul style="margin-top: 0cm; margin-left: 200px;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Examples</span></u><span style="font-size: 10pt; font-family: Verdana;"><o:p></o:p></span></li><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Almost examples were
+           updated with both Cosmic and Raisonance compilers using STVD
+           toolchain.<o:p></o:p></span></li></ul></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">Exception is made for the following FLASH examples:</span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">FLASH_ExecutionFromRAMWhileBlockWriteOperation<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 271.75pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Wingdings; color: black;"><span style=""><span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"></span><span style="font-size: 10pt; font-family: Verdana; color: black;">FLASH_WriteEraseBlockOperation<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt;"><span style="font-size: 10pt; font-family: Verdana; color: black;"><span style="">&nbsp;&nbsp;</span>--&gt; Dependency
+     related to linkerfile edition<o:p></o:p></span></p>
+     <ul style="margin-top: 0cm; margin-left: 200px;" type="square"><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">AWU example updated<o:p></o:p></span></li></ul></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">AWU_AutoLSICalibration private function removed and
+     replaced by u32 LSIMeasurment <o:p></o:p></span></p>
+     <ul style="margin-top: 0cm; margin-left: 200px;" type="square"><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">BEEP example updated<o:p></o:p></span></li></ul></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">BEEP_AutoLSICalibration private function removed and
+     replaced by u32 LSIMeasurment<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">Add BEEP_Cmd function call in the example after
+     BEEP_Init function update.<o:p></o:p></span></p>
+     <ul style="margin-top: 0cm; margin-left: 200px;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><u><span style="font-size: 10pt; font-family: Verdana;">Project</span></u><span style="font-size: 10pt; font-family: Verdana;"><o:p></o:p></span></li><ul style="margin-top: 0cm;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Project template added
+           for RIDE7 toolchain<o:p></o:p></span></li><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Project templates
+           updated for STVD toolchain<o:p></o:p></span></li></ul></ul>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">stm8_interrupt_vector.c and stm8s_it.c/.h files were
+     updated to use @far instead of @near<o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;">Optimization option updated for STVD with Raisonance
+     project <o:p></o:p></span></p>
+     <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 256.8pt; text-indent: -18pt;"><span style="font-size: 10pt; font-family: Tahoma; color: black;"><span style="">-<span style="font-family: &quot;Times New Roman&quot;; font-style: normal; font-variant: normal; font-weight: normal; font-size: 7pt; line-height: normal; font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span><span style="font-size: 10pt; font-family: Verdana; color: black;"><span style="">&nbsp;</span>SCINAME(STM8)
+     linker option added for STVD with Raisonance project</span></p><u><span style="font-size: 10pt; font-family: Verdana;"></span></u><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt;"><table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; width: 634px; height: 20px;" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td style="padding: 0cm 5.4pt;" align="left"><p class="MsoNormal" style="margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 10pt; color: white;">
+ 1.0.0 - 10-April-2009</span></b></p></td></tr></tbody></table></span><br><ul style="margin-top: 0cm; margin-left: 200px;" type="square"><li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;">Official release</span><span style="font-size: 10pt; font-family: Verdana;"><o:p></o:p></span></li></ul><table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; margin-right: 4cm; width: 80%;" border="0" cellpadding="0" cellspacing="0" width="100%">
+ <tbody><tr><td style="padding: 0cm 5.4pt;">
+ <p class="MsoNormal" style="margin-left: 0cm; margin-bottom: 0cm; line-height: normal;"><b><span style="font-size: 12pt; color: white;">
+ License</span></b></p></td></tr></tbody></table>
+ <p class="MsoNormal" style="line-height: normal;"><span style="font-size: 10pt;">&nbsp;</span></p>
+ <p class="MsoNormal" style="margin-left: 4cm; margin-right: 4cm; line-height: normal;"><span style="font-size: 10pt; color: black;">Licensed under MCD-ST Liberty SW License Agreement V2, (the "License").
+ You may not use this file except in compliance with the License.
+ You may obtain a copy of the License at:
+ 
+ 
+ </span></p>
+ <p class="MsoNormal" style="text-align: center; line-height: normal;"><span style="font-size: 10pt;">
+ <a href="http://www.st.com/software_license_agreement_liberty_v2"> http://www.st.com/software_license_agreement_liberty_v2</a></span></p>
+ <p class="MsoNormal" style="margin-left: 4cm; margin-right: 4cm; line-height: normal;"><span style="font-size: 10pt; color: black;">Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ </span></p>
+ <p class="MsoNormal" style="line-height: normal;"><b><span style="font-size: 10pt;">&nbsp;&nbsp;&nbsp;&nbsp;</span></b></p>
+ <table class="MsoNormal" style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-left: 4cm; margin-right: 4cm; width: 80%;" border="0" cellpadding="0" cellspacing="0" width="100%">
+ <tbody><tr><td style="padding: 0cm 5.4pt;">
+ <p class="MsoNormal" style="margin-left: 0cm; margin-bottom: 0cm; line-height: 4pt;"><b><span style="font-size: 10pt; color: rgb(51, 102, 255);">
+ ---</span></b></p></td></tr></tbody></table>
+ <p class="MsoNormal" style="line-height: normal;"><b><span style="font-size: 10pt;">&nbsp;&nbsp;&nbsp;&nbsp;</span></b></p>
+ <p class="MsoNormal" style="text-align: center; line-height: normal;"><span style="font-size: 10pt;">
+ For complete documentation on <b>STM8</b> microcontrollers please visit <a href="http://www.st.com/stm8"> http://www.st.com/stm8</a></span></p>
+ <p class="MsoNormal" style="line-height: normal;"><b><span style="font-size: 10pt;">&nbsp;&nbsp;&nbsp;</span></b></p>
+ <p class="MsoNormal" style="margin-right: 1cm; line-height: normal;" align="right"><span style="font-size: 8pt;">Generated by RNcreator v2.0
+ </span></p>
+ <!-- Generated by RNcreator v2.0 on Tue 16:54:38 -->
+ 
+ </body></html>
\ Kein Zeilenumbruch am Dateiende.
Binrdateien ./STM8L10x_StdPeriph_Lib_V1.2.1/stm8l10x_stdperiph_lib_um.chm und ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/stm8l10x_stdperiph_lib_um.chm sind verschieden.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,741 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l_eval_i2c_ee.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file provides a set of functions needed to manage the I2C M24CXX
+   *          EEPROM memory mounted on STM8xx-EVAL board.
+   *          It implements a high level communication layer for read and write
+   *          from/to this memory. The needed STM8 hardware resources (I2C and
+   *          GPIO) are defined in stm8l101_eval.h file, and the initialization is
+   *          performed in sEE_LowLevel_Init() function declared in stm8l101_eval.c
+   *          file.
+   *          You can easily tailor this driver to any other development board,
+   *          by just adapting the defines for hardware resources and
+   *          sEE_LowLevel_Init() function.
+   *
+   *          @note In this driver, basic read and write functions (sEE_ReadBuffer()
+   *                and sEE_WritePage()) use the I2C in polling mode to perform 
+   *                the data transfer to/from EEPROM memory 
+   *                Safe procedure is implemented to handle the read operation, 
+   *                ensuring safe data reception in case of 1, 2, 3 or more bytes
+   *                The application should then monitor the variable holding
+   *                the number of data in order to determine when the transfer is
+   *                completed (variable decremented to 0). 
+   *                For more details on the use of this driver you can refer to 
+   *                the I2C_EEPROM example provided within the STM8L10x_StdPeriph_Lib 
+   *                package.     
+   *
+   *     +-----------------------------------------------------------------+
+   *     |                        Pin assignment                           |
+   *     +---------------------------------------+-----------+-------------+
+   *     |  STM8 I2C Pins                       |   sEE     |   Pin       |
+   *     +---------------------------------------+-----------+-------------+
+   *     | .                                     |   E0(GND) |    1  (0V)  |
+   *     | .                                     |   E1(GND) |    2  (0V)  |
+   *     | .                                     |   E2(GND) |    3  (0V)  |
+   *     | .                                     |   E0(VSS) |    4  (0V)  |
+   *     | sEE_I2C_SDA_PIN/ SDA                  |   SDA     |    5        |
+   *     | sEE_I2C_SCL_PIN/ SCL                  |   SCL     |    6        |
+   *     | .                                     |   /WC(VDD)|    7 (3.3V) |
+   *     | .                                     |   VDD     |    8 (3.3V) |
+   *     +---------------------------------------+-----------+-------------+
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l_eval_i2c_ee.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+ 
+ /** @addtogroup STM8L101_EVAL
+   * @{
+   */
+ 
+ /** @addtogroup Common
+   * @{
+   */
+ 
+ /** @addtogroup STM8L_EVAL_I2C_EE
+   * @brief      This file includes the I2C EEPROM driver of STM8-EVAL boards.
+   * @{
+   */
+ 
+ /* Private types -------------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ 
+ 
+ /** @defgroup STM8L_EVAL_I2C_EE_Private_Variables
+   * @{
+   */
+ __IO uint16_t sEEAddress = 0;
+ __IO uint32_t sEETimeout = sEE_TIMEOUT_MAX;
+ __IO uint16_t* sEEDataReadPointer;
+ __IO uint8_t* sEEDataWritePointer;
+ __IO uint8_t sEEDataNum;
+ /**
+   * @}
+   */
+ 
+ /* Private function prototypes -----------------------------------------------*/
+ 
+ 
+ /** @defgroup STM8L_EVAL_I2C_EE_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  DeInitializes peripherals used by the I2C EEPROM driver.
+   * @param  None
+   * @retval None
+   */
+ void sEE_DeInit(void)
+ {
+   sEE_LowLevel_DeInit();
+ }
+ 
+ /**
+   * @brief  Initializes peripherals used by the I2C EEPROM driver.
+   * @param  None
+   * @retval None
+   */
+ void sEE_Init(void)
+ {
+   sEE_LowLevel_Init();
+ 
+   /* I2C configuration */
+   /* sEE_I2C Peripheral Enable */
+   I2C_Cmd(ENABLE);
+   /* sEE_I2C configuration after enabling it */
+   I2C_Init(I2C_SPEED, I2C_SLAVE_ADDRESS7, I2C_DutyCycle_2,
+            I2C_Ack_Enable, I2C_AcknowledgedAddress_7bit);
+ 
+ #if defined (sEE_M24C64_32)
+   /* Select the EEPROM address according to the state of E0, E1, E2 pins */
+   sEEAddress = sEE_HW_ADDRESS;
+ #endif /* sEE_M24C64_32 */
+ }
+ 
+ /**
+   * @brief  Writes one byte to the I2C EEPROM.
+   * @param  pBuffer : pointer to the buffer  containing the data to be written
+   *         to the EEPROM.
+   * @param  WriteAddr : EEPROM's internal address to write to.
+   * @retval None
+   */
+ void sEE_WriteByte(uint8_t* pBuffer, uint16_t WriteAddr)
+ {
+   /* Send STRAT condition */
+   I2C_GenerateSTART(ENABLE);
+ 
+   /* Test on EV5 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT))
+   {}
+ 
+   /* Send EEPROM address for write */
+   I2C_Send7bitAddress((uint8_t)sEEAddress, I2C_Direction_Transmitter);
+ 
+   /* Test on EV6 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
+   {}
+ 
+ #ifdef sEE_M24C64_32
+ 
+   /* Send the EEPROM's internal address to write to : MSB of the address first */
+   I2C_SendData((uint8_t)((WriteAddr & 0xFF00) >> 8));
+ 
+   /* Test on EV8 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+   {}
+ 
+   /* Send the EEPROM's internal address to write to : LSB of the address */
+   I2C_SendData((uint8_t)(WriteAddr & 0x00FF));
+ 
+ #endif /* sEE_M24C64_32 */
+ 
+   /* Test on EV8 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+   {}
+ 
+   /* Send the byte to be written */
+   I2C_SendData(*pBuffer);
+ 
+   /* Test on EV8 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+   {}
+ 
+   /* Send STOP condition */
+   I2C_GenerateSTOP(ENABLE);
+ }
+ 
+ /**
+   * @brief  Reads a block of data from the EEPROM.
+   * @param  pBuffer : pointer to the buffer that receives the data read from
+   *         the EEPROM.
+   * @param  ReadAddr : EEPROM's internal address to read from.
+   * @param  NumByteToRead : pointer to the variable holding number of bytes to
+   *         read from the EEPROM.
+   *
+   *        @note The variable pointed by NumByteToRead is reset to 0 when all the
+   *              data are read from the EEPROM. Application should monitor this
+   *              variable in order know when the transfer is complete.
+   *
+   * @note This function ensures data reading from EEPROM, it assumes that I2C is 
+   *       used with polling or its interrupt priority is not the highest in the 
+   *       application. 
+   *       Method 2 transfer sequence is implemented in this function(refer to RM0013
+   *       for more details). 3 bytes, 2bytes and 1 byte reception cases are handled. 
+   *
+   * @retval None
+   */
+ void sEE_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead)
+ {
+   __IO uint32_t timeout = 0xFFFF;
+ 
+   /* Wait the end of last communication */
+   for (;timeout > 0; timeout--);
+ 
+   /* While the bus is busy */
+   while (I2C_GetFlagStatus(I2C_FLAG_BUSY))
+   {}
+ 
+   /* Send START condition */
+   I2C_GenerateSTART(ENABLE);
+ 
+   /* Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT))
+   {}
+ 
+   /* Send EEPROM address for write */
+   I2C_Send7bitAddress((uint8_t)sEEAddress, I2C_Direction_Transmitter);
+ 
+   /* Test on EV6 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
+   {}
+ 
+ #ifdef sEE_M24C64_32
+ 
+   /* Send the EEPROM's internal address to read from: MSB of the address first */
+   I2C_SendData((uint8_t)((ReadAddr & 0xFF00) >> 8));
+ 
+   /* Test on EV8 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+   {}
+ 
+   /* Send the EEPROM's internal address to read from: LSB of the address */
+   I2C_SendData((uint8_t)(ReadAddr & 0x00FF));
+ 
+ #endif /* sEE_M24C64_32 */
+ 
+   /* Test on EV8 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+   {}
+ 
+   /* Send STRAT condition a second time */
+   I2C_GenerateSTART(ENABLE);
+ 
+   /* Test on EV5 and clear it (cleared by reading SR1 then writing to DR) */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT))
+   {}
+ 
+   /* Send EEPROM address for read */
+   I2C_Send7bitAddress((uint8_t)sEEAddress, I2C_Direction_Receiver);
+ 
+   /* Test on EV6 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
+   {}
+ 
+   /* Read data from first byte until byte N-3 */
+   if ((uint16_t)(*NumByteToRead)> 3) 
+     {
+       /* Poll on BTF */
+        while (I2C_GetFlagStatus(I2C_FLAG_BTF) == RESET)
+       {
+       }   
+ 
+       /* Read a byte from the EEPROM */
+       *pBuffer = I2C_ReceiveData();
+ 
+       /* Point to the next location where the byte read will be saved */
+       *pBuffer++;
+ 
+       /* Decrement the read bytes counter */
+       (uint16_t)(*NumByteToRead)--;
+     }
+ 
+   /*  Remains three data for read: data N-2, data N-1, Data N */
+   /* Three Bytes Master Reception procedure (POLLING) ------------------------*/
+   if ((uint16_t)(*NumByteToRead) == 3)  
+   {
+     /* Data N-2 in DR and data N -1 in shift register */
+     /* Poll on BTF */
+       while (I2C_GetFlagStatus( I2C_FLAG_BTF) == RESET)
+       {
+       } 
+ 
+       /* Clear ACK */
+       I2C_AcknowledgeConfig(DISABLE);
+ 
+       /* disable general interrupts */
+       disableInterrupts(); 
+ 
+       /* Read Data N-2 */
+       *pBuffer = I2C_ReceiveData();
+ 
+       /* Point to the next location where the byte read will be saved */
+       *pBuffer++;
+ 
+       /* Program the STOP */
+       I2C_GenerateSTOP(ENABLE);
+ 
+       /* Read DataN-1 */
+       *pBuffer = I2C_ReceiveData();
+ 
+        /* re-enable interrupts */
+         enableInterrupts(); 
+ 
+       /* Point to the next location where the byte read will be saved */
+       *pBuffer++;
+ 
+       /* Poll on RxNE */
+       while (I2C_GetFlagStatus(I2C_FLAG_RXNE) == RESET)
+       {
+       }
+       /* Read DataN */
+       *pBuffer = I2C_ReceiveData();
+ 
+       /* Reset the number of bytes to be read from the EEPROM */
+       NumByteToRead = 0;
+     }
+ 
+   /* If number of data to be read is 2 */
+   /* Tow Bytes Master Reception procedure (POLLING) ---------------------------*/
+   if ((uint16_t)(*NumByteToRead) == 2)
+   {
+     /* Enable acknowledgement on next byte (set POS and ACK bits)*/
+     I2C_AcknowledgeConfig(ENABLE);
+     I2C_AckPositionConfig(I2C_AckPosition_Next);
+     
+     /* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
+     while(I2C_GetFlagStatus( I2C_FLAG_ADDR) == RESET)
+     {
+     }
+ 
+     /* Clear ADDR register by reading SR1 then SR3 register (SR1 has already been read) */
+      (void)I2C->SR3;
+         
+     /* Disable Acknowledgement */
+     I2C_AcknowledgeConfig(DISABLE);
+     
+     /* Wait for BTF flag to be set */
+       while (I2C_GetFlagStatus( I2C_FLAG_BTF) == RESET)
+       {
+       } 
+     
+     /* Disable interrupts */
+     disableInterrupts();
+     
+     /* Program the STOP */
+       I2C_GenerateSTOP(ENABLE);
+       
+     /* Read Data N-1 */
+       *pBuffer = I2C_ReceiveData();
+ 
+       /* Point to the next location where the byte read will be saved */
+       *pBuffer++;  
+            
+     /* re-enable interrupts */
+     enableInterrupts();
+        
+     /* Read Data N */
+       *pBuffer = I2C_ReceiveData();
+           
+     /* Reset the number of bytes to be read from the EEPROM */
+       NumByteToRead = 0;   
+   }
+ 
+   /* If number of data to be read is 1 */
+   /* One Byte Master Reception procedure (POLLING) ---------------------------*/
+   if ((uint16_t)(*NumByteToRead) < 2)
+   {
+     /* Wait on ADDR flag to be set (ADDR is still not cleared at this level */
+     while(I2C_GetFlagStatus( I2C_FLAG_ADDR) == RESET)
+     {
+     } 
+        
+     /* Disable Acknowledgement */
+     I2C_AcknowledgeConfig(DISABLE); 
+ 
+     /* Disable interrupts */
+     disableInterrupts();
+     
+     /* Clear ADDR register by reading SR1 then SR3 register (SR1 has already been read) */
+     (void)sEE_I2C->SR3;
+     
+     /* Send STOP Condition */
+     I2C_GenerateSTOP( ENABLE);
+    
+     /* re-enable interrupts */
+     enableInterrupts();
+     
+     /* Wait for the byte to be received */
+     while(I2C_GetFlagStatus( I2C_FLAG_RXNE) == RESET)
+     {
+     }
+     
+     /* Read the byte received from the EEPROM */
+     *pBuffer = I2C_ReceiveData();
+     
+     /* Decrement the read bytes counter */
+     (uint16_t)(*NumByteToRead)--;        
+     
+     /* Wait to make sure that STOP control bit has been cleared */
+     while(sEE_I2C->CR2 & I2C_CR2_STOP)
+     {
+     }  
+     
+     /* Re-Enable Acknowledgement to be ready for another reception */
+     I2C_AcknowledgeConfig(ENABLE);  
+   }
+ }
+ 
+ /**
+   * @brief  Writes buffer of data to the I2C EEPROM.
+   * @param  pBuffer : pointer to the buffer  containing the data to be written
+   *         to the EEPROM.
+   * @param  WriteAddr : EEPROM's internal address to write to.
+   * @param  NumByteToWrite : number of bytes to write to the EEPROM.
+   * @retval None
+   */
+ void sEE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite)
+ {
+   uint8_t NumOfPage = 0, NumOfSingle = 0, count = 0;
+   uint16_t Addr = 0;
+ 
+   Addr = WriteAddr % sEE_PAGESIZE;
+   count = (uint8_t)(sEE_PAGESIZE - (uint16_t)Addr);
+   NumOfPage =  (uint8_t)(NumByteToWrite / sEE_PAGESIZE);
+   NumOfSingle = (uint8_t)(NumByteToWrite % sEE_PAGESIZE);
+ 
+   /* If WriteAddr is sEE_PAGESIZE aligned  */
+   if (Addr == 0)
+   {
+     /* If NumByteToWrite < sEE_PAGESIZE */
+     if (NumOfPage == 0)
+     {
+       /* Store the number of data to be written */
+       sEEDataNum = NumOfSingle;
+       /* Start writing data */
+       sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+       /* Wait data transfer to be complete */
+       sEETimeout = sEE_TIMEOUT_MAX;
+       while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+       {}
+       
+       sEE_WaitEepromStandbyState();
+     }
+     /* If NumByteToWrite > sEE_PAGESIZE */
+     else
+     {
+       while (NumOfPage--)
+       {
+         /* Store the number of data to be written */
+         sEEDataNum = sEE_PAGESIZE;
+         sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+         WriteAddr +=  sEE_PAGESIZE;
+         pBuffer += sEE_PAGESIZE;
+       }
+ 
+       if (NumOfSingle != 0)
+       {
+         /* Store the number of data to be written */
+         sEEDataNum = NumOfSingle;
+         sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+       }
+     }
+   }
+   /* If WriteAddr is not sEE_PAGESIZE aligned  */
+   else
+   {
+     /* If NumByteToWrite < sEE_PAGESIZE */
+     if (NumOfPage == 0)
+     {
+       /* If the number of data to be written is more than the remaining space
+       in the current page: */
+       if (NumByteToWrite > count)
+       {
+         /* Store the number of data to be written */
+         sEEDataNum = count;
+         /* Write the data contained in the same page */
+         sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+ 
+         /* Store the number of data to be written */
+         sEEDataNum = (uint8_t)(NumByteToWrite - count);
+         /* Write the remaining data in the following page */
+         sEE_WritePage((uint8_t*)(pBuffer + count), (WriteAddr + count), (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+       }
+       else
+       {
+         /* Store the number of data to be written */
+         sEEDataNum = NumOfSingle;
+         sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+       }
+     }
+     /* If NumByteToWrite > sEE_PAGESIZE */
+     else
+     {
+       NumByteToWrite -= count;
+       NumOfPage = (uint8_t)(NumByteToWrite / sEE_PAGESIZE);
+       NumOfSingle = (uint8_t)(NumByteToWrite % sEE_PAGESIZE);
+ 
+       if (count != 0)
+       {
+         /* Store the number of data to be written */
+         sEEDataNum = count;
+         sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+         WriteAddr += count;
+         pBuffer += count;
+       }
+ 
+       while (NumOfPage--)
+       {
+         /* Store the number of data to be written */
+         sEEDataNum = sEE_PAGESIZE;
+         sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+         WriteAddr +=  sEE_PAGESIZE;
+         pBuffer += sEE_PAGESIZE;
+       }
+       if (NumOfSingle != 0)
+       {
+         /* Store the number of data to be written */
+         sEEDataNum = NumOfSingle;
+         sEE_WritePage(pBuffer, WriteAddr, (uint8_t*)(&sEEDataNum));
+         /* Wait data transfer to be complete */
+         sEETimeout = sEE_TIMEOUT_MAX;
+         while ((sEEDataNum > 0) && (sEETimeout-- > 0))
+         {}
+         sEE_WaitEepromStandbyState();
+       }
+     }
+   }
+ }
+ 
+ /**
+   * @brief  Writes more than one byte to the EEPROM with a single WRITE cycle.
+   *   
+   * @note   The number of bytes (combined to write start address) must not 
+   *         cross the EEPROM page boundary. This function can only write into
+   *         the boundaries of an EEPROM page.
+   *         This function doesn't check on boundaries condition (in this driver 
+   *         the function sEE_WriteBuffer() which calls sEE_WritePage() is 
+   *         responsible of checking on Page boundaries).
+   * 
+   * @param  pBuffer: pointer to the buffer containing the data to be written to 
+   *         the EEPROM.
+   * @param  WriteAddr: EEPROM's internal address to write to.
+   * @param  NumByteToWrite: pointer to the variable holding number of bytes to 
+   *         be written into the EEPROM. 
+   * 
+   *        @note The variable pointed by NumByteToWrite is reset to 0 when all the 
+   *              data are written to the EEPROM. Application should monitor this 
+   *              variable in order know when the transfer is complete.
+   *
+   * @retval None
+   */
+ void sEE_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite)
+ {
+   __IO uint32_t timeout = 0xFFFF;
+ 
+   /* Wait the end of last communication */
+   for (;timeout > 0; timeout--);
+ 
+   /* Set the pointer to the Number of data to be written. 
+      User should check on this variable in order to know if the 
+      data transfer has been completed or not. */
+   sEEDataWritePointer = NumByteToWrite;
+ 
+   /* While the bus is busy */
+   while (I2C_GetFlagStatus(I2C_FLAG_BUSY))
+   {}
+ 
+   /* Send START condition */
+   I2C_GenerateSTART(ENABLE);
+ 
+   /* Test on EV5 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_MODE_SELECT))
+   {}
+ 
+   /* Send EEPROM address for write */
+   I2C_Send7bitAddress((uint8_t)sEEAddress, I2C_Direction_Transmitter);
+ 
+   /* Test on EV6 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
+   {}
+ 
+ #ifdef sEE_M24C64_32
+ 
+   /* Send the EEPROM's internal address to write to : MSB of the address first */
+   I2C_SendData((uint8_t)((WriteAddr & 0xFF00) >> 8));
+ 
+   /* Test on EV8 and clear it */
+   while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+   {}
+ 
+   /* Send the EEPROM's internal address to write to : LSB of the address */
+   I2C_SendData((uint8_t)(WriteAddr & 0x00FF));
+ 
+ #endif /* sEE_M24C64_32 */
+ 
+   /* Test on EV8 and clear it */
+   while (! I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+   {}
+ 
+   /* While there is data to be written */
+   while((uint16_t)(*NumByteToWrite) > 0)
+   {
+     /* Send the byte to be written */
+     I2C_SendData( *pBuffer);
+ 
+     /* Test on EV8 and clear it */
+     /* Wait till all data have been physically transferred on the bus */
+     while (!I2C_CheckEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
+     {}
+     (uint16_t)(*NumByteToWrite)--;
+   }
+   
+    /* Send STOP condition */
+     I2C_GenerateSTOP(ENABLE);
+     
+     /* Perform a read on SR1 and SR3 register to clear eventually pending flags */
+     (void)sEE_I2C->SR1;
+     (void)sEE_I2C->SR3;
+ }
+ 
+ /**
+   * @brief  Wait for EEPROM Standby state.
+   * 
+   * @note  This function allows to wait and check that EEPROM has finished the 
+   *        last Write operation. It is mostly used after a Write operation: after 
+   *        receiving the buffer to be written, the EEPROM may need additional 
+   *        time to actually perform the write operation. During this time, it 
+   *        doesn't answer to I2C packets addressed to it. Once the write operation 
+   *        is complete the EEPROM responds to its address.
+   *        
+   * @note  It is not necessary to call this function after sEE_WriteBuffer() 
+   *        function (sEE_WriteBuffer() already calls this function after each
+   *        write page operation).    
+   * 
+   * @param  None
+   * @retval None
+   */
+ void sEE_WaitEepromStandbyState(void) 
+ {
+   __IO uint8_t tempreg = 0;
+   __IO uint32_t timeout = 0xFFFF;
+ 
+   do
+   {
+     /*!< Send START condition */
+     I2C_GenerateSTART(ENABLE);
+ 
+     /* Test on EEPROM_I2C EV5 and clear it */
+     while (!I2C_GetFlagStatus(I2C_FLAG_SB))  /* EV5 */
+     {
+     }
+ 
+     /*!< Send EEPROM address for write */
+     I2C_Send7bitAddress((uint8_t)sEEAddress, I2C_Direction_Transmitter);
+ 
+     /*!< Wait for address acknowledgement */
+     for (;timeout > 0; timeout--);
+ 
+     /*!< Read sEE SR1 register to clear pending flags */
+     tempreg = I2C->SR1;
+ 
+   }
+   while (!(tempreg & 0x02));
+ 
+   /*!< Clear AF flag */
+   I2C_ClearFlag(I2C_FLAG_AF);
+ 
+   /*!< STOP condition */
+   I2C_GenerateSTOP(ENABLE);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+   
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_i2c_ee.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,120 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l_eval_i2c_ee.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions prototypes for the stm8_eval_i2c_ee
+   *          firmware driver.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */ 
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L_EVAL_I2C_EE_H
+ #define __STM8L_EVAL_I2C_EE_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l101_eval.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+   
+ /** @addtogroup STM8L101_EVAL
+   * @{
+   */ 
+ 
+ /** @addtogroup Common
+   * @{
+   */
+   
+ /** @addtogroup STM8L_EVAL_I2C_EE
+   * @{
+   */  
+ 
+ /* Private types -------------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+   
+ /** @defgroup STM8L_EVAL_I2C_EE_Private_define
+   * @{
+   */
+ #if !defined (sEE_M24C64_32)
+ /* Use the defines below the choose the EEPROM type */
+  #define sEE_M24C64_32  /* Support the devices: M24C32 and M24C64 */
+ #endif
+ 
+ #ifdef sEE_M24C64_32
+ /* For M24C32 and M24C64 devices, E0,E1 and E2 pins are all used for device 
+   address selection (ne need for additional address lines). According to the 
+   Hardware connection on the board (on STM8L1x-EVAL board E0 = E1 = E2 = 0) */
+ 
+  #define sEE_HW_ADDRESS     0xA0   /* E0 = E1 = E2 = 0 */ 
+ #endif /* sEE_M24C64_32 */
+ 
+ #define I2C_SPEED              200000
+ #define I2C_SLAVE_ADDRESS7     0xA0
+ 
+ #if defined (sEE_M24C64_32)
+  #define sEE_PAGESIZE    32
+ #endif
+  
+ /* Maximum timeout value for counting before exiting waiting loop.
+    This value depends directly on the maximum page size and
+    the sytem clock frequency. */
+ #define sEE_TIMEOUT_MAX         0x10000
+ /**
+   * @}
+   */ 
+   
+ /* Private macro -------------------------------------------------------------*/
+ 
+ /** @defgroup STM8L_EVAL_I2C_EE_Exported_Functions
+   * @{
+   */ 
+ void sEE_DeInit(void);
+ void sEE_Init(void);
+ void sEE_WriteByte(uint8_t* pBuffer, uint16_t WriteAddr);
+ void sEE_WritePage(uint8_t* pBuffer, uint16_t WriteAddr, uint8_t* NumByteToWrite);
+ void sEE_WriteBuffer(uint8_t* pBuffer, uint16_t WriteAddr, uint16_t NumByteToWrite);
+ void sEE_ReadBuffer(uint8_t* pBuffer, uint16_t ReadAddr, uint16_t* NumByteToRead);
+ void sEE_WaitEepromStandbyState(void);
+ 
+ #endif /* __STM8L_EVAL_I2C_EE_H */
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */ 
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,420 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l_eval_lcd.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file includes driver for the dot matrix LCD Module mounted on
+   *          STM8L15xx-EVAL board.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l_eval_lcd.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+ 
+ /** @defgroup STM8L101_EVAL_LCD
+   * @{
+   */
+ 
+ /** @defgroup STM8L_EVAL_LCD_Private_Types
+   * @{
+   */
+ /**
+   * @}
+   */
+ 
+ /** @defgroup STM8L_EVAL_LCD_Private_Defines
+   * @{
+   */
+ 
+ #define STATUS_TYPE 0xFC
+ 
+ /* This table contains the "S" of ST logo */
+ CONST uint8_t S_CGRAM[] =
+   {
+     /* 0~7 */
+     0x03, 0xff,
+     0x02, 0x00,
+     0x04, 0x00,
+     0x04, 0x00,
+     0x0c, 0x7f,
+     0x0c, 0x7f,
+     0x1c, 0x3f,
+     0x1e, 0x1f,
+     /* 8~15 */
+     0x3f, 0x0f,
+     0x3f, 0x87,
+     0x7f, 0xc3,
+     0x7f, 0xe3,
+     0x00, 0x03,
+     0x00, 0x03,
+     0x00, 0x07,
+     0xff, 0xfe,
+   };
+ 
+ /* This table contains the "T" of ST logo */
+ CONST uint8_t T_CGRAM[] =
+   {
+     /* 0~7 */
+     0xff, 0xff,
+     0x00, 0x00,
+     0x00, 0x00,
+     0x00, 0x00,
+     0xf8, 0xf8,
+     0xf0, 0xf8,
+     0xf0, 0xf0,
+     0xf0, 0xf0,
+     /* 8~15 */
+     0xe1, 0xe0,
+     0xe3, 0xe0,
+     0xc3, 0xc0,
+     0xc7, 0xc0,
+     0x87, 0xc0,
+     0x8f, 0x80,
+     0x0f, 0x80,
+     0x1f, 0x00
+   };
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ static void LCD_SPISendByte(uint8_t DataToSend);
+ static void LCD_DisplayCGRAM0(uint8_t address, uint8_t *ptrTable);
+ static void LCD_DisplayCGRAM1(uint8_t address, uint8_t *ptrTable);
+ 
+ /**
+   * @brief  The delay function implemented in this driver is not a precise one,
+   *         however it allows the insertion of 1ms delay when Fcpu is 16Mhz if 
+   *         the passed parameter is 0x4000.
+   *         Any change in system clock frequency will impact this delay duration.
+   *         
+   *         User is given the possibility to develop a customized and accurate
+   *         delay function by the mean of timers for example. 
+   *         Uncommenting " #define USE_Delay" line in the stm8l_eval_lcd.h file 
+   *         will allow the consideration of the new function by this driver. 
+   */      
+ static void delay(__IO uint32_t nCount);
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /** @defgroup STM8L_EVAL_LCD_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Initialize the LCD
+   * @param  None
+   * @retval None
+   */
+ void STM8L_EVAL_LCD_Init(void)
+ {
+   /* Enable SPI clock */
+   CLK_PeripheralClockConfig(LCD_SPI_CLK, ENABLE);
+ 
+   /* Configure SPI pins: SCK and MOSI */
+   GPIO_Init(LCD_SPI_GPIO_PORT, LCD_SPI_SCK_PIN | LCD_SPI_MOSI_PIN, GPIO_Mode_Out_PP_Low_Fast);
+ 
+   /* Initialize SPI */
+   SPI_Init(SPI_FirstBit_MSB, SPI_BaudRatePrescaler_64, SPI_Mode_Master,
+            SPI_CPOL_High, SPI_CPHA_2Edge,  SPI_Direction_1Line_Tx, SPI_NSS_Soft);
+   SPI_Cmd(ENABLE);
+ 
+   /* Required to ensure proper LCD display when the board is powered-on ... */
+   _delay_(0x4000); /* 1ms _delay_ using Fcpu = 16Mhz*/
+ 
+   /* Configure LCD ChipSelect pin (CS) in Output push-pull mode */
+   GPIO_Init(LCD_CS_GPIO_PORT, LCD_CS_PIN, GPIO_Mode_Out_PP_Low_Fast);
+ 
+ 
+   /* Set the LCD in TEXT mode */
+   LCD_SendByte(COMMAND_TYPE, SET_TEXT_MODE);
+ 
+   /* Enable the display */
+   LCD_SendByte(COMMAND_TYPE, DISPLAY_ON);
+ 
+   /* Clear the LCD */
+   LCD_SendByte(COMMAND_TYPE, DISPLAY_CLR);
+ 
+   /* Delay required to complete LCD clear command */
+   _delay_(0x4000); /* 1ms _delay_ using Fcpu = 16Mhz*/
+ 
+   /* Select the entry mode type */
+   LCD_SendByte(COMMAND_TYPE, ENTRY_MODE_SET_INC);
+ }
+ 
+ /**
+   * @brief  Set the LCD cursor to the specified location
+   * @param  Line : line where the cursor will be set (LCD_LINE1 or LCD_LINE2)
+   * @param  Offset : is the position offset (only even position are supported)
+   * @retval None
+   */
+ void LCD_SetCursorPos(uint8_t Line, uint8_t Offset)
+ {
+   LCD_SendByte(COMMAND_TYPE, (uint8_t)(Line + Offset));
+ }
+ 
+ /**
+   * @brief  Send a byte to LCD
+   * @param  DataType Type of Data to be sent
+   * @param  DataToSend Data to be sent
+   * @retval None
+   */
+ void LCD_SendByte(uint8_t DataType, uint8_t DataToSend)
+ {
+   /* Enable access to LCD */
+   LCD_CS_HIGH();
+ 
+   /* Send Synchro/Mode byte */
+   LCD_SPISendByte(DataType);
+ 
+   /* Send byte high nibble */
+   LCD_SPISendByte((uint8_t)(DataToSend & (uint8_t)0xF0));
+ 
+   /* Send byte low nibble */
+   LCD_SPISendByte((uint8_t)((uint8_t)(DataToSend << 4) & (uint8_t)0xF0));
+   _delay_(80);
+ 
+   /* Disable access to LCD */
+   LCD_CS_LOW();
+ }
+ 
+ /**
+   * @brief  Clear the LCD
+   * @param  None
+   * @retval None
+   */
+ void LCD_Clear(void)
+ {
+   LCD_SendByte(COMMAND_TYPE, DISPLAY_CLR); /* Clear the LCD */
+ 
+   /* Delay required to complete LCD clear command */
+   _delay_(0x4000); /* 1ms _delay_ using Fcpu = 16Mhz*/
+ 
+ }
+ 
+ /**
+   * @brief  Display a string from current position of the LCD cursor
+   * @param  ptr : Pointer to the string to display
+   * @retval None
+   */
+ void LCD_Print(uint8_t *ptr)
+ {
+   __IO uint8_t charindex = 0x00;
+ 
+   /* Display the string */
+   while ((*ptr) && (charindex < 0x0F))
+   {
+     LCD_SendByte(DATA_TYPE, *ptr++);
+     charindex++;
+   }
+ }
+ 
+ /**
+   * @brief  Display a string in rolling mode
+   * @param  Line : line used for displaying the text (LCD_LINE1 or LCD_LINE2)
+   * @param  ptr : Pointer to the text to display
+   * @param  speed : Rolling speed
+   * @retval
+   * None
+   */
+ void LCD_RollString(uint8_t Line, uint8_t *ptr, uint16_t speed)
+ {
+ 
+   uint8_t CharPos = 0;
+   uint8_t *ptr2;
+ 
+   /* Set cursor position at beginning of line */
+   LCD_SendByte(COMMAND_TYPE, Line);
+ 
+   ptr2 = ptr;
+ 
+   /* Display each character of the string */
+   while (*ptr2 != 0)
+   {
+     if (*ptr != 0)
+     {
+       LCD_SendByte(DATA_TYPE, *ptr);
+       ptr++;
+     }
+     else
+     {
+       LCD_SendByte(DATA_TYPE, ' ');
+     }
+ 
+     CharPos++;
+ 
+     if (CharPos == LCD_LINE_MAX_CHAR)
+     {
+       _delay_(speed);
+ 
+       /* Select the line to be cleared */
+       LCD_SendByte(COMMAND_TYPE, Line);
+ 
+       /* Clear the selected line */
+       for (CharPos = 0; CharPos < LCD_LINE_MAX_CHAR; CharPos++)
+       {
+         LCD_SendByte(DATA_TYPE, ' ');
+       }
+       LCD_SendByte(COMMAND_TYPE, Line);
+       CharPos = 0;
+       ptr2++;
+       ptr = ptr2;
+     }
+   }
+ }
+ 
+ /**
+   * @brief  Display ST logo
+   * @param  address : Display address (LINE1:0x80-0x87 and LINE2:0x90-0x97)
+   * @retval None
+   */
+ void LCD_DisplayLogo(uint8_t address)
+ {
+   LCD_DisplayCGRAM0(address, (uint8_t*)S_CGRAM);
+   LCD_DisplayCGRAM1(address, (uint8_t*)T_CGRAM);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup LCD_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Send a byte to LCD through the SPI peripheral
+   * @param  DataToSend : Data to be sent
+   * @retval None
+   */
+ static void LCD_SPISendByte(uint8_t DataToSend)
+ {
+   while ((LCD_SPI->SR & SPI_SR_TXE) == 0)
+   {
+     /* Wait while the byte is transmitted */
+   }
+ 
+   /* Send byte through the SPI peripheral */
+   LCD_SPI->DR = DataToSend;
+ 
+ }
+ 
+ /**
+   * @brief  Display CGRAM on even address
+   * @param  address : Display address
+   * @param  ptrTable : Pointer a the CGRAM table to be displayed
+   * @retval None
+   */
+ static void LCD_DisplayCGRAM0(uint8_t address, uint8_t *ptrTable)
+ {
+ 
+   uint8_t u = 32; /* Nb byte in the table */
+ 
+   /* Set CGRAM Address */
+   LCD_SendByte(COMMAND_TYPE, (uint8_t)0x40);
+ 
+   while (u)
+   {
+     LCD_SendByte(DATA_TYPE, ptrTable[32 - u]);
+     u--;
+   }
+ 
+   /* Setup Display Address */
+   LCD_SendByte(COMMAND_TYPE, address);
+   LCD_SendByte(DATA_TYPE, (uint8_t)0x00);
+   LCD_SendByte(DATA_TYPE, (uint8_t)0x00);
+ 
+ }
+ 
+ /**
+   * @brief  Display CGRAM on odd address
+   * @param  address : Display address
+   * @param  ptrTable : Pointer a the CGRAM table to be displayed
+   * @retval None
+   */
+ static void LCD_DisplayCGRAM1(uint8_t address, uint8_t *ptrTable)
+ {
+ 
+   uint8_t u = 32; /* Nb byte in the table */
+ 
+   /* Set CGRAM Address */
+   LCD_SendByte(COMMAND_TYPE, (uint8_t)((uint8_t)0x40 | (uint8_t)0x10));
+ 
+   while (u)
+   {
+     LCD_SendByte(DATA_TYPE, ptrTable[32 - u]);
+     u--;
+   }
+ 
+   /* Setup Display Address */
+   LCD_SendByte(COMMAND_TYPE, (uint8_t)(address + 1));
+   LCD_SendByte(DATA_TYPE, (uint8_t)0x00);
+   LCD_SendByte(DATA_TYPE, (uint8_t)0x02);
+ 
+ }
+ 
+ #ifndef USE_Delay
+ /**
+   * @brief  Inserts a delay time.
+   *         The delay function implemented in this driver is not a precise one,
+   *         however it allows the insertion of 1ms delay when Fcpu is 16Mhz if 
+   *         the passed parameter is 0x4000.
+   *         Any change in system clock frequency will impact this delay duration.
+   *         
+   *         User is given the possibility to develop a customized and accurate
+   *         delay function by the mean of timers for example. 
+   *         Uncommenting " #define USE_Delay" line in the stm8l_eval_lcd.h file 
+   *         will allow the consideration of the new function by this driver. 
+   *    
+   * @param  nCount: specifies the _delay_ time length.
+   * @retval None
+   */
+ static void delay(__IO uint32_t nCount)
+ {
+   /* Decrement nCount value */
+   while (nCount != 0)
+   {
+     nCount--;
+   }
+ }
+ #endif /* USE_Delay*/
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_lcd.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,153 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l_eval_lcd.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions prototypes for the Dot matrix 
+   *          LCD firmware driver.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */ 
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L_EVAL_LCD_H
+ #define __STM8L_EVAL_LCD_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l101_eval.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+   
+ /** @addtogroup STM8L101_EVAL
+   * @{
+   */ 
+ 
+ /** @addtogroup Common
+   * @{
+   */
+ 
+ /** @addtogroup STM8L_EVAL_LCD
+   * @{
+   */  
+   
+ /* Exported constants --------------------------------------------------------*/
+ 
+ /*
+  * Uncomment the line below if you want to use user defined Delay function
+  * (for precise timing), otherwise default _delay_ function defined within
+  *  this driver is used (less precise timing).  
+  */
+  
+ /* #define USE_Delay */
+ 
+ #ifdef USE_Delay
+ #include "main.h"
+  
+   #define _delay_     Delay  /* !< User can provide more timing precise _delay_ 
+                                    function (with at least 1ms time base), using
+                                    Timer for example */
+ #else
+   #define _delay_     delay      /* !< Default _delay_ function with less precise timing */
+ #endif 	
+ 
+ 
+ 
+ /** @addtogroup STM8L_EVAL_LOW_LEVEL_DOT_MATRIX_LCD
+   * @{
+   */
+ /**
+   * @brief  Defines for the SPI and GPIO pins used to drive the SPI Flash
+   */
+ 
+  #define LCD_SPI                         SPI
+  #define LCD_CS_GPIO_PORT                GPIOD /* LCD Chip Select I/O definition */
+  #define LCD_CS_PIN                      GPIO_Pin_1
+  #define LCD_SPI_CLK                     CLK_Peripheral_SPI
+  #define LCD_SPI_SCK_PIN                 GPIO_Pin_5
+  #define LCD_SPI_MOSI_PIN                GPIO_Pin_6
+  #define LCD_SPI_MISO_PIN                GPIO_Pin_7
+  #define LCD_SPI_GPIO_PORT               GPIOB
+ 
+ /**
+   * @}
+   */
+ 
+ /* LCD managed as 2 Lines of 15 characters (2Lines * 15Char) */
+ #define LCD_LINE_MAX_CHAR    ((uint8_t)15)
+ #define LCD_LINE1            ((uint8_t)0x80)
+ #define LCD_LINE2            ((uint8_t)0x90)
+ 
+ /* LCD Commands */
+ #define COMMAND_TYPE         ((uint8_t)0xF8)
+ #define DATA_TYPE            ((uint8_t)0xFA)
+ #define SET_TEXT_MODE        ((uint8_t)0x30) /* 8-Bits Interface, Normal inst., Text mode */
+ #define SET_EXTENDED_INST    ((uint8_t)0x34)
+ #define SET_GRAPHIC_MODE     ((uint8_t)0x36) /* 8-Bits Interface, Extended inst., Graphic mode */
+ #define DISPLAY_ON           ((uint8_t)0x0C) /* Cursor and blink off */
+ #define DISPLAY_OFF          ((uint8_t)0x08)
+ #define DISPLAY_CLR          ((uint8_t)0x01)
+ #define ENTRY_MODE_SET_INC   ((uint8_t)0x06)
+ 
+ 
+ /** @defgroup STM8L_EVAL_LCD_Exported_Macros
+   * @{
+   */
+ 
+ /** 
+   * @brief  Deselect LCD: ChipSelect pin low : LCD disabled
+   */  
+ #define LCD_CS_LOW()     GPIO_ResetBits(LCD_CS_GPIO_PORT, LCD_CS_PIN)
+ /** 
+   * @brief  Select LCD : ChipSelect pin high : LCD enabled   
+   */ 
+ #define LCD_CS_HIGH()    GPIO_SetBits(LCD_CS_GPIO_PORT, LCD_CS_PIN)
+ /**
+   * @}
+   */
+   
+ /* Exported functions --------------------------------------------------------*/
+ void STM8L_EVAL_LCD_Init(void);
+ void LCD_SetCursorPos(uint8_t Line, uint8_t Offset);
+ void LCD_SendByte(uint8_t DataType, uint8_t DataToSend);
+ void LCD_Clear(void);
+ void LCD_Print(uint8_t *ptr);
+ void LCD_DisplayLogo(uint8_t address);
+ void LCD_RollString(uint8_t Line, uint8_t *ptr, uint16_t speed);
+ 
+ #endif /* __STM8L_EVAL_LCD_H */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */ 
+ 
+ /**
+   * @}
+   */ 
+   
+ /**
+   * @}
+   */  
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,873 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l_eval_spi_sd.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file provides a set of functions needed to manage the SPI SD
+   *          Card memory mounted on STM8xx-EVAL board (refer to stm8l_eval.h
+   *          to know about the boards supporting this memory).
+   *          It implements a high level communication layer for read and write
+   *          from/to this memory. The needed STM8 hardware resources (SPI and
+   *          GPIO) are defined in stm8l101_eval.h file, and the initialization is
+   *          performed in SD_LowLevel_Init() function declared in stm8xx_eval.c
+   *          file.
+   *          You can easily tailor this driver to any other development board,
+   *          by just adapting the defines for hardware resources and
+   *          SD_LowLevel_Init() function.
+   *
+   *          +-------------------------------------------------------+
+   *          |                     Pin assignment                    |
+   *          +-------------------------+---------------+-------------+
+   *          |  STM8 SPI Pins         |     SD        |    Pin      |
+   *          +-------------------------+---------------+-------------+
+   *          | SD_SPI_CS_PIN           |   ChipSelect  |    1        |
+   *          | SD_SPI_MOSI_PIN / MOSI  |   DataIn      |    2        |
+   *          |                         |   GND         |    3 (0 V)  |
+   *          |                         |   VDD         |    4 (3.3 V)|
+   *          | SD_SPI_SCK_PIN / SCLK   |   Clock       |    5        |
+   *          |                         |   GND         |    6 (0 V)  |
+   *          | SD_SPI_MISO_PIN / MISO  |   DataOut     |    7        |
+   *          +-------------------------+---------------+-------------+
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l_eval_spi_sd.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+ 
+ /** @addtogroup STM8L101_EVAL
+   * @{
+   */
+ 
+ /** @addtogroup Common
+   * @{
+   */
+ 
+ /** @addtogroup STM8L_EVAL_SPI_SD
+   * @brief      This file includes the SD card driver of STM8-EVAL boards.
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /** @defgroup STM8L_EVAL_SPI_SD_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  DeInitializes the SD/SD communication.
+   * @param  None
+   * @retval None
+   */
+ void SD_DeInit(void)
+ {
+   SD_LowLevel_DeInit();
+ }
+ 
+ /**
+   * @brief  Initializes the SD/SD communication.
+   * @param  None
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_Init(void)
+ {
+   uint32_t i = 0;
+ 
+   /*!< Initialize SD_SPI */
+   SD_LowLevel_Init();
+ 
+   /*!< SD chip select high */
+   SD_CS_LOW();
+ 
+   /*!< Send dummy byte 0xFF, 10 times with CS high */
+   /*!< Rise CS and MOSI for 80 clocks cycles */
+   for (i = 0; i <= 9; i++)
+   {
+     /*!< Send dummy byte 0xFF */
+     SD_WriteByte(SD_DUMMY_BYTE);
+   }
+   /*------------Put SD in SPI mode--------------*/
+   /*!< SD initialized and set to SPI mode properly */
+   return (SD_GoIdleState());
+ }
+ 
+ /**
+   * @brief  Returns information about specific card.
+   * @param  cardinfo: pointer to a SD_CardInfo structure that contains all SD
+   *         card information.
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_GetCardInfo(SD_CardInfo *cardinfo)
+ {
+   uint8_t status = SD_RESPONSE_FAILURE;
+ 
+   status = SD_GetCSDRegister(&(cardinfo->SD_csd));
+   status = SD_GetCIDRegister(&(cardinfo->SD_cid));
+   cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
+   cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
+   cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
+   cardinfo->CardCapacity *= cardinfo->CardBlockSize;
+ 
+   /*!< Returns the response */
+   return status;
+ }
+ 
+ /**
+   * @brief  Reads a block of data from the SD.
+   * @param  pBuffer: pointer to the buffer that receives the data read from the
+   *                  SD.
+   * @param  ReadAddr: SD's internal address to read from.
+   * @param  BlockSize: the SD card Data block size.
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
+ {
+   uint32_t i = 0;
+   uint8_t rvalue = SD_RESPONSE_FAILURE;
+ 
+   /*!< SD chip select low */
+   SD_CS_LOW();
+ 
+   /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
+   SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
+ 
+   /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
+   if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
+   {
+     /*!< Now look for the data token to signify the start of the data */
+     if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
+     {
+       /*!< Read the SD block data : read NumByteToRead data */
+       for (i = 0; i < BlockSize; i++)
+       {
+         /*!< Save the received data */
+         *pBuffer = SD_ReadByte();
+ 
+         /*!< Point to the next location where the byte read will be saved */
+         pBuffer++;
+       }
+       /*!< Get CRC bytes (not really needed by us, but required by SD) */
+       SD_ReadByte();
+       SD_ReadByte();
+       /*!< Set response value to success */
+       rvalue = SD_RESPONSE_NO_ERROR;
+     }
+   }
+   /*!< SD chip select high */
+   SD_CS_HIGH();
+ 
+   /*!< Send dummy byte: 8 Clock pulses of delay */
+   SD_WriteByte(SD_DUMMY_BYTE);
+ 
+   /*!< Returns the response */
+   return rvalue;
+ 
+ }
+ 
+ /**
+   * @brief  Read a buffer (many blocks) from the SD card.
+   * @param  pBuffer : pointer to the buffer that receives the data read from the SD.
+   * @param  ReadAddr : SD's internal address to read from.
+   * @param  NumByteToRead : number of bytes to read from the SD.
+   * @retval SD Response:
+   *   - SD_RESPONSE_FAILURE: Sequence failed.
+   *   - SD_RESPONSE_NO_ERROR: Sequence succeed.
+   */
+ uint8_t SD_ReadBuffer(uint8_t *pBuffer, uint32_t ReadAddr, uint32_t NumByteToRead)
+ {
+   uint32_t i = 0, NbrOfBlock = 0, Offset = 0;
+   uint8_t rvalue = SD_RESPONSE_FAILURE;
+ 
+   /* Calculate number of blocks to read */
+   NbrOfBlock = NumByteToRead / SD_BLOCK_SIZE;
+   /* SD chip select low */
+   SD_CS_LOW();
+ 
+   /* Data transfer */
+   while (NbrOfBlock --)
+   {
+     /* Send CMD17 (SD_READ_SINGLE_BLOCK) to read one block */
+     SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
+     /* Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
+     if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
+     {
+       return  SD_RESPONSE_FAILURE;
+     }
+     /* Now look for the data token to signify the start of the data */
+     if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
+     {
+       /* Read the SD block data : read NumByteToRead data */
+       for (i = 0; i < SD_BLOCK_SIZE; i++)
+       {
+         /* Read the pointed data */
+         *pBuffer = SD_ReadByte();
+         /* Point to the next location where the byte read will be saved */
+         pBuffer++;
+       }
+       /* Set next read address*/
+       Offset += 512;
+       /* get CRC bytes (not really needed by us, but required by SD) */
+       SD_ReadByte();
+       SD_ReadByte();
+       /* Set response value to success */
+       rvalue = SD_RESPONSE_NO_ERROR;
+     }
+     else
+     {
+       /* Set response value to failure */
+       rvalue = SD_RESPONSE_FAILURE;
+     }
+   }
+ 
+   /* SD chip select high */
+   SD_CS_HIGH();
+   /* Send dummy byte: 8 Clock pulses of delay */
+   SD_WriteByte(SD_DUMMY_BYTE);
+   /* Returns the response */
+   return rvalue;
+ }
+ 
+ /**
+   * @brief  Writes a block on the SD
+   * @param  pBuffer: pointer to the buffer containing the data to be written on
+   *                  the SD.
+   * @param  WriteAddr: address to write on.
+   * @param  BlockSize: the SD card Data block size.
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
+ {
+   uint32_t i = 0;
+   uint8_t rvalue = SD_RESPONSE_FAILURE;
+ 
+   /*!< SD chip select low */
+   SD_CS_LOW();
+ 
+   /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
+   SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
+ 
+   /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
+   if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
+   {
+     /*!< Send a dummy byte */
+     SD_WriteByte(SD_DUMMY_BYTE);
+ 
+     /*!< Send the data token to signify the start of the data */
+     SD_WriteByte(0xFE);
+ 
+     /*!< Write the block data to SD : write count data by block */
+     for (i = 0; i < BlockSize; i++)
+     {
+       /*!< Send the pointed byte */
+       SD_WriteByte(*pBuffer);
+       /*!< Point to the next location where the byte read will be saved */
+       pBuffer++;
+     }
+ 
+     /* Send DUMMY bytes when the number of data to be written are lower
+        than the SD card BLOCK size (512 Byte) */
+     for (; i != SD_BLOCK_SIZE; i++)
+     {
+       /* Send the pointed byte */
+       SD_WriteByte(SD_DUMMY_BYTE);
+     }
+ 
+     /*!< Put CRC bytes (not really needed by us, but required by SD) */
+     SD_ReadByte();
+     SD_ReadByte();
+ 
+     /*!< Read data response */
+     if (SD_GetDataResponse() == SD_DATA_OK)
+     {
+       rvalue = SD_RESPONSE_NO_ERROR;
+     }
+   }
+   /*!< SD chip select high */
+   SD_CS_HIGH();
+   /*!< Send dummy byte: 8 Clock pulses of delay */
+   SD_WriteByte(SD_DUMMY_BYTE);
+ 
+   /*!< Returns the response */
+   return rvalue;
+ 
+ }
+ 
+ 
+ /**
+   * @brief  Write a buffer (many blocks) in the SD card.
+   * @note   The amount of data to write should be a multiple of SD card BLOCK
+   *         size (512 Byte).
+   * @param  pBuffer : pointer to the buffer containing the data to be written on the SD.
+   * @param  WriteAddr : address to write on.
+   * @param  NumByteToWrite : number of data to write.
+   * @retval SD Response:
+   *   - SD_RESPONSE_FAILURE: Sequence failed.
+   *   - SD_RESPONSE_NO_ERROR: Sequence succeed.
+   */
+ uint8_t SD_WriteBuffer(uint8_t *pBuffer, uint32_t WriteAddr, uint32_t NumByteToWrite)
+ {
+   uint32_t i = 0, NbrOfBlock = 0, Offset = 0;
+   uint8_t rvalue = SD_RESPONSE_FAILURE;
+ 
+   /* Calculate number of blocks to write */
+   NbrOfBlock = NumByteToWrite / SD_BLOCK_SIZE;
+   /* SD chip select low */
+   SD_CS_LOW();
+ 
+   /* Data transfer */
+   while (NbrOfBlock--)
+   {
+     /* Send CMD24 (SD_WRITE_BLOCK) to write blocks */
+     SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
+ 
+     /* Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
+     if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
+     {
+       return SD_RESPONSE_FAILURE;
+     }
+     /* Send dummy byte */
+     SD_WriteByte(SD_DUMMY_BYTE);
+     /* Send the data token to signify the start of the data */
+     SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
+     /* Write the block data to SD : write count data by block */
+     for (i = 0; i < SD_BLOCK_SIZE; i++)
+     {
+       /* Send the pointed byte */
+       SD_WriteByte(*pBuffer);
+       /* Point to the next location where the byte read will be saved */
+       pBuffer++;
+     }
+     /* Set next write address */
+     Offset += 512;
+     /* Put CRC bytes (not really needed by us, but required by SD) */
+     SD_ReadByte();
+     SD_ReadByte();
+     /* Read data response */
+     if (SD_GetDataResponse() == SD_DATA_OK)
+     {
+       /* Set response value to success */
+       rvalue = SD_RESPONSE_NO_ERROR;
+     }
+     else
+     {
+       /* Set response value to failure */
+       rvalue = SD_RESPONSE_FAILURE;
+     }
+   }
+ 
+   /* SD chip select high */
+   SD_CS_HIGH();
+   /* Send dummy byte: 8 Clock pulses of delay */
+   SD_WriteByte(SD_DUMMY_BYTE);
+   /* Returns the response */
+   return rvalue;
+ }
+ 
+ /**
+   * @brief  Read the CSD card register.
+   *         Reading the contents of the CSD register in SPI mode is a simple
+   *         read-block transaction.
+   * @param  SD_csd: pointer on an SCD register structure
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_GetCSDRegister(SD_CSD* SD_csd)
+ {
+   uint32_t i = 0;
+   uint8_t rvalue = SD_RESPONSE_FAILURE;
+   uint8_t CSD_Tab[16];
+ 
+   /*!< SD chip select low */
+   SD_CS_LOW();
+   /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
+   SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
+   /*!< Wait for response in the R1 format (0x00 is no errors) */
+   if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
+   {
+     if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
+     {
+       for (i = 0; i < 16; i++)
+       {
+         /*!< Store CSD register value on CSD_Tab */
+         CSD_Tab[i] = SD_ReadByte();
+       }
+     }
+     /*!< Get CRC bytes (not really needed by us, but required by SD) */
+     SD_WriteByte(SD_DUMMY_BYTE);
+     SD_WriteByte(SD_DUMMY_BYTE);
+     /*!< Set response value to success */
+     rvalue = SD_RESPONSE_NO_ERROR;
+   }
+   /*!< SD chip select high */
+   SD_CS_HIGH();
+   /*!< Send dummy byte: 8 Clock pulses of delay */
+   SD_WriteByte(SD_DUMMY_BYTE);
+ 
+   /*!< Byte 0 */
+   SD_csd->CSDStruct = (uint8_t)((CSD_Tab[0] & 0xC0) >> 6);
+   SD_csd->SysSpecVersion = (uint8_t)((CSD_Tab[0] & 0x3C) >> 2);
+   SD_csd->Reserved1 = (uint8_t)(CSD_Tab[0] & 0x03);
+ 
+   /*!< Byte 1 */
+   SD_csd->TAAC = CSD_Tab[1];
+ 
+   /*!< Byte 2 */
+   SD_csd->NSAC = CSD_Tab[2];
+ 
+   /*!< Byte 3 */
+   SD_csd->MaxBusClkFrec = CSD_Tab[3];
+ 
+   /*!< Byte 4 */
+   SD_csd->CardComdClasses = CSD_Tab[4] << 4;
+ 
+   /*!< Byte 5 */
+   SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
+   SD_csd->RdBlockLen = (uint8_t)(CSD_Tab[5] & 0x0F);
+ 
+   /*!< Byte 6 */
+   SD_csd->PartBlockRead = (uint8_t)((CSD_Tab[6] & 0x80) >> 7);
+   SD_csd->WrBlockMisalign = (uint8_t)((CSD_Tab[6] & 0x40) >> 6);
+   SD_csd->RdBlockMisalign = (uint8_t)((CSD_Tab[6] & 0x20) >> 5);
+   SD_csd->DSRImpl = (uint8_t)((CSD_Tab[6] & 0x10) >> 4);
+   SD_csd->Reserved2 = 0; /*!< Reserved */
+ 
+   SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
+ 
+   /*!< Byte 7 */
+   SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
+ 
+   /*!< Byte 8 */
+   SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
+ 
+   SD_csd->MaxRdCurrentVDDMin = (uint8_t)((CSD_Tab[8] & 0x38) >> 3);
+   SD_csd->MaxRdCurrentVDDMax = (uint8_t)((CSD_Tab[8] & 0x07));
+ 
+   /*!< Byte 9 */
+   SD_csd->MaxWrCurrentVDDMin = (uint8_t)((CSD_Tab[9] & 0xE0) >> 5);
+   SD_csd->MaxWrCurrentVDDMax = (uint8_t)((CSD_Tab[9] & 0x1C) >> 2);
+   SD_csd->DeviceSizeMul = (uint8_t)((CSD_Tab[9] & 0x03) << 1);
+   /*!< Byte 10 */
+   SD_csd->DeviceSizeMul |= (uint8_t)((CSD_Tab[10] & 0x80) >> 7);
+ 
+   SD_csd->EraseGrSize = (uint8_t)((CSD_Tab[10] & 0x40) >> 6);
+   SD_csd->EraseGrMul = (uint8_t)((CSD_Tab[10] & 0x3F) << 1);
+ 
+   /*!< Byte 11 */
+   SD_csd->EraseGrMul |= (uint8_t)((CSD_Tab[11] & 0x80) >> 7);
+   SD_csd->WrProtectGrSize = (uint8_t)((CSD_Tab[11] & 0x7F));
+ 
+   /*!< Byte 12 */
+   SD_csd->WrProtectGrEnable = (uint8_t)((CSD_Tab[12] & 0x80) >> 7);
+   SD_csd->ManDeflECC = (uint8_t)((CSD_Tab[12] & 0x60) >> 5);
+   SD_csd->WrSpeedFact = (uint8_t)((CSD_Tab[12] & 0x1C) >> 2);
+   SD_csd->MaxWrBlockLen = (uint8_t)((CSD_Tab[12] & 0x03) << 2);
+ 
+   /*!< Byte 13 */
+   SD_csd->MaxWrBlockLen |= (uint8_t)((CSD_Tab[13] & 0xC0) >> 6);
+   SD_csd->WriteBlockPaPartial = (uint8_t)((CSD_Tab[13] & 0x20) >> 5);
+   SD_csd->Reserved3 = 0;
+   SD_csd->ContentProtectAppli = (uint8_t)(CSD_Tab[13] & 0x01);
+ 
+   /*!< Byte 14 */
+   SD_csd->FileFormatGroup = (uint8_t)((CSD_Tab[14] & 0x80) >> 7);
+   SD_csd->CopyFlag = (uint8_t)((CSD_Tab[14] & 0x40) >> 6);
+   SD_csd->PermWrProtect = (uint8_t)((CSD_Tab[14] & 0x20) >> 5);
+   SD_csd->TempWrProtect = (uint8_t)((CSD_Tab[14] & 0x10) >> 4);
+   SD_csd->FileFormat = (uint8_t)((CSD_Tab[14] & 0x0C) >> 2);
+   SD_csd->ECC = (uint8_t)(CSD_Tab[14] & 0x03);
+ 
+   /*!< Byte 15 */
+   SD_csd->CSD_CRC = (uint8_t)((CSD_Tab[15] & 0xFE) >> 1);
+   SD_csd->Reserved4 = 1;
+ 
+   /*!< Return the response */
+   return rvalue;
+ }
+ 
+ /**
+   * @brief  Read the CID card register.
+   *         Reading the contents of the CID register in SPI mode is a simple
+   *         read-block transaction.
+   * @param  SD_cid: pointer on an CID register structure
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_GetCIDRegister(SD_CID* SD_cid)
+ {
+   uint32_t i = 0;
+   uint8_t rvalue = SD_RESPONSE_FAILURE;
+   uint8_t CID_Tab[16];
+ 
+   /*!< SD chip select low */
+   SD_CS_LOW();
+ 
+   /*!< Send CMD10 (CID register) */
+   SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
+ 
+   /*!< Wait for response in the R1 format (0x00 is no errors) */
+   if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
+   {
+     if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
+     {
+       /*!< Store CID register value on CID_Tab */
+       for (i = 0; i < 16; i++)
+       {
+         CID_Tab[i] = SD_ReadByte();
+       }
+     }
+     /*!< Get CRC bytes (not really needed by us, but required by SD) */
+     SD_WriteByte(SD_DUMMY_BYTE);
+     SD_WriteByte(SD_DUMMY_BYTE);
+     /*!< Set response value to success */
+     rvalue = SD_RESPONSE_NO_ERROR;
+   }
+   /*!< SD chip select high */
+   SD_CS_HIGH();
+   /*!< Send dummy byte: 8 Clock pulses of delay */
+   SD_WriteByte(SD_DUMMY_BYTE);
+ 
+   /*!< Byte 0 */
+   SD_cid->ManufacturerID = CID_Tab[0];
+ 
+   /*!< Byte 1 */
+   SD_cid->OEM_AppliID = CID_Tab[1] << 8;
+ 
+   /*!< Byte 2 */
+   SD_cid->OEM_AppliID |= CID_Tab[2];
+ 
+   /*!< Byte 3 */
+   SD_cid->ProdName1 = ((uint32_t)CID_Tab[3] << 24);
+ 
+   /*!< Byte 4 */
+   SD_cid->ProdName1 |= ((uint32_t)CID_Tab[4] << 16);
+ 
+   /*!< Byte 5 */
+   SD_cid->ProdName1 |= CID_Tab[5] << 8;
+ 
+   /*!< Byte 6 */
+   SD_cid->ProdName1 |= CID_Tab[6];
+ 
+   /*!< Byte 7 */
+   SD_cid->ProdName2 = CID_Tab[7];
+ 
+   /*!< Byte 8 */
+   SD_cid->ProdRev = CID_Tab[8];
+ 
+   /*!< Byte 9 */
+   SD_cid->ProdSN = ((uint32_t)CID_Tab[9] << 24);
+ 
+   /*!< Byte 10 */
+   SD_cid->ProdSN |= ((uint32_t)CID_Tab[10] << 16);
+ 
+   /*!< Byte 11 */
+   SD_cid->ProdSN |= CID_Tab[11] << 8;
+ 
+   /*!< Byte 12 */
+   SD_cid->ProdSN |= CID_Tab[12];
+ 
+   /*!< Byte 13 */
+   SD_cid->Reserved1 |= (uint8_t)((CID_Tab[13] & 0xF0) >> 4);
+   SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
+ 
+   /*!< Byte 14 */
+   SD_cid->ManufactDate |= CID_Tab[14];
+ 
+   /*!< Byte 15 */
+   SD_cid->CID_CRC = (uint8_t)((CID_Tab[15] & 0xFE) >> 1);
+   SD_cid->Reserved2 = 1;
+ 
+   /*!< Return the response */
+   return rvalue;
+ }
+ 
+ /**
+   * @brief  Send 5 bytes command to the SD card.
+   * @param  Cmd: The user expected command to send to SD card.
+   * @param  Arg: The command argument.
+   * @param  Crc: The CRC.
+   * @retval None
+   */
+ void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
+ {
+   uint32_t i = 0x00;
+ 
+   uint8_t Frame[6];
+ 
+   Frame[0] = (uint8_t)(Cmd | 0x40); /*!< Construct byte 1 */
+ 
+   Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
+ 
+   Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
+ 
+   Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
+ 
+   Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
+ 
+   Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
+ 
+   for (i = 0; i < 6; i++)
+   {
+     SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
+   }
+ }
+ 
+ /**
+   * @brief  Get SD card data response.
+   * @param  None
+   * @retval The SD status: Read data response xxx0<status>1
+   *         - status 010: Data accepted
+   *         - status 101: Data rejected due to a crc error
+   *         - status 110: Data rejected due to a Write error.
+   *         - status 111: Data rejected due to other error.
+   */
+ uint8_t SD_GetDataResponse(void)
+ {
+   uint32_t i = 0;
+   uint8_t response = 0, rvalue = 0;
+ 
+   while (i <= 64)
+   {
+     /*!< Read response */
+     response = SD_ReadByte();
+     /*!< Mask unused bits */
+     response &= 0x1F;
+     switch (response)
+     {
+       case SD_DATA_OK:
+       {
+         rvalue = SD_DATA_OK;
+         break;
+       }
+       case SD_DATA_CRC_ERROR:
+         return SD_DATA_CRC_ERROR;
+       case SD_DATA_WRITE_ERROR:
+         return SD_DATA_WRITE_ERROR;
+       default:
+       {
+         rvalue = SD_DATA_OTHER_ERROR;
+         break;
+       }
+     }
+     /*!< Exit loop in case of data ok */
+     if (rvalue == SD_DATA_OK)
+       break;
+     /*!< Increment loop counter */
+     i++;
+   }
+ 
+   /*!< Wait null data */
+   while (SD_ReadByte() == 0);
+ 
+   /*!< Return response */
+   return response;
+ }
+ 
+ /**
+   * @brief  Returns the SD response.
+   * @param  None
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_GetResponse(uint8_t Response)
+ {
+   uint32_t Count = 0xFFF;
+ 
+   /*!< Check if response is got or a timeout is happen */
+   while ((SD_ReadByte() != Response) && Count)
+   {
+     Count--;
+   }
+   if (Count == 0)
+   {
+     /*!< After time out */
+     return SD_RESPONSE_FAILURE;
+   }
+   else
+   {
+     /*!< Right response got */
+     return SD_RESPONSE_NO_ERROR;
+   }
+ }
+ 
+ /**
+   * @brief  Returns the SD status.
+   * @param  None
+   * @retval The SD status.
+   */
+ uint16_t SD_GetStatus(void)
+ {
+   uint16_t Status = 0;
+ 
+   /*!< SD chip select low */
+   SD_CS_LOW();
+ 
+   /*!< Send CMD13 (SD_SEND_STATUS) to get SD status */
+   SD_SendCmd(SD_CMD_SEND_STATUS, 0, 0xFF);
+ 
+   Status = SD_ReadByte();
+   Status |= (uint16_t)(SD_ReadByte() << 8);
+ 
+   /*!< SD chip select high */
+   SD_CS_HIGH();
+ 
+   /*!< Send dummy byte 0xFF */
+   SD_WriteByte(SD_DUMMY_BYTE);
+ 
+   return Status;
+ }
+ 
+ /**
+   * @brief  Put SD in Idle state.
+   * @param  None
+   * @retval The SD Response:
+   *         - SD_RESPONSE_FAILURE: Sequence failed
+   *         - SD_RESPONSE_NO_ERROR: Sequence succeed
+   */
+ uint8_t SD_GoIdleState(void)
+ {
+   /*!< SD chip select low */
+   SD_CS_LOW();
+ 
+   /*!< Send CMD0 (SD_CMD_GO_IDLE_STATE) to put SD in SPI mode */
+   SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
+ 
+   /*!< Wait for In Idle State Response (R1 Format) equal to 0x01 */
+   if (SD_GetResponse(SD_IN_IDLE_STATE))
+   {
+     /*!< No Idle State Response: return response failure */
+     return SD_RESPONSE_FAILURE;
+   }
+   /*----------Activates the card initialization process-----------*/
+   do
+   {
+     /*!< SD chip select high */
+     SD_CS_HIGH();
+ 
+     /*!< Send Dummy byte 0xFF */
+     SD_WriteByte(SD_DUMMY_BYTE);
+ 
+     /*!< SD chip select low */
+     SD_CS_LOW();
+ 
+     /*!< Send CMD1 (Activates the card process) until response equal to 0x0 */
+     SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
+     /*!< Wait for no error Response (R1 Format) equal to 0x00 */
+   }
+   while (SD_GetResponse(SD_RESPONSE_NO_ERROR));
+ 
+   /*!< SD chip select high */
+   SD_CS_HIGH();
+ 
+   /*!< Send dummy byte 0xFF */
+   SD_WriteByte(SD_DUMMY_BYTE);
+ 
+   return SD_RESPONSE_NO_ERROR;
+ }
+ 
+ /**
+   * @brief  Write a byte on the SD.
+   * @param  Data: byte to send.
+   * @retval None
+   */
+ uint8_t SD_WriteByte(uint8_t Data)
+ {
+   /*!< Wait until the transmit buffer is empty */
+   while (SPI_GetFlagStatus(SPI_FLAG_TXE) == RESET)
+   {}
+ 
+   /*!< Send the byte */
+   SPI_SendData(Data);
+ 
+   /*!< Wait to receive a byte*/
+   while (SPI_GetFlagStatus(SPI_FLAG_RXNE) == RESET)
+   {}
+ 
+   /*!< Return the byte read from the SPI bus */
+   return SPI_ReceiveData();
+ }
+ 
+ /**
+   * @brief  Read a byte from the SD.
+   * @param  None
+   * @retval The received byte.
+   */
+ uint8_t SD_ReadByte(void)
+ {
+   uint8_t Data = 0;
+ 
+   /*!< Wait until the transmit buffer is empty */
+   while (SPI_GetFlagStatus(SPI_FLAG_TXE) == RESET)
+   {}
+   /*!< Send the byte */
+   SPI_SendData(SD_DUMMY_BYTE);
+ 
+   /*!< Wait until a data is received */
+   while (SPI_GetFlagStatus(SPI_FLAG_RXNE) == RESET)
+   {}
+   /*!< Get the received data */
+   Data = SPI_ReceiveData();
+ 
+   /*!< Return the shifted data */
+   return Data;
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Common/stm8l_eval_spi_sd.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,275 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l_eval_spi_sd.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains all the functions prototypes for the stm8_eval_spi_sd
+   *          firmware driver.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L101_EVAL_SPI_SD_H
+ #define __STM8L101_EVAL_SPI_SD_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l101_eval.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+   
+ /** @addtogroup STM8L101_EVAL
+   * @{
+   */ 
+ 
+ /** @addtogroup Common
+   * @{
+   */
+   
+ /** @addtogroup STM8L101_EVAL_SPI_SD
+   * @{
+   */  
+ 
+ /** @defgroup STM8L101_EVAL_SPI_SD_Exported_Types
+   * @{
+   */ 
+ 
+ /** 
+   * @brief  Card Specific Data: CSD Register   
+   */ 
+ typedef struct
+ {
+   __IO uint8_t  CSDStruct;            /*!< CSD structure */
+   __IO uint8_t  SysSpecVersion;       /*!< System specification version */
+   __IO uint8_t  Reserved1;            /*!< Reserved */
+   __IO uint8_t  TAAC;                 /*!< Data read access-time 1 */
+   __IO uint8_t  NSAC;                 /*!< Data read access-time 2 in CLK cycles */
+   __IO uint8_t  MaxBusClkFrec;        /*!< Max. bus clock frequency */
+   __IO uint16_t CardComdClasses;      /*!< Card command classes */
+   __IO uint8_t  RdBlockLen;           /*!< Max. read data block length */
+   __IO uint8_t  PartBlockRead;        /*!< Partial blocks for read allowed */
+   __IO uint8_t  WrBlockMisalign;      /*!< Write block misalignment */
+   __IO uint8_t  RdBlockMisalign;      /*!< Read block misalignment */
+   __IO uint8_t  DSRImpl;              /*!< DSR implemented */
+   __IO uint8_t  Reserved2;            /*!< Reserved */
+   __IO uint32_t DeviceSize;           /*!< Device Size */
+   __IO uint8_t  MaxRdCurrentVDDMin;   /*!< Max. read current @ VDD min */
+   __IO uint8_t  MaxRdCurrentVDDMax;   /*!< Max. read current @ VDD max */
+   __IO uint8_t  MaxWrCurrentVDDMin;   /*!< Max. write current @ VDD min */
+   __IO uint8_t  MaxWrCurrentVDDMax;   /*!< Max. write current @ VDD max */
+   __IO uint8_t  DeviceSizeMul;        /*!< Device size multiplier */
+   __IO uint8_t  EraseGrSize;          /*!< Erase group size */
+   __IO uint8_t  EraseGrMul;           /*!< Erase group size multiplier */
+   __IO uint8_t  WrProtectGrSize;      /*!< Write protect group size */
+   __IO uint8_t  WrProtectGrEnable;    /*!< Write protect group enable */
+   __IO uint8_t  ManDeflECC;           /*!< Manufacturer default ECC */
+   __IO uint8_t  WrSpeedFact;          /*!< Write speed factor */
+   __IO uint8_t  MaxWrBlockLen;        /*!< Max. write data block length */
+   __IO uint8_t  WriteBlockPaPartial;  /*!< Partial blocks for write allowed */
+   __IO uint8_t  Reserved3;            /*!< Reserved */
+   __IO uint8_t  ContentProtectAppli;  /*!< Content protection application */
+   __IO uint8_t  FileFormatGroup;     /*!< File format group */
+   __IO uint8_t  CopyFlag;             /*!< Copy flag (OTP) */
+   __IO uint8_t  PermWrProtect;        /*!< Permanent write protection */
+   __IO uint8_t  TempWrProtect;        /*!< Temporary write protection */
+   __IO uint8_t  FileFormat;           /*!< File Format */
+   __IO uint8_t  ECC;                  /*!< ECC code */
+   __IO uint8_t  CSD_CRC;              /*!< CSD CRC */
+   __IO uint8_t  Reserved4;            /*!< always 1*/
+ } SD_CSD;
+ 
+ /** 
+   * @brief  Card Identification Data: CID Register   
+   */
+ typedef struct
+ {
+   __IO uint8_t  ManufacturerID;       /*!< ManufacturerID */
+   __IO uint16_t OEM_AppliID;          /*!< OEM/Application ID */
+   __IO uint32_t ProdName1;            /*!< Product Name part1 */
+   __IO uint8_t  ProdName2;            /*!< Product Name part2*/
+   __IO uint8_t  ProdRev;              /*!< Product Revision */
+   __IO uint32_t ProdSN;               /*!< Product Serial Number */
+   __IO uint8_t  Reserved1;            /*!< Reserved1 */
+   __IO uint16_t ManufactDate;         /*!< Manufacturing Date */
+   __IO uint8_t  CID_CRC;              /*!< CID CRC */
+   __IO uint8_t  Reserved2;            /*!< always 1 */
+ } SD_CID;
+ 
+ /** 
+   * @brief SD Card information 
+   */
+ typedef struct
+ {
+   SD_CSD SD_csd;
+   SD_CID SD_cid;
+   uint32_t CardCapacity;  /*!< Card Capacity */
+   uint32_t CardBlockSize; /*!< Card Block Size */
+ } SD_CardInfo;
+ 
+ /**
+   * @}
+   */
+   
+ /** @defgroup STM8L101_EVAL_SPI_SD_Exported_Constants
+   * @{
+   */ 
+ 
+ /**
+   * @brief  SD reponses and error flags
+   */
+ #define  SD_RESPONSE_NO_ERROR         0x00
+ #define  SD_IN_IDLE_STATE             0x01
+ #define  SD_ERASE_RESET               0x02
+ #define  SD_ILLEGAL_COMMAND           0x04
+ #define  SD_COM_CRC_ERROR             0x08
+ #define  SD_ERASE_SEQUENCE_ERROR      0x10
+ #define  SD_ADDRESS_ERROR             0x20
+ #define  SD_PARAMETER_ERROR           0x40
+ #define  SD_RESPONSE_FAILURE          0xFF
+ 
+ /**
+   * @brief  Data response error
+   */
+ #define  SD_DATA_OK                   0x05
+ #define  SD_DATA_CRC_ERROR            0x0B
+ #define  SD_DATA_WRITE_ERROR          0x0D
+ #define  SD_DATA_OTHER_ERROR          0xFF
+     
+ /**
+   * @brief  Block Size
+   */
+ #define SD_BLOCK_SIZE    0x200
+ 
+ /**
+   * @brief  Dummy byte
+   */
+ #define SD_DUMMY_BYTE   0xFF
+ 
+ /**
+   * @brief  Start Data tokens:
+   *         Tokens (necessary because at nop/idle (and CS active) only 0xff is 
+   *         on the data/command line)  
+   */
+ #define SD_START_DATA_SINGLE_BLOCK_READ    0xFE  /*!< Data token start byte, Start Single Block Read */
+ #define SD_START_DATA_MULTIPLE_BLOCK_READ  0xFE  /*!< Data token start byte, Start Multiple Block Read */
+ #define SD_START_DATA_SINGLE_BLOCK_WRITE   0xFE  /*!< Data token start byte, Start Single Block Write */
+ #define SD_START_DATA_MULTIPLE_BLOCK_WRITE 0xFD  /*!< Data token start byte, Start Multiple Block Write */
+ #define SD_STOP_DATA_MULTIPLE_BLOCK_WRITE  0xFD  /*!< Data toke stop byte, Stop Multiple Block Write */
+ 
+ /**
+   * @brief  SD detection on its memory slot
+   */
+ #define SD_PRESENT        ((uint8_t)0x01)
+ #define SD_NOT_PRESENT    ((uint8_t)0x00)
+ 
+ 
+ /**
+   * @brief  Commands: CMDxx = CMD-number | 0x40
+   */
+ #define SD_CMD_GO_IDLE_STATE          0   /*!< CMD0 = 0x40 */
+ #define SD_CMD_SEND_OP_COND           1   /*!< CMD1 = 0x41 */
+ #define SD_CMD_SEND_CSD               9   /*!< CMD9 = 0x49 */
+ #define SD_CMD_SEND_CID               10  /*!< CMD10 = 0x4A */
+ #define SD_CMD_STOP_TRANSMISSION      12  /*!< CMD12 = 0x4C */
+ #define SD_CMD_SEND_STATUS            13  /*!< CMD13 = 0x4D */
+ #define SD_CMD_SET_BLOCKLEN           16  /*!< CMD16 = 0x50 */
+ #define SD_CMD_READ_SINGLE_BLOCK      17  /*!< CMD17 = 0x51 */
+ #define SD_CMD_READ_MULT_BLOCK        18  /*!< CMD18 = 0x52 */
+ #define SD_CMD_SET_BLOCK_COUNT        23  /*!< CMD23 = 0x57 */
+ #define SD_CMD_WRITE_SINGLE_BLOCK     24  /*!< CMD24 = 0x58 */
+ #define SD_CMD_WRITE_MULT_BLOCK       25  /*!< CMD25 = 0x59 */
+ #define SD_CMD_PROG_CSD               27  /*!< CMD27 = 0x5B */
+ #define SD_CMD_SET_WRITE_PROT         28  /*!< CMD28 = 0x5C */
+ #define SD_CMD_CLR_WRITE_PROT         29  /*!< CMD29 = 0x5D */
+ #define SD_CMD_SEND_WRITE_PROT        30  /*!< CMD30 = 0x5E */
+ #define SD_CMD_SD_ERASE_GRP_START     32  /*!< CMD32 = 0x60 */
+ #define SD_CMD_SD_ERASE_GRP_END       33  /*!< CMD33 = 0x61 */
+ #define SD_CMD_UNTAG_SECTOR           34  /*!< CMD34 = 0x62 */
+ #define SD_CMD_ERASE_GRP_START        35  /*!< CMD35 = 0x63 */
+ #define SD_CMD_ERASE_GRP_END          36  /*!< CMD36 = 0x64 */
+ #define SD_CMD_UNTAG_ERASE_GROUP      37  /*!< CMD37 = 0x65 */
+ #define SD_CMD_ERASE                  38  /*!< CMD38 = 0x66 */
+ 
+ /**
+   * @}
+   */ 
+   
+ /** @defgroup STM8L101_EVAL_SPI_SD_Exported_Macros
+   * @{
+   */
+ /** 
+   * @brief  Select SD Card: ChipSelect pin low   
+   */  
+ #define SD_CS_LOW()     GPIO_SetBits(SD_CS_GPIO_PORT, SD_CS_PIN)
+ /** 
+   * @brief  Deselect SD Card: ChipSelect pin high   
+   */ 
+ #define SD_CS_HIGH()    GPIO_ResetBits(SD_CS_GPIO_PORT, SD_CS_PIN)
+ /**
+   * @}
+   */ 
+ 
+ /** @defgroup STM8L101_EVAL_SPI_SD_Exported_Functions
+   * @{
+   */ 
+ void SD_DeInit(void);  
+ uint8_t SD_Init(void);
+ uint8_t SD_GetCardInfo(SD_CardInfo *cardinfo);
+ uint8_t SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize);
+ uint8_t SD_ReadBuffer(uint8_t *pBuffer, uint32_t ReadAddr, uint32_t NumByteToRead);
+ uint8_t SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize);
+ uint8_t SD_WriteBuffer(uint8_t *pBuffer, uint32_t WriteAddr, uint32_t NumByteToWrite);
+ uint8_t SD_GetCSDRegister(SD_CSD* SD_csd);
+ uint8_t SD_GetCIDRegister(SD_CID* SD_cid);
+ 
+ void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc);
+ uint8_t SD_GetResponse(uint8_t Response);
+ uint8_t SD_GetDataResponse(void);
+ uint8_t SD_GoIdleState(void);
+ uint16_t SD_GetStatus(void);
+ 
+ uint8_t SD_WriteByte(uint8_t byte);
+ uint8_t SD_ReadByte(void);
+ 
+ 
+ #endif /* __STM8L101_EVAL_SPI_SD_H */
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */ 
+ 
+ /**
+   * @}
+   */    
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Release_Notes.html ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Release_Notes.html
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/Release_Notes.html	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/Release_Notes.html	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,186 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+ <html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>
+ 
+ 
+ 
+ 
+ 
+ 
+   
+   <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
+ 
+   
+   <link rel="File-List" href="Library_files/filelist.xml">
+ 
+   
+   <link rel="Edit-Time-Data" href="Library_files/editdata.mso"><!--[if !mso]> <style> v\:* {behavior:url(#default#VML);} o\:* {behavior:url(#default#VML);} w\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);} </style> <![endif]--><title>STM8L10x Standard Peripherals Library Utilities release note</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>STMicroelectronics</o:Author> <o:LastAuthor>STMicroelectronics</o:LastAuthor> <o:Revision>37</o:Revision> <o:TotalTime>136</o:TotalTime> <o:Created>2009-02-27T19:26:00Z</o:Created> <o:LastSaved>2009-03-01T17:56:00Z</o:LastSaved> <o:Pages>1</o:Pages> <o:Words>522</o:Words> <o:Characters>2977</o:Characters> <o:Company>STMicroelectronics</o:Company> <o:Lines>24</o:Lines> <o:Paragraphs>6</o:Paragraphs> <o:CharactersWithSpaces>3493</o:CharactersWithSpaces> <o:Version>11.6568</o:Version> </o:DocumentProperties> </xml><![endif]--><!--[if gte mso 9]><xml> <w:WordDocument> <w:Zoom>110</w:Zoom> <w:ValidateAgainstSchemas/> <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid> <w:IgnoreMixedContent>false</w:IgnoreMixedContent> <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText> <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel> </w:WordDocument> </xml><![endif]--><!--[if gte mso 9]><xml> <w:LatentStyles DefLockedState="false" LatentStyleCount="156"> </w:LatentStyles> </xml><![endif]-->
+ 
+ 
+   
+ 
+   
+ 
+   
+   <style>
+ <!--
+ /* Style Definitions */
+ p.MsoNormal, li.MsoNormal, div.MsoNormal
+ {mso-style-parent:"";
+ margin:0in;
+ margin-bottom:.0001pt;
+ mso-pagination:widow-orphan;
+ font-size:12.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"Times New Roman";}
+ h2
+ {mso-style-next:Normal;
+ margin-top:12.0pt;
+ margin-right:0in;
+ margin-bottom:3.0pt;
+ margin-left:0in;
+ mso-pagination:widow-orphan;
+ page-break-after:avoid;
+ mso-outline-level:2;
+ font-size:14.0pt;
+ font-family:Arial;
+ font-weight:bold;
+ font-style:italic;}
+ a:link, span.MsoHyperlink
+ {color:blue;
+ text-decoration:underline;
+ text-underline:single;}
+ a:visited, span.MsoHyperlinkFollowed
+ {color:blue;
+ text-decoration:underline;
+ text-underline:single;}
+ p
+ {mso-margin-top-alt:auto;
+ margin-right:0in;
+ mso-margin-bottom-alt:auto;
+ margin-left:0in;
+ mso-pagination:widow-orphan;
+ font-size:12.0pt;
+ font-family:"Times New Roman";
+ mso-fareast-font-family:"Times New Roman";}
+ @page Section1
+ {size:8.5in 11.0in;
+ margin:1.0in 1.25in 1.0in 1.25in;
+ mso-header-margin:.5in;
+ mso-footer-margin:.5in;
+ mso-paper-source:0;}
+ div.Section1
+ {page:Section1;}
+ -->
+   </style><!--[if gte mso 10]> <style> /* Style Definitions */ table.MsoNormalTable {mso-style-name:"Table Normal"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-parent:""; mso-padding-alt:0in 5.4pt 0in 5.4pt; mso-para-margin:0in; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:"Times New Roman"; mso-ansi-language:#0400; mso-fareast-language:#0400; mso-bidi-language:#0400;} </style> <![endif]--><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="5122"/> </xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]-->
+   <meta content="MCD Application Team" name="author"></head>
+ <body link="blue" vlink="blue">
+ <div class="Section1">
+ <p class="MsoNormal"><span style="font-family: Arial;"><o:p><br>
+ </o:p></span></p>
+ <div align="center">
+ <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+   <tbody>
+     <tr>
+       <td style="padding: 0cm;" valign="top">
+       <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" cellspacing="0" width="900">
+         <tbody>
+           <tr>
+             <td style="vertical-align: top;">
+             <p class="MsoNormal"><span style="font-size: 8pt; font-family: Arial; color: blue;"><a href="../../Release_Notes.html">Back to Release page</a><o:p></o:p></span></p>
+             </td>
+           </tr>
+           <tr style="">
+             <td style="padding: 1.5pt;">
+             <h1 style="margin-bottom: 18pt; text-align: center;" align="center"><span style="font-size: 20pt; font-family: Verdana; color: rgb(51, 102, 255);">Release
+ Notes for STM8L10x Standard Peripherals Library Utilities (Utilities)</span><span style="font-size: 20pt; font-family: Verdana;"><o:p></o:p></span></h1>
+             <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;">Copyright
+ 2014 STMicroelectronics</span><span style="color: black;"><u1:p></u1:p><o:p></o:p></span></p>
+             <p class="MsoNormal" style="text-align: center;" align="center"><span style="font-size: 10pt; font-family: Arial; color: black;"><img alt="" id="_x0000_i1025" src="../../_htmresc/st_logo.png" style="border: 0px solid ; width: 86px; height: 65px;"></span><span style="font-size: 10pt;"><o:p></o:p></span></p>
+             </td>
+           </tr>
+         </tbody>
+       </table>
+       <p class="MsoNormal"><span style="font-family: Arial; display: none;"><o:p>&nbsp;</o:p></span></p>
+       <table class="MsoNormalTable" style="width: 675pt;" border="0" cellpadding="0" width="900">
+         <tbody>
+           <tr style="">
+             <td style="padding: 0cm;" valign="top">
+             <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><span style="font-size: 12pt; color: white;">Contents<o:p></o:p></span></h2>
+             <ol style="margin-top: 0cm;" start="1" type="1">
+               <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#History">STM8L10x Standard Peripherals Library Utilities
+ update History</a><o:p></o:p></span></li>
+               <li class="MsoNormal" style="color: black; margin-top: 4.5pt; margin-bottom: 4.5pt;"><span style="font-size: 10pt; font-family: Verdana;"><a href="#License">License</a><o:p></o:p></span></li>
+             </ol>
+             <span style="font-family: &quot;Times New Roman&quot;;">
+             </span>
+             <h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="History"></a><span style="font-size: 12pt; color: white;">STM8L10x
+ Standard
+ Peripherals Library Utilities update History</span></h2>
+             <h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 500pt; width: 199px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.2.1 / 30-September-2014<o:p></o:p></span></h3>
+             <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+ Changes<o:p></o:p></span></u></b></p>
+ 
+             <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;">Fix&nbsp;Typo in driver comments</span></li></ul><b style=""><u></u></b><h3 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; margin-right: 500pt; width: 167px;"><span style="font-size: 10pt; font-family: Arial; color: white;">V1.2.0 / 01-June-2012<o:p></o:p></span></h3>
+             <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt;"><b style=""><u><span style="font-size: 10pt; font-family: Verdana; color: black;">Main
+ Changes<o:p></o:p></span></u></b></p>
+ 
+             <ul style="margin-top: 0cm;" type="square"><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">&nbsp;Rename "STM8L1x-EVAL" folder to "STM8L101-EVAL"</span></li><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;"> Add a new subfolder Common containing&nbsp; new and updated&nbsp; eval board drivers: 
+ stm8l_eval_i2c_ee.h/.c,</span><span style="font-size: 10pt; font-family: Verdana;">&nbsp;</span><span style="font-size: 10pt; font-family: Verdana;"></span><span style="font-size: 10pt; font-family: Verdana;">stm8l_eval_spi_sd.h/.c 
+ and </span><span style="font-size: 10pt; font-family: Verdana;">stm8l_eval_lcd.h/.c.</span> <span style="font-size: 10pt; font-family: Verdana;"><br><b>Note : </b><i>All
+ theses common drivers names and API were modified versus the previous
+ drivers available in version 1.1.0, no compatibility is guaranteed
+ between the two versions</i></span></li><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">Add new driver for the 
+ STM8L101-EVAL managing Leds, push button, COM ports and configuring the system 
+ level of the I2C EEPROM, SPI SD and 
+ LCD.</span></li><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">Mono LCD 
+ driver updated as follow: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size: 10pt; font-family: Verdana;">- The LCD_SetTextMode() and 
+ LCD_SetGraphicMode() functions removed as the graphic mode is not supported 
+ </span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size: 10pt; font-family: Verdana;">- The 
+ following functions are removed and are replaced by "LCD _Print ()" function : 
+ <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_ClearLine(uint8_t Line);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void 
+ LCD_PrintChar(uint8_t Ascii);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintString(uint8_t Line, 
+ FunctionalState AutoComplete, FunctionalState Append, uint8_t 
+ *ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintMsg(uint8_t *ptr);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void 
+ LCD_PrintDec1(uint8_t Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintDec2(uint8_t 
+ Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintDec3(uint16_t Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 
+ void LCD_PrintDec4(uint16_t Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintHex1(uint8_t 
+ Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintHex2(uint8_t Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 
+ void LCD_PrintHex3(uint16_t Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintBin2(uint8_t 
+ Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - void LCD_PrintBin4(uint8_t Number); <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 
+ void LCD_SendBuffer(uint8_t *pTxBuffer, uint8_t NumByte) ; </span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size: 10pt; font-family: Verdana;">- The LCD_DisplayCGRAM0() and 
+ LCD_DisplayCGRAM1() functions are declared as static as they are used only by 
+ the LCD_DisplayLogo() function</span></span></li><li class="MsoNormal"><span style="font-size: 10pt; font-family: Verdana;">SPI Micro SD driver updated as follow:&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 10pt; font-family: Verdana;">&nbsp; &nbsp;- microsd.c/.h files renamed to stm8l_eval_spi_sd.c/.h files</span></span></li><dl><dd>-&nbsp;<span style="font-size: 10pt; font-family: Verdana;"><span style="font-size: 10pt; font-family: Verdana;">SD_DeInit() function added</span></span><span style="font-size: 10pt; font-family: Verdana;"><span style="font-size: 10pt; font-family: Verdana;"></span></span></dd><dd><span style="font-size: 10pt; font-family: Verdana;"><span style="font-size: 10pt; font-family: Verdana;">-&nbsp;MSD_Init() function renamed to SD_Init() function<br>-&nbsp;MSD_Detect function renamed to SD_Detect<br>- New function SD_GetCardInfo() added <br>-&nbsp;MSD_ReadBlock() function renamed to SD_ReadBlock()<br>-&nbsp;MSD_ReadBuffer() function renamed to SD_ReadBuffer()<br>-&nbsp;MSD_WriteBlock() function renamed to SD_WriteBlock<br>-&nbsp;MSD_WriteBuffer() function renamed to SD_WriteBuffer<br>- New function SD_GetCSDRegister() added<br>- New function SD_GetCIDRegister() added<br>-&nbsp;MSD_SendCmd() function renamed to SD_SendCmd()<br>-&nbsp;MSD_GetDataResponse() function renamed to SD_GetDataResponse()<br>-&nbsp;MSD_GetResponse() function renamed to SD_GetResponse()<br>- New function SD_GetStatus() added</span></span></dd><dd><span style="font-size: 10pt; font-family: Verdana;"><span style="font-size: 10pt; font-family: Verdana;">-&nbsp;MSD_GoIdleState() function renamed to SD_GoIdleState()<br>-&nbsp;MSD_WriteByte() function renamed to SD_WriteByte()<br>-&nbsp;MSD_ReadByte() function renamed to SD_ReadByte()<br>- MSD_ChipSelect() function removed and replaced by two macros: SD_CS_LOW and SD_CS_HIGH<br>-&nbsp;MICROSD_PRESENT macro renamed to SD_PRESENT<br>-&nbsp;MICROSD_NOT_PRESENT macro renamed to SD_NOT_PRESENT<br>-&nbsp; MSD prefix replaced by SD in all defines</span></span></dd></dl><li><span style="font-size: 10pt; font-family: Verdana;">I2C EEPROM&nbsp;driver updated as follow:&nbsp;</span></li><dl><dt><span style="font-size: 10pt; font-family: Verdana;">&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-size: 10pt; font-family: Verdana;">&nbsp; &nbsp;- i2c_ee.c/.h files renamed to stm8l_eval_i2c_ee.c/.h files</span></span></dt><dd><font size="-1"><span style="font-family: Verdana;">-&nbsp;I2C_EE_BufferRead()
+ function renamed to sEE_ReadBuffer() and updated to implement the safe
+ procedure for I2C &nbsp; &nbsp; &nbsp;master receive mode</span><br style="font-family: Verdana;"><span style="font-family: Verdana;">- sEE_WaitEepromStandbyState() function added</span><br style="font-family: Verdana;"><span style="font-family: Verdana;">-&nbsp;I2C_EE_PageWrite() function renamed to sEE_WritePage() and updated to poll on BTF Flag</span><br style="font-family: Verdana;"><span style="font-family: Verdana;">-&nbsp;sEE_WriteBuffer() function added</span><br style="font-family: Verdana;"><span style="font-family: Verdana;">- I2C_EEInit()&nbsp; function renamed to sEE_Init()</span><br style="font-family: Verdana;"><span style="font-family: Verdana;">- sEE_DeInit() function added</span><br style="font-family: Verdana;"><span style="font-family: Verdana;">- I2C_EE_ByteWrite() function removed</span></font></dd></dl></ul><h2 style="background: rgb(51, 102, 255) none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial;"><a name="License"></a><span style="font-size: 12pt; color: white;">License<o:p></o:p></span></h2><p class="MsoNormal" style="margin-right: 4cm; line-height: normal; margin-left: 0.85cm; text-align: left; font-family: Arial;"><span style="font-size: 10pt; color: black;">Licensed under MCD-ST Liberty SW License Agreement V2, (the "License").
+ You may not use this file except in compliance with the License.
+ You may obtain a copy of the License at:
+ 
+ 
+ </span></p>
+ <dl style="text-align: center; font-family: Arial;"><dd><span style="font-size: 10pt;">
+ <a href="http://www.st.com/software_license_agreement_liberty_v2"> http://www.st.com/software_license_agreement_liberty_v2</a></span></dd></dl>
+ <dl><dd><span style="font-size: 10pt; color: black;"><span style="font-family: Arial;">Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.</span>
+ </span></dd></dl><b><span style="font-size: 10pt; font-family: Verdana; color: black;"></span></b>
+             
+             <div class="MsoNormal" style="text-align: center;" align="center"><span style="color: black;">
+             <hr align="center" size="2" width="100%"></span></div>
+             <p class="MsoNormal" style="margin: 4.5pt 0cm 4.5pt 18pt; text-align: center;" align="center"><span style="font-size: 10pt; font-family: Verdana; color: black;">For
+ complete documentation on </span><span style="font-size: 10pt; font-family: Verdana;">STMicroelectronics<span style="color: black;"> Microcontrollers visit </span><a target="_blank" href="http://www.st.com/internet/mcu/family/141.jsp"><u><span style="color: blue;">www.st.com</span></u></a></span><span style="font-size: 10pt; font-family: Verdana;"><u><span style="color: blue;"><a href="http://www.st.com/stm32l" target="_blank"></a></span></u></span><span style="color: black;"><o:p></o:p></span></p>
+             </td>
+           </tr>
+         </tbody>
+       </table>
+       <p class="MsoNormal"><span style="font-size: 10pt;"><o:p></o:p></span></p>
+       </td>
+     </tr>
+   </tbody>
+ </table>
+ </div>
+ <p class="MsoNormal"><o:p>&nbsp;</o:p></p>
+ </div>
+ 
+ </body></html>
\ Kein Zeilenumbruch am Dateiende.
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/stm8l101_eval.c ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/stm8l101_eval.c
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/stm8l101_eval.c	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/stm8l101_eval.c	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,353 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l101_eval.c
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file provides firmware functions to manage Leds, push-buttons
+   *          and COM ports available on STM8L Evaluation Boards from STMicroelectronics.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l101_eval.h"
+ #include "stm8l10x_spi.h"
+ #include "stm8l10x_i2c.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+ 
+ 
+ /** @addtogroup STM8L101_EVAL
+   * @{
+   */
+ 
+ /** @defgroup STM8L101_EVAL_LOW_LEVEL
+   * @brief This file provides firmware functions to manage Leds, push-buttons,
+   *        COM ports, SD card on SPI and EEPROM (sEE) available on STM8L101-EVAL
+   *        evaluation board from STMicroelectronics.
+   * @{
+   */
+ 
+ /* Private typedef -----------------------------------------------------------*/
+ /* Private define ------------------------------------------------------------*/
+ /* Private macro -------------------------------------------------------------*/
+ /* Private variables ---------------------------------------------------------*/
+ GPIO_TypeDef* LED_PORT[LEDn] = {LED1_GPIO_PORT, LED2_GPIO_PORT, LED3_GPIO_PORT,
+                                 LED4_GPIO_PORT};
+ CONST uint8_t LED_PIN[LEDn] =
+   {
+     LED1_GPIO_PIN, LED2_GPIO_PIN, LED3_GPIO_PIN,
+     LED4_GPIO_PIN,
+   };
+ 
+ GPIO_TypeDef* BUTTON_PORT[BUTTONn] =
+   {
+     KEY_BUTTON_PORT, RIGHT_BUTTON_PORT,
+     LEFT_BUTTON_PORT, UP_BUTTON_PORT,
+     DOWN_BUTTON_PORT, SEL_BUTTON_PORT
+   };
+ CONST uint8_t BUTTON_PIN[BUTTONn] =
+   {
+     KEY_BUTTON_PIN, RIGHT_BUTTON_PIN,
+     LEFT_BUTTON_PIN, UP_BUTTON_PIN,
+     DOWN_BUTTON_PIN, SEL_BUTTON_PIN
+   };
+ 
+ CONST uint8_t BUTTON_EXTI[BUTTONn] =
+   {
+     KEY_BUTTON_EXTI, RIGHT_BUTTON_EXTI,
+     LEFT_BUTTON_EXTI, UP_BUTTON_EXTI,
+     DOWN_BUTTON_EXTI, SEL_BUTTON_EXTI
+   };
+ 
+ 
+ USART_TypeDef* COM_USART[COMn] =
+   {
+     EVAL_COM1
+   };
+ 
+ GPIO_TypeDef* COM_PORT[COMn] =
+   {
+     EVAL_COM1_GPIO
+   };
+ CONST uint8_t COM_USART_CLK[COMn] =
+   {
+     EVAL_COM1_CLK
+   };
+ CONST uint8_t COM_TX_PIN[COMn] =
+   {
+     EVAL_COM1_TxPin
+   };
+ CONST uint8_t COM_RX_PIN[COMn] =
+   {
+     EVAL_COM1_RxPin
+   };
+ /* Private function prototypes -----------------------------------------------*/
+ /* Private functions ---------------------------------------------------------*/
+ 
+ /** @defgroup STM8L101_EVAL_LOW_LEVEL_Private_Functions
+   * @{
+   */
+ 
+ /**
+   * @brief  Configures LED GPIO.
+   * @param  Led: Specifies the Led to be configured.
+   *   This parameter can be one of following parameters:
+   *     @arg LED1
+   *     @arg LED2
+   *     @arg LED3
+   *     @arg LED4
+   * @retval None
+   */
+ void STM_EVAL_LEDInit(Led_TypeDef Led)
+ {
+   /* Configure the GPIO_LED pin */
+   GPIO_Init(LED_PORT[Led], LED_PIN[Led], GPIO_Mode_Out_PP_High_Fast);
+ }
+ 
+ /**
+   * @brief  Turns selected LED On.
+   * @param  Led: Specifies the Led to be set on.
+   *   This parameter can be one of following parameters:
+   *     @arg LED1
+   *     @arg LED2
+   *     @arg LED3
+   *     @arg LED4
+   * @retval None
+   */
+ void STM_EVAL_LEDOn(Led_TypeDef Led)
+ {
+   LED_PORT[Led]->ODR &= (uint8_t)~LED_PIN[Led];
+ }
+ 
+ /**
+   * @brief  Turns selected LED Off.
+   * @param  Led: Specifies the Led to be set off.
+   *   This parameter can be one of following parameters:
+   *     @arg LED1
+   *     @arg LED2
+   *     @arg LED3
+   *     @arg LED4
+   * @retval None
+   */
+ void STM_EVAL_LEDOff(Led_TypeDef Led)
+ {
+   LED_PORT[Led]->ODR |= (uint8_t)LED_PIN[Led];
+ }
+ 
+ /**
+   * @brief  Toggles the selected LED.
+   * @param  Led: Specifies the Led to be toggled.
+   *   This parameter can be one of following parameters:
+   *     @arg LED1
+   *     @arg LED2
+   *     @arg LED3
+   *     @arg LED4
+   * @retval None
+   */
+ void STM_EVAL_LEDToggle(Led_TypeDef Led)
+ {
+   LED_PORT[Led]->ODR ^= (uint8_t)LED_PIN[Led];
+ }
+ 
+ /**
+   * @brief  Configures Button GPIO and EXTI Line.
+   * @param  Button: Specifies the Button to be configured.
+   *   This parameter can be one of following parameters:
+   *     @arg BUTTON_KEY: Key Push Button
+   *     @arg BUTTON_RIGHT: Joystick Right Push Button
+   *     @arg BUTTON_LEFT: Joystick Left Push Button
+   *     @arg BUTTON_UP: Joystick Up Push Button
+   *     @arg BUTTON_DOWN: Joystick Down Push Button
+   *     @arg BUTTON_SEL: Joystick Sel Push Button
+   * @param  Button_Mode: Specifies Button mode.
+   *   This parameter can be one of following parameters:
+   *     @arg BUTTON_MODE_GPIO: Button will be used as simple IO
+   *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI pin (sensitive to falling trigger)
+   * @retval None
+   */
+ void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
+ {
+ 
+   if (Button_Mode == BUTTON_MODE_EXTI)
+   { /* Pin configured in input floating mode with interrupt enabled
+                        --> connected to EXTIx Interrupt, where x:0..7 */
+     GPIO_Init(BUTTON_PORT[Button], BUTTON_PIN[Button], GPIO_Mode_In_FL_IT);
+     EXTI_SetPinSensitivity((EXTI_Pin_TypeDef)BUTTON_EXTI[(uint8_t)Button], EXTI_Trigger_Falling);
+   }
+   else
+   { /* Pin configured in input floating mode with interrupt disabled */
+     GPIO_Init(BUTTON_PORT[Button], BUTTON_PIN[Button], GPIO_Mode_In_FL_No_IT);
+   }
+ }
+ 
+ /**
+   * @brief  Returns the selected Button state.
+   * @param  Button: Specifies the Button to be checked.
+   *   This parameter can be one of following parameters:
+   *     @arg BUTTON_KEY: Key Push Button
+   *     @arg BUTTON_RIGHT: Joystick Right Push Button
+   *     @arg BUTTON_LEFT: Joystick Left Push Button
+   *     @arg BUTTON_UP: Joystick Up Push Button
+   *     @arg BUTTON_DOWN: Joystick Down Push Button
+   *     @arg BUTTON_SEL: Joystick Sel Push Button
+   * @retval The Button GPIO pin value.
+   */
+ uint8_t STM_EVAL_PBGetState(Button_TypeDef Button)
+ {
+   return GPIO_ReadInputDataBit(BUTTON_PORT[Button], (GPIO_Pin_TypeDef)BUTTON_PIN[Button]);
+ }
+ 
+ 
+ /**
+   * @brief  Configures COM port.
+   * @param  COM: Specifies the COM port to be configured.
+   *   This parameter should be COM1.
+   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that
+   *   contains the configuration information for the specified USART peripheral.
+   * @retval None
+   */
+ void STM_EVAL_COMInit(COM_TypeDef COM, uint32_t USART_BaudRate,
+                       USART_WordLength_TypeDef USART_WordLength,
+                       USART_StopBits_TypeDef USART_StopBits,
+                       USART_Parity_TypeDef USART_Parity,
+                       USART_Mode_TypeDef USART_Mode)
+ {
+   /* Enable USART clock */
+   CLK_PeripheralClockConfig((CLK_Peripheral_TypeDef)COM_USART_CLK[COM], ENABLE);
+ 
+   /* Configure USART Tx as alternate function push-pull  (software pull up)*/
+   GPIO_ExternalPullUpConfig(COM_PORT[COM], COM_TX_PIN[COM], ENABLE);
+ 
+   /* Configure USART Rx as alternate function push-pull  (software pull up)*/
+   GPIO_ExternalPullUpConfig(COM_PORT[COM], COM_RX_PIN[COM], ENABLE);
+ 
+   /* USART configuration */
+   USART_Init(USART_BaudRate, USART_WordLength, USART_StopBits, USART_Parity, USART_Mode);
+ }
+ 
+ /**
+   * @brief  DeInitializes the SD/SD communication.
+   * @param  None
+   * @retval None
+   */
+ void SD_LowLevel_DeInit(void)
+ {
+   SPI_Cmd(DISABLE); /*!< SD_SPI disable */
+ 
+   /*!< SD_SPI Periph clock disable */
+   CLK_PeripheralClockConfig(SD_SPI_CLK, DISABLE);
+ 
+   /*!< Configure SD_SPI pins: SCK */
+   GPIO_Init(SD_SPI_SCK_GPIO_PORT, SD_SPI_SCK_PIN, GPIO_Mode_In_FL_No_IT);
+ 
+   /*!< Configure SD_SPI pins: MISO */
+   GPIO_Init(SD_SPI_MISO_GPIO_PORT, SD_SPI_MISO_PIN, GPIO_Mode_In_FL_No_IT);
+ 
+   /*!< Configure SD_SPI pins: MOSI */
+   GPIO_Init(SD_SPI_MOSI_GPIO_PORT, SD_SPI_MOSI_PIN, GPIO_Mode_In_FL_No_IT);
+ 
+   /*!< Configure SD_SPI_CS_PIN pin: SD Card CS pin */
+   GPIO_Init(SD_CS_GPIO_PORT, SD_CS_PIN, GPIO_Mode_In_FL_No_IT);
+ 
+ }
+ 
+ /**
+   * @brief  Initializes the SD_SPI and CS pins.
+   * @param  None
+   * @retval None
+   */
+ void SD_LowLevel_Init(void)
+ {
+   /* Enable SPI clock */
+   CLK_PeripheralClockConfig(SD_SPI_CLK, ENABLE);
+ 
+   /* Set the MOSI,MISO and SCK at high level */
+   GPIO_ExternalPullUpConfig(SD_SPI_SCK_GPIO_PORT, SD_SPI_MISO_PIN | SD_SPI_MOSI_PIN | \
+                             SD_SPI_SCK_PIN, ENABLE);
+ 
+   /* SD_SPI Config */
+   SPI_Init(SPI_FirstBit_MSB, SPI_BaudRatePrescaler_4, SPI_Mode_Master,
+            SPI_CPOL_High, SPI_CPHA_2Edge, SPI_Direction_2Lines_FullDuplex,
+            SPI_NSS_Soft);
+ 
+ 
+   /* SD_SPI enable */
+   SPI_Cmd(ENABLE);
+ 
+   /* Set MSD ChipSelect pin in Output push-pull high level */
+   GPIO_Init(SD_CS_GPIO_PORT, SD_CS_PIN, GPIO_Mode_Out_PP_High_Slow);
+ }
+ 
+ /**
+   * @brief  DeInitializes peripherals used by the I2C EEPROM driver.
+   * @param  None
+   * @retval None
+   */
+ void sEE_LowLevel_DeInit(void)
+ {
+   /* sEE_I2C Peripheral Disable */
+   I2C_Cmd(DISABLE);
+ 
+   /* sEE_I2C DeInit */
+   I2C_DeInit();
+ 
+   /*!< sEE_I2C Periph clock disable */
+   CLK_PeripheralClockConfig(sEE_I2C_CLK, DISABLE);
+ 
+   /*!< GPIO configuration */
+   /*!< Configure sEE_I2C pins: SCL */
+   GPIO_Init(sEE_I2C_SCL_GPIO_PORT, sEE_I2C_SCL_PIN, GPIO_Mode_In_PU_No_IT);
+ 
+   /*!< Configure sEE_I2C pins: SDA */
+   GPIO_Init(sEE_I2C_SDA_GPIO_PORT, sEE_I2C_SDA_PIN, GPIO_Mode_In_PU_No_IT);
+ }
+ 
+ /**
+   * @brief  Initializes peripherals used by the I2C EEPROM driver.
+   * @param  None
+   * @retval None
+   */
+ void sEE_LowLevel_Init(void)
+ {
+   /*!< sEE_I2C Periph clock enable */
+   CLK_PeripheralClockConfig(sEE_I2C_CLK, ENABLE);
+ }
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ 
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff -rcN ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/stm8l101_eval.h ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/stm8l101_eval.h
*** ./STM8L10x_StdPeriph_Lib_V1.2.1/Utilities/STM8L101_EVAL/stm8l101_eval.h	1970-01-01 01:00:00.000000000 +0100
--- ./STM8L10x_StdPeriph_Lib_V1.2.1_sdcc/Utilities/STM8L101_EVAL/stm8l101_eval.h	2014-10-21 14:13:34.000000000 +0200
***************
*** 0 ****
--- 1,293 ----
+ /**
+   ******************************************************************************
+   * @file    stm8l101_eval.h
+   * @author  MCD Application Team
+   * @version V1.2.1
+   * @date    30-September-2014
+   * @brief   This file contains definitions for STM8L101_EVAL's Leds, push-buttons
+   *          and COM ports hardware resources.
+   ******************************************************************************
+   * @attention
+   *
+   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
+   *
+   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
+   * You may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at:
+   *
+   *        http://www.st.com/software_license_agreement_liberty_v2
+   *
+   * Unless required by applicable law or agreed to in writing, software 
+   * distributed under the License is distributed on an "AS IS" BASIS, 
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   *
+   ******************************************************************************
+   */
+ 
+ /* Define to prevent recursive inclusion -------------------------------------*/
+ #ifndef __STM8L101_EVAL_H
+ #define __STM8L101_EVAL_H
+ 
+ /* Includes ------------------------------------------------------------------*/
+ #include "stm8l10x.h"
+ 
+ /** @addtogroup Utilities
+   * @{
+   */
+ 
+ /** @addtogroup STM8L101_EVAL
+   * @{
+   */
+ /** @defgroup STM8L_EVAL_HARDWARE_RESOURCES
+   * @{
+   */
+ 
+ /**
+ @code
+  The table below gives an overview of the hardware resources supported by the 
+  STM8L101 EVAL board.
+      - LCD: Mono LCD (Serial (SPI))
+      - sEE: serial I2C EEPROM (M24C32)
+      - SD: SD Card memory (SPI (SD Card MODE))
+   =============================================================================================+
+     STM8 EVAL     | LED | Buttons  | Com Ports |    LCD    | sFLASH | sEE | TSENSOR | SD (SPI) |
+   -============================================================================================+
+    STM8L101-EVAL  |  5  |    6     |     1     | YES (SPI) |  NO    | YES |   NO    |    YES   |
+   =============================================================================================+
+ @endcode
+ */
+ /**
+   * @}
+   */
+   
+ /** @addtogroup STM8L101_EVAL_LOW_LEVEL
+   * @{
+   */
+ 
+ /** @defgroup STM8L_EVAL_Exported_Types
+   * @{
+   */
+ typedef enum
+ {
+   LED1 = 0,
+   LED2 = 1,
+   LED3 = 2,
+   LED4 = 3,
+   LED5 = 4  /* Bicolor Led */
+ } Led_TypeDef;
+ 
+ typedef enum
+ {
+   BUTTON_KEY = 0,
+   BUTTON_RIGHT = 1,
+   BUTTON_LEFT = 2,
+   BUTTON_UP = 3,
+   BUTTON_DOWN = 4,
+   BUTTON_SEL = 5,
+   BUTTON_TAMPER = 6
+ } Button_TypeDef;
+ 
+ typedef enum
+ {
+   BUTTON_MODE_GPIO = 0,
+   BUTTON_MODE_EXTI = 1
+ } ButtonMode_TypeDef;
+ 
+ typedef enum
+ {
+   JOY_NONE = 0,
+   JOY_SEL = 1,
+   JOY_DOWN = 2,
+   JOY_LEFT = 3,
+   JOY_RIGHT = 4,
+   JOY_UP = 5
+ } JOYState_TypeDef;
+ 
+ typedef enum
+ {
+   COM1 = 0
+ } COM_TypeDef;
+ 
+ /** @defgroup STM8L_EVAL_LOW_LEVEL_Exported_Constants
+   * @{
+   */
+ /** @addtogroup STM8L_EVAL_LOW_LEVEL_LED
+   * @{
+   */
+ 
+ #define LEDn                        4
+ #define LED1_GPIO_PORT              GPIOB
+ #define LED1_GPIO_PIN               GPIO_Pin_0
+ 
+ #define LED2_GPIO_PORT              GPIOD
+ #define LED2_GPIO_PIN               GPIO_Pin_4
+ 
+ #define LED3_GPIO_PORT              GPIOD
+ #define LED3_GPIO_PIN               GPIO_Pin_5
+ 
+ #define LED4_GPIO_PORT              GPIOD
+ #define LED4_GPIO_PIN               GPIO_Pin_6
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup STM8L_EVAL_LOW_LEVEL_BUTTON
+   * @{
+   */
+ #define BUTTONn                     6
+ 
+ /**
+  * @brief Key push-button
+  */
+ #define KEY_BUTTON_PORT             GPIOA
+ #define KEY_BUTTON_PIN              GPIO_Pin_5
+ 
+ /**
+  * @brief Joystick Right push-button
+  */
+ #define RIGHT_BUTTON_PORT           GPIOB
+ #define RIGHT_BUTTON_PIN            GPIO_Pin_2
+ 
+ /**
+  * @brief Joystick Left push-button
+  */
+ #define LEFT_BUTTON_PORT            GPIOB
+ #define LEFT_BUTTON_PIN             GPIO_Pin_1
+ 
+ /**
+  * @brief Joystick Up push-button
+  */
+ #define UP_BUTTON_PORT              GPIOB
+ #define UP_BUTTON_PIN               GPIO_Pin_3
+ 
+ /**
+  * @brief Joystick Down push-button
+  */
+ #define DOWN_BUTTON_PORT            GPIOA
+ #define DOWN_BUTTON_PIN             GPIO_Pin_4
+ 
+ /**
+  * @brief Joystick Sel push-button
+  */
+ #define SEL_BUTTON_PORT             GPIOD
+ #define SEL_BUTTON_PIN              GPIO_Pin_7
+ 
+ 
+ /**
+  * @brief Joystick EXTI push-button definition
+  */
+ #define KEY_BUTTON_EXTI             EXTI_Pin_5
+ #define RIGHT_BUTTON_EXTI           EXTI_Pin_2
+ #define LEFT_BUTTON_EXTI            EXTI_Pin_1
+ #define UP_BUTTON_EXTI              EXTI_Pin_3
+ #define DOWN_BUTTON_EXTI            EXTI_Pin_4
+ #define SEL_BUTTON_EXTI             EXTI_Pin_7
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup STM8L_EVAL_LOW_LEVEL_COM
+   * @{
+   */
+ #define COMn                        1
+ 
+ /**
+  * @brief Definition for COM port1
+  */
+ #define EVAL_COM1                   USART
+ #define EVAL_COM1_GPIO              GPIOC
+ #define EVAL_COM1_CLK               CLK_Peripheral_USART
+ #define EVAL_COM1_RxPin             GPIO_Pin_2
+ #define EVAL_COM1_TxPin             GPIO_Pin_3
+ 
+ /**
+   * @}
+   */
+ /** @addtogroup STM8L_EVAL_SD_SPI
+   * @{
+   */
+ /**
+   * @brief  SD SPI Interface pins
+   */
+ #define SD_SPI                           SPI
+ #define SD_SPI_CLK                       CLK_Peripheral_SPI
+ #define SD_SPI_SCK_PIN                   GPIO_Pin_5                  /* PB.05 */
+ #define SD_SPI_SCK_GPIO_PORT             GPIOB                       /* GPIOB */
+ #define SD_SPI_MISO_PIN                  GPIO_Pin_7                  /* PB.07 */
+ #define SD_SPI_MISO_GPIO_PORT            GPIOB                       /* GPIOB */
+ #define SD_SPI_MOSI_PIN                  GPIO_Pin_6                  /* PB.06 */
+ #define SD_SPI_MOSI_GPIO_PORT            GPIOB                       /* GPIOB */
+ #define SD_CS_PIN                        GPIO_Pin_4                  /* PB.04 */
+ #define SD_CS_GPIO_PORT                  GPIOB                       /* GPIOB */
+ 
+ /**
+   * @}
+   */
+ 
+ /** @addtogroup STM8L_EVAL_LOW_LEVEL_I2C_EE
+   * @{
+   */
+ /**
+   * @brief  I2C EEPROM Interface pins
+   */
+ #define sEE_I2C                          I2C
+ #define sEE_I2C_CLK                      CLK_Peripheral_I2C
+ #define sEE_I2C_SCL_PIN                  GPIO_Pin_1                  /* PC.01 */
+ #define sEE_I2C_SCL_GPIO_PORT            GPIOC                       /* GPIOC */
+ #define sEE_I2C_SDA_PIN                  GPIO_Pin_0                  /* PC.00 */
+ #define sEE_I2C_SDA_GPIO_PORT            GPIOC                       /* GPIOC */
+ #define sEE_M24C64_32
+ 
+ #define sEE_DIRECTION_TX                 0
+ #define sEE_DIRECTION_RX                 1
+ 
+ /**
+   * @}
+   */
+ 
+ /* Exported Macros ------------------------------------------------------------*/
+ 
+ /** @defgroup STM8L_EVAL_LOW_LEVEL_Exported_Functions
+   * @{
+   */
+ void STM_EVAL_LEDInit(Led_TypeDef Led);
+ void STM_EVAL_LEDOn(Led_TypeDef Led);
+ void STM_EVAL_LEDOff(Led_TypeDef Led);
+ void STM_EVAL_LEDToggle(Led_TypeDef Led);
+ void STM_EVAL_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode);
+ uint8_t STM_EVAL_PBGetState(Button_TypeDef Button);
+ void STM_EVAL_COMInit(COM_TypeDef COM, uint32_t USART_BaudRate, USART_WordLength_TypeDef USART_WordLength,\
+                       USART_StopBits_TypeDef USART_StopBits,\
+                       USART_Parity_TypeDef USART_Parity,\
+                       USART_Mode_TypeDef USART_Mode);
+ void SD_LowLevel_DeInit(void);
+ void SD_LowLevel_Init(void);
+ void sEE_LowLevel_DeInit(void);
+ void sEE_LowLevel_Init(void);
+ 
+ /**
+   * @}
+   */
+ 
+ #endif /* __STM8L101_EVAL_H */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ 
+ /**
+   * @}
+   */
+ /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
